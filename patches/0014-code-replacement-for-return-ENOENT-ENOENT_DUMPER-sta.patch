From caacb78dd4607d75dc548148133c3982f3070a03 Mon Sep 17 00:00:00 2001
From: user <user@localhost.localdomain>
Date: Wed, 12 Aug 2020 09:51:37 -0400
Subject: [PATCH 14/14] code replacement for return -ENOENT; ->
 ENOENT_DUMPER(stackdump_tuneable);

---
 arch/alpha/kernel/perf_event.c                |  2 +-
 arch/arc/kernel/perf_event.c                  | 10 ++--
 arch/arm/kernel/cpuidle.c                     |  2 +-
 arch/arm/mach-axxia/platsmp.c                 |  2 +-
 arch/arm/mach-bcm/bcm63xx_smp.c               |  2 +-
 arch/arm/mach-bcm/platsmp.c                   |  2 +-
 arch/arm/mach-davinci/cpuidle.c               |  2 +-
 arch/arm/mach-exynos/suspend.c                |  4 +-
 arch/arm/mach-hisi/hotplug.c                  |  2 +-
 arch/arm/mach-imx/mmdc.c                      |  2 +-
 arch/arm/mach-mvebu/cpu-reset.c               |  2 +-
 arch/arm/mach-omap2/omap_hwmod.c              | 12 ++---
 arch/arm/mach-omap2/pm.c                      |  2 +-
 arch/arm/mach-omap2/prm_common.c              |  4 +-
 arch/arm/mach-prima2/pm.c                     |  2 +-
 arch/arm/mach-s3c24xx/irq-pm.c                |  2 +-
 arch/arm/mm/cache-l2x0-pmu.c                  |  2 +-
 arch/arm/mm/pmsa-v7.c                         |  2 +-
 arch/arm/mm/pmsa-v8.c                         |  2 +-
 arch/arm/plat-samsung/adc.c                   |  2 +-
 arch/arm/plat-samsung/pm.c                    |  2 +-
 arch/arm64/include/asm/acpi.h                 |  2 +-
 arch/arm64/kvm/arm.c                          |  2 +-
 arch/arm64/kvm/guest.c                        | 12 ++---
 arch/arm64/kvm/psci.c                         |  4 +-
 arch/arm64/kvm/sys_regs.c                     | 32 ++++++------
 arch/csky/kernel/perf_event.c                 | 10 ++--
 arch/mips/alchemy/devboards/pm.c              |  2 +-
 arch/mips/kernel/cacheinfo.c                  |  2 +-
 arch/mips/kernel/perf_event_mipsxx.c          |  2 +-
 arch/mips/lantiq/xway/gptu.c                  |  2 +-
 arch/nds32/kernel/perf_event_cpu.c            | 16 +++---
 arch/parisc/kernel/module.c                   |  4 +-
 arch/powerpc/include/asm/kvm_ppc.h            |  4 +-
 arch/powerpc/kernel/eeh.c                     |  6 +--
 arch/powerpc/kernel/iommu.c                   |  2 +-
 arch/powerpc/kernel/module_32.c               |  2 +-
 arch/powerpc/kernel/module_64.c               |  6 +--
 arch/powerpc/kernel/ptrace/ptrace-adv.c       | 12 ++---
 arch/powerpc/kernel/ptrace/ptrace-noadv.c     |  2 +-
 arch/powerpc/kernel/rtas.c                    | 12 ++---
 arch/powerpc/kernel/smp.c                     |  2 +-
 arch/powerpc/kexec/core.c                     |  2 +-
 arch/powerpc/kexec/file_load.c                |  2 +-
 arch/powerpc/kexec/ima.c                      |  6 +--
 arch/powerpc/kvm/book3s_32_mmu.c              |  4 +-
 arch/powerpc/kvm/book3s_64_mmu.c              |  4 +-
 arch/powerpc/kvm/book3s_64_mmu_hv.c           |  2 +-
 arch/powerpc/kvm/book3s_64_mmu_radix.c        |  2 +-
 arch/powerpc/kvm/book3s_hv.c                  |  2 +-
 arch/powerpc/kvm/book3s_rtas.c                |  2 +-
 arch/powerpc/kvm/book3s_xics.c                |  6 +--
 arch/powerpc/kvm/book3s_xive.c                |  8 +--
 arch/powerpc/kvm/book3s_xive_native.c         | 14 ++---
 arch/powerpc/kvm/booke.c                      |  2 +-
 arch/powerpc/kvm/powerpc.c                    |  2 +-
 arch/powerpc/mm/book3s64/hash_native.c        |  2 +-
 arch/powerpc/mm/book3s64/subpage_prot.c       |  2 +-
 arch/powerpc/perf/8xx-pmu.c                   |  2 +-
 arch/powerpc/perf/core-book3s.c               |  4 +-
 arch/powerpc/perf/core-fsl-emb.c              |  2 +-
 arch/powerpc/perf/hv-24x7.c                   |  2 +-
 arch/powerpc/perf/hv-gpci.c                   |  2 +-
 arch/powerpc/perf/imc-pmu.c                   | 10 ++--
 arch/powerpc/platforms/44x/iss4xx.c           |  2 +-
 arch/powerpc/platforms/44x/warp.c             | 14 ++---
 arch/powerpc/platforms/85xx/smp.c             |  4 +-
 arch/powerpc/platforms/86xx/mpc86xx_smp.c     |  2 +-
 arch/powerpc/platforms/cell/axon_msi.c        |  2 +-
 arch/powerpc/platforms/cell/smp.c             |  2 +-
 arch/powerpc/platforms/powermac/smp.c         |  2 +-
 arch/powerpc/platforms/powernv/ocxl.c         |  4 +-
 arch/powerpc/platforms/powernv/ultravisor.c   |  2 +-
 arch/powerpc/platforms/powernv/vas.c          |  2 +-
 arch/powerpc/platforms/ps3/repository.c       |  8 +--
 arch/powerpc/platforms/pseries/lpar.c         |  2 +-
 arch/powerpc/platforms/pseries/mobility.c     |  8 +--
 arch/powerpc/platforms/pseries/msi.c          |  2 +-
 arch/powerpc/platforms/pseries/rtas-fadump.c  |  2 +-
 arch/powerpc/platforms/pseries/smp.c          |  2 +-
 arch/powerpc/sysdev/fsl_lbc.c                 |  2 +-
 arch/riscv/kernel/module.c                    |  2 +-
 arch/riscv/kernel/perf_event.c                |  4 +-
 arch/s390/kernel/perf_cpum_cf.c               | 14 ++---
 arch/s390/kernel/perf_cpum_sf.c               |  8 +--
 arch/s390/mm/extmem.c                         |  2 +-
 arch/s390/net/pnet.c                          |  2 +-
 arch/sh/drivers/dma/dmabrg.c                  |  2 +-
 arch/sh/kernel/perf_event.c                   |  2 +-
 arch/sh/kernel/smp.c                          |  2 +-
 arch/sparc/kernel/pci_msi.c                   |  2 +-
 arch/sparc/kernel/perf_event.c                |  2 +-
 arch/sparc/mm/init_64.c                       |  8 +--
 arch/um/drivers/pty.c                         |  2 +-
 arch/um/os-Linux/execvp.c                     |  2 +-
 arch/x86/events/amd/core.c                    |  4 +-
 arch/x86/events/amd/ibs.c                     |  6 +--
 arch/x86/events/amd/iommu.c                   |  2 +-
 arch/x86/events/amd/power.c                   |  2 +-
 arch/x86/events/amd/uncore.c                  |  4 +-
 arch/x86/events/core.c                        |  8 +--
 arch/x86/events/intel/bts.c                   |  2 +-
 arch/x86/events/intel/cstate.c                |  4 +-
 arch/x86/events/intel/pt.c                    |  2 +-
 arch/x86/events/intel/uncore.c                |  4 +-
 arch/x86/events/intel/uncore_snb.c            |  4 +-
 arch/x86/events/msr.c                         |  4 +-
 arch/x86/events/rapl.c                        |  2 +-
 arch/x86/kernel/cpu/cacheinfo.c               |  2 +-
 arch/x86/kernel/cpu/resctrl/ctrlmondata.c     |  2 +-
 arch/x86/kernel/cpu/resctrl/rdtgroup.c        | 12 ++---
 arch/x86/kvm/hyperv.c                         |  6 +--
 arch/x86/kvm/vmx/evmcs.h                      |  2 +-
 arch/x86/kvm/vmx/vmcs12.h                     |  6 +--
 arch/x86/kvm/vmx/vmx.c                        |  2 +-
 arch/x86/mm/amdtopology.c                     |  6 +--
 arch/x86/mm/numa_emulation.c                  |  2 +-
 arch/x86/pci/mmconfig-shared.c                |  2 +-
 arch/xtensa/kernel/hw_breakpoint.c            |  2 +-
 arch/xtensa/kernel/perf_event.c               |  2 +-
 block/blk-mq-debugfs.c                        |  2 +-
 block/elevator.c                              |  2 +-
 crypto/algapi.c                               |  4 +-
 crypto/crypto_user_base.c                     |  6 +--
 crypto/crypto_user_stat.c                     |  2 +-
 drivers/acpi/acpi_apd.c                       |  2 +-
 drivers/acpi/acpi_lpat.c                      |  4 +-
 drivers/acpi/apei/erst.c                      |  2 +-
 drivers/acpi/apei/ghes.c                      |  6 +--
 drivers/acpi/numa/srat.c                      |  2 +-
 drivers/acpi/pmic/intel_pmic.c                |  2 +-
 drivers/acpi/pmic/tps68470_pmic.c             |  2 +-
 drivers/acpi/pptt.c                           |  8 +--
 drivers/acpi/property.c                       |  8 +--
 drivers/acpi/spcr.c                           |  2 +-
 drivers/ata/ata_piix.c                        |  2 +-
 drivers/ata/libata-acpi.c                     |  4 +-
 drivers/ata/libata-core.c                     | 12 ++---
 drivers/ata/libata-sata.c                     |  2 +-
 drivers/ata/libata-sff.c                      |  2 +-
 drivers/ata/pata_amd.c                        |  4 +-
 drivers/ata/pata_arasan_cf.c                  |  2 +-
 drivers/ata/pata_artop.c                      |  2 +-
 drivers/ata/pata_atiixp.c                     |  2 +-
 drivers/ata/pata_efar.c                       |  2 +-
 drivers/ata/pata_hpt37x.c                     |  2 +-
 drivers/ata/pata_it8213.c                     |  2 +-
 drivers/ata/pata_jmicron.c                    |  6 +--
 drivers/ata/pata_marvell.c                    |  2 +-
 drivers/ata/pata_mpiix.c                      |  2 +-
 drivers/ata/pata_ns87410.c                    |  2 +-
 drivers/ata/pata_oldpiix.c                    |  2 +-
 drivers/ata/pata_opti.c                       |  2 +-
 drivers/ata/pata_optidma.c                    |  2 +-
 drivers/ata/pata_pdc2027x.c                   |  2 +-
 drivers/ata/pata_rb532_cf.c                   |  2 +-
 drivers/ata/pata_rdc.c                        |  2 +-
 drivers/ata/pata_sis.c                        |  2 +-
 drivers/ata/pata_sl82c105.c                   |  2 +-
 drivers/ata/pata_triflex.c                    |  2 +-
 drivers/ata/pata_via.c                        |  2 +-
 drivers/atm/solos-pci.c                       |  2 +-
 drivers/base/cacheinfo.c                      | 12 ++---
 drivers/base/devres.c                         |  4 +-
 drivers/base/firmware_loader/fallback.h       |  2 +-
 .../base/firmware_loader/fallback_platform.c  |  2 +-
 drivers/base/firmware_loader/firmware.h       |  2 +-
 drivers/base/firmware_loader/main.c           |  2 +-
 drivers/base/power/clock_ops.c                |  2 +-
 drivers/base/regmap/regcache-rbtree.c         |  4 +-
 drivers/base/regmap/regcache.c                |  2 +-
 drivers/base/swnode.c                         |  8 +--
 drivers/bcma/scan.c                           |  8 +--
 drivers/bcma/sprom.c                          |  2 +-
 drivers/block/rbd.c                           |  6 +--
 drivers/block/sx8.c                           |  2 +-
 drivers/block/xen-blkback/xenbus.c            |  4 +-
 drivers/bluetooth/btrtl.c                     |  2 +-
 drivers/bluetooth/btrtl.h                     |  2 +-
 drivers/bus/fsl-mc/fsl-mc-msi.c               |  2 +-
 drivers/bus/ti-sysc.c                         |  6 +--
 drivers/bus/uniphier-system-bus.c             |  2 +-
 drivers/char/hw_random/octeon-rng.c           | 10 ++--
 drivers/char/ipmi/ipmi_msghandler.c           |  4 +-
 drivers/char/random.c                         |  2 +-
 drivers/char/tpm/tpm2-space.c                 |  4 +-
 drivers/clk/bcm/clk-raspberrypi.c             |  2 +-
 drivers/clk/clk.c                             |  2 +-
 drivers/clk/hisilicon/crg-hi3516cv300.c       |  2 +-
 drivers/clk/hisilicon/crg-hi3798cv200.c       |  2 +-
 drivers/clk/imx/clk-imx6q.c                   |  4 +-
 drivers/clk/qcom/common.c                     |  2 +-
 drivers/clk/renesas/rcar-usb2-clock-sel.c     |  2 +-
 drivers/clk/tegra/clk-dfll.c                  |  2 +-
 drivers/clk/tegra/clk-tegra124-emc.c          |  2 +-
 drivers/clk/ti/clk.c                          |  2 +-
 drivers/cpufreq/brcmstb-avs-cpufreq.c         |  2 +-
 drivers/cpufreq/freq_table.c                  |  2 +-
 drivers/cpufreq/highbank-cpufreq.c            |  2 +-
 drivers/cpufreq/imx6q-cpufreq.c               |  6 +--
 drivers/cpufreq/qcom-cpufreq-nvmem.c          |  4 +-
 drivers/cpufreq/s3c2412-cpufreq.c             |  4 +-
 drivers/cpufreq/s3c2440-cpufreq.c             |  2 +-
 drivers/cpufreq/s3c24xx-cpufreq.c             |  4 +-
 drivers/cpufreq/speedstep-centrino.c          |  4 +-
 drivers/cpufreq/sun50i-cpufreq-nvmem.c        |  4 +-
 drivers/crypto/ccp/sev-dev.c                  |  2 +-
 drivers/crypto/hisilicon/sec2/sec_main.c      |  2 +-
 drivers/crypto/hisilicon/zip/zip_main.c       |  2 +-
 drivers/crypto/nx/nx-842-pseries.c            |  2 +-
 drivers/crypto/s5p-sss.c                      |  2 +-
 drivers/dma-buf/dma-fence.c                   |  2 +-
 drivers/dma/ti/k3-psil.c                      |  2 +-
 drivers/dma/ti/k3-udma-glue.c                 |  2 +-
 drivers/dma/ti/k3-udma.c                      |  6 +--
 drivers/edac/mv64x60_edac.c                   |  2 +-
 drivers/edac/thunderx_edac.c                  |  2 +-
 drivers/firewire/core-card.c                  |  2 +-
 drivers/firewire/core-device.c                |  2 +-
 drivers/firewire/core-transaction.c           |  2 +-
 drivers/firewire/net.c                        |  2 +-
 drivers/firmware/arm_sdei.c                   |  4 +-
 drivers/firmware/broadcom/bcm47xx_nvram.c     |  4 +-
 drivers/firmware/broadcom/bcm47xx_sprom.c     |  2 +-
 drivers/firmware/efi/efi.c                    |  2 +-
 drivers/firmware/efi/embedded-firmware.c      |  6 +--
 drivers/firmware/iscsi_ibft.c                 |  4 +-
 drivers/firmware/meson/meson_sm.c             |  6 +--
 drivers/firmware/tegra/bpmp-debugfs.c         |  4 +-
 drivers/fpga/dfl-fme-br.c                     |  2 +-
 drivers/fpga/dfl-fme-perf.c                   |  2 +-
 drivers/fpga/fpga-mgr.c                       |  2 +-
 drivers/fpga/fpga-region.c                    |  2 +-
 drivers/gpio/gpio-aggregator.c                |  2 +-
 drivers/gpio/gpio-amd-fch.c                   |  2 +-
 drivers/gpio/gpio-bcm-kona.c                  |  2 +-
 drivers/gpio/gpio-brcmstb.c                   |  2 +-
 drivers/gpio/gpio-em.c                        |  4 +-
 drivers/gpio/gpio-raspberrypi-exp.c           |  2 +-
 drivers/gpio/gpio-uniphier.c                  |  2 +-
 drivers/gpio/gpiolib-acpi.c                   |  4 +-
 drivers/gpio/gpiolib-sysfs.c                  |  2 +-
 drivers/gpio/gpiolib.c                        |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c   |  2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c       | 10 ++--
 drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c       | 10 ++--
 drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c       |  4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c       |  2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_pmu.c       |  2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c       |  2 +-
 .../gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c    |  2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c       |  2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c        |  6 +--
 drivers/gpu/drm/amd/amdgpu/dce_v10_0.c        |  2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v11_0.c        |  2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v6_0.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/jpeg_v2_5.c        |  2 +-
 drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/mxgpu_vi.c         |  4 +-
 drivers/gpu/drm/amd/amdgpu/si_dpm.c           | 14 ++---
 drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/vce_v3_0.c         |  2 +-
 drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c         |  2 +-
 drivers/gpu/drm/amd/powerplay/navi10_ppt.c    |  4 +-
 .../arm/display/komeda/komeda_framebuffer.c   |  4 +-
 drivers/gpu/drm/armada/armada_crtc.c          |  2 +-
 drivers/gpu/drm/armada/armada_gem.c           |  4 +-
 drivers/gpu/drm/drm_client.c                  |  2 +-
 drivers/gpu/drm/drm_color_mgmt.c              |  4 +-
 drivers/gpu/drm/drm_connector.c               |  2 +-
 drivers/gpu/drm/drm_crtc.c                    |  4 +-
 drivers/gpu/drm/drm_encoder.c                 |  2 +-
 drivers/gpu/drm/drm_framebuffer.c             | 10 ++--
 drivers/gpu/drm/drm_gem.c                     |  6 +--
 drivers/gpu/drm/drm_gem_vram_helper.c         |  2 +-
 drivers/gpu/drm/drm_mode_object.c             |  2 +-
 drivers/gpu/drm/drm_plane.c                   | 12 ++---
 drivers/gpu/drm/drm_prime.c                   |  2 +-
 drivers/gpu/drm/drm_property.c                |  6 +--
 drivers/gpu/drm/drm_syncobj.c                 |  8 +--
 drivers/gpu/drm/drm_sysfs.c                   |  2 +-
 drivers/gpu/drm/drm_vblank.c                  |  4 +-
 drivers/gpu/drm/etnaviv/etnaviv_drv.c         |  8 +--
 drivers/gpu/drm/exynos/exynos_drm_fimc.c      |  2 +-
 drivers/gpu/drm/exynos/exynos_drm_gsc.c       |  2 +-
 drivers/gpu/drm/exynos/exynos_drm_ipp.c       |  8 +--
 drivers/gpu/drm/gma500/psb_device.c           |  2 +-
 drivers/gpu/drm/i915/display/intel_display.c  |  2 +-
 drivers/gpu/drm/i915/display/intel_hdcp.c     |  4 +-
 drivers/gpu/drm/i915/display/intel_opregion.c |  2 +-
 drivers/gpu/drm/i915/display/intel_overlay.c  |  4 +-
 drivers/gpu/drm/i915/display/intel_sprite.c   |  2 +-
 drivers/gpu/drm/i915/gem/i915_gem_context.c   | 22 ++++----
 drivers/gpu/drm/i915/gem/i915_gem_domain.c    |  4 +-
 .../gpu/drm/i915/gem/i915_gem_execbuffer.c    |  4 +-
 drivers/gpu/drm/i915/gem/i915_gem_mman.c      |  4 +-
 drivers/gpu/drm/i915/gem/i915_gem_tiling.c    |  2 +-
 drivers/gpu/drm/i915/gem/i915_gem_wait.c      |  2 +-
 drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h      |  2 +-
 drivers/gpu/drm/i915/i915_gem.c               |  8 +--
 drivers/gpu/drm/i915/i915_pmu.c               |  6 +--
 drivers/gpu/drm/i915/i915_query.c             |  2 +-
 drivers/gpu/drm/imx/imx-ldb.c                 |  2 +-
 drivers/gpu/drm/lima/lima_gem.c               |  4 +-
 drivers/gpu/drm/lima/lima_vm.c                |  2 +-
 drivers/gpu/drm/mgag200/mgag200_cursor.c      |  2 +-
 drivers/gpu/drm/msm/adreno/a6xx_gmu.c         |  2 +-
 drivers/gpu/drm/msm/adreno/a6xx_hfi.c         |  2 +-
 drivers/gpu/drm/msm/disp/mdp4/mdp4_crtc.c     |  2 +-
 drivers/gpu/drm/msm/disp/mdp5/mdp5_crtc.c     |  2 +-
 drivers/gpu/drm/msm/msm_drv.c                 | 10 ++--
 drivers/gpu/drm/msm/msm_gem_submit.c          |  2 +-
 drivers/gpu/drm/msm/msm_submitqueue.c         |  6 +--
 drivers/gpu/drm/nouveau/dispnv04/crtc.c       |  2 +-
 drivers/gpu/drm/nouveau/dispnv04/hw.c         |  2 +-
 drivers/gpu/drm/nouveau/nouveau_bios.c        | 12 ++---
 drivers/gpu/drm/nouveau/nouveau_display.c     |  2 +-
 drivers/gpu/drm/nouveau/nouveau_gem.c         |  6 +--
 drivers/gpu/drm/nouveau/nouveau_usif.c        |  6 +--
 drivers/gpu/drm/nouveau/nvkm/core/client.c    |  6 +--
 drivers/gpu/drm/nouveau/nvkm/core/firmware.c  |  2 +-
 .../gpu/drm/nouveau/nvkm/engine/gr/gf100.c    |  2 +-
 .../gpu/drm/nouveau/nvkm/engine/gr/gk20a.c    |  4 +-
 .../gpu/drm/nouveau/nvkm/engine/gr/gm20b.c    |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/bios/bit.c    |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/bios/i2c.c    |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/bios/pll.c    |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/clk/base.c    |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c |  4 +-
 .../gpu/drm/nouveau/nvkm/subdev/gpio/base.c   |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c    |  4 +-
 drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/mxm/base.c    |  2 +-
 .../gpu/drm/nouveau/nvkm/subdev/top/base.c    |  2 +-
 drivers/gpu/drm/omapdrm/omap_drv.c            |  2 +-
 drivers/gpu/drm/panfrost/panfrost_drv.c       |  8 +--
 drivers/gpu/drm/panfrost/panfrost_mmu.c       |  2 +-
 drivers/gpu/drm/qxl/qxl_dumb.c                |  2 +-
 drivers/gpu/drm/qxl/qxl_ioctl.c               |  2 +-
 drivers/gpu/drm/radeon/ci_dpm.c               | 14 ++---
 drivers/gpu/drm/radeon/r100.c                 |  2 +-
 drivers/gpu/drm/radeon/r600_cs.c              |  2 +-
 drivers/gpu/drm/radeon/radeon_cs.c            |  2 +-
 drivers/gpu/drm/radeon/radeon_cursor.c        |  2 +-
 drivers/gpu/drm/radeon/radeon_fence.c         |  4 +-
 drivers/gpu/drm/radeon/radeon_gem.c           | 18 +++----
 drivers/gpu/drm/radeon/radeon_uvd.c           |  2 +-
 drivers/gpu/drm/radeon/si_dpm.c               | 14 ++---
 drivers/gpu/drm/scheduler/sched_main.c        |  2 +-
 drivers/gpu/drm/stm/drv.c                     |  2 +-
 drivers/gpu/drm/tegra/drm.c                   | 12 ++---
 drivers/gpu/drm/v3d/v3d_bo.c                  |  4 +-
 drivers/gpu/drm/vc4/vc4_bo.c                  |  6 +--
 drivers/gpu/drm/vc4/vc4_gem.c                 |  4 +-
 drivers/gpu/drm/vgem/vgem_drv.c               |  2 +-
 drivers/gpu/drm/vgem/vgem_fence.c             |  4 +-
 drivers/gpu/drm/virtio/virtgpu_gem.c          |  2 +-
 drivers/gpu/drm/virtio/virtgpu_ioctl.c        |  8 +--
 drivers/hid/hid-logitech-hidpp.c              |  4 +-
 drivers/hid/hid-prodikeys.c                   |  2 +-
 drivers/hid/intel-ish-hid/ishtp-hid-client.c  |  2 +-
 drivers/hid/intel-ish-hid/ishtp/bus.c         |  2 +-
 drivers/hid/intel-ish-hid/ishtp/client.c      |  4 +-
 drivers/hsi/hsi_core.c                        |  2 +-
 drivers/hwmon/ibmaem.c                        |  4 +-
 drivers/hwmon/ibmpex.c                        | 10 ++--
 drivers/hwmon/ibmpowernv.c                    |  2 +-
 drivers/hwmon/pc87427.c                       |  2 +-
 drivers/hwmon/pmbus/ucd9000.c                 |  4 +-
 .../hwtracing/coresight/coresight-platform.c  |  6 +--
 drivers/hwtracing/coresight/coresight-stm.c   |  6 +--
 drivers/hwtracing/coresight/coresight.c       |  2 +-
 drivers/hwtracing/intel_th/gth.c              |  2 +-
 drivers/i2c/busses/i2c-exynos5.c              |  2 +-
 drivers/i2c/busses/i2c-qcom-cci.c             |  2 +-
 drivers/i2c/busses/i2c-s3c2410.c              |  2 +-
 drivers/i3c/master.c                          |  2 +-
 drivers/ide/ide-legacy.c                      |  2 +-
 drivers/iio/adc/stm32-adc-core.c              |  4 +-
 drivers/infiniband/core/counters.c            |  6 +--
 drivers/infiniband/core/device.c              |  4 +-
 drivers/infiniband/core/ucma.c                |  2 +-
 drivers/infiniband/hw/hfi1/eprom.c            |  2 +-
 drivers/infiniband/hw/hfi1/fault.c            |  2 +-
 drivers/infiniband/hw/hfi1/file_ops.c         |  2 +-
 drivers/infiniband/hw/mlx4/cm.c               |  4 +-
 drivers/infiniband/hw/mlx4/mad.c              |  8 +--
 drivers/infiniband/hw/mlx4/qp.c               |  4 +-
 drivers/infiniband/sw/siw/siw_qp.c            |  2 +-
 drivers/infiniband/sw/siw/siw_qp_rx.c         |  2 +-
 drivers/infiniband/ulp/rtrs/rtrs-srv.c        |  2 +-
 drivers/infiniband/ulp/srp/ib_srp.c           |  8 +--
 drivers/input/evdev.c                         |  2 +-
 drivers/input/keyboard/tegra-kbc.c            |  6 +--
 drivers/input/misc/uinput.c                   |  2 +-
 drivers/input/mouse/psmouse-base.c            |  2 +-
 drivers/input/touchscreen/lpc32xx_ts.c        |  2 +-
 drivers/input/touchscreen/raspberrypi-ts.c    |  2 +-
 drivers/input/touchscreen/s3c2410_ts.c        |  2 +-
 drivers/input/touchscreen/sis_i2c.c           |  2 +-
 drivers/iommu/arm-smmu-v3.c                   |  4 +-
 drivers/iommu/fsl_pamu.c                      | 16 +++---
 drivers/iommu/intel/dmar.c                    |  6 +--
 drivers/iommu/virtio-iommu.c                  |  2 +-
 drivers/irqchip/irq-imgpdc.c                  |  4 +-
 drivers/irqchip/irq-ls-extirq.c               |  2 +-
 drivers/mailbox/pcc.c                         |  2 +-
 drivers/mailbox/tegra-hsp.c                   |  2 +-
 drivers/md/bcache/super.c                     |  4 +-
 drivers/md/dm-cache-policy-smq.c              |  2 +-
 drivers/md/dm-log-userspace-transfer.c        |  2 +-
 drivers/md/dm-stats.c                         |  8 +--
 drivers/md/md-bitmap.c                        |  4 +-
 drivers/md/md.c                               |  4 +-
 drivers/media/cec/platform/tegra/tegra_cec.c  |  2 +-
 drivers/media/common/siano/smscoreapi.c       |  2 +-
 .../media/common/videobuf2/videobuf2-v4l2.c   |  2 +-
 drivers/media/i2c/adv7604.c                   |  6 +--
 drivers/media/pci/cx25821/cx25821-alsa.c      |  2 +-
 drivers/media/platform/coda/coda-bit.c        |  2 +-
 drivers/media/platform/davinci/vpss.c         |  2 +-
 drivers/media/platform/exynos4-is/media-dev.c |  2 +-
 drivers/media/platform/s5p-mfc/s5p_mfc.c      |  2 +-
 .../media/test-drivers/vicodec/vicodec-core.c |  8 +--
 drivers/media/tuners/tuner-xc2028.c           |  2 +-
 drivers/media/tuners/xc4000.c                 |  2 +-
 drivers/media/usb/go7007/snd-go7007.c         |  2 +-
 drivers/media/usb/pwc/pwc-ctrl.c              |  4 +-
 drivers/media/usb/siano/smsusb.c              |  2 +-
 drivers/media/usb/tm6000/tm6000-alsa.c        |  2 +-
 drivers/media/usb/ttusb-dec/ttusb_dec.c       |  8 +--
 drivers/media/usb/uvc/uvc_ctrl.c              |  6 +--
 drivers/media/v4l2-core/v4l2-event.c          |  2 +-
 drivers/media/v4l2-core/v4l2-fwnode.c         |  2 +-
 drivers/memory/brcmstb_dpfe.c                 |  6 +--
 drivers/memory/fsl_ifc.c                      |  2 +-
 drivers/memory/omap-gpmc.c                    |  4 +-
 drivers/memory/tegra/tegra124-emc.c           | 10 ++--
 drivers/memory/tegra/tegra30-emc.c            |  4 +-
 drivers/mfd/altera-sysmgr.c                   |  2 +-
 drivers/mfd/pcf50633-core.c                   |  2 +-
 drivers/mfd/rn5t618.c                         |  2 +-
 drivers/mfd/sun6i-prcm.c                      |  2 +-
 drivers/mfd/syscon.c                          |  2 +-
 drivers/misc/cxl/api.c                        |  2 +-
 drivers/misc/cxl/flash.c                      |  2 +-
 drivers/misc/cxl/guest.c                      |  6 +--
 drivers/misc/fastrpc.c                        |  4 +-
 drivers/misc/genwqe/card_dev.c                |  2 +-
 drivers/misc/mei/client.c                     |  2 +-
 drivers/misc/mei/hbm.c                        |  2 +-
 drivers/misc/mic/scif/scif_fd.c               |  2 +-
 drivers/misc/mic/vop/vop_main.c               |  2 +-
 drivers/misc/ocxl/file.c                      |  4 +-
 drivers/mmc/core/sd.c                         |  2 +-
 drivers/mmc/host/sdhci-s3c.c                  |  2 +-
 drivers/mtd/ftl.c                             |  2 +-
 drivers/mtd/maps/lantiq-flash.c               |  2 +-
 drivers/mtd/nand/raw/lpc32xx_mlc.c            |  4 +-
 drivers/mtd/nand/raw/lpc32xx_slc.c            |  4 +-
 drivers/mtd/nand/raw/ndfc.c                   |  2 +-
 drivers/mtd/parsers/parser_trx.c              |  2 +-
 drivers/mtd/rfd_ftl.c                         |  4 +-
 drivers/mtd/ubi/gluebi.c                      |  4 +-
 drivers/net/appletalk/ipddp.c                 |  4 +-
 drivers/net/bonding/bond_sysfs.c              |  2 +-
 drivers/net/can/xilinx_can.c                  |  4 +-
 drivers/net/dsa/b53/b53_common.c              |  2 +-
 drivers/net/dsa/b53/b53_priv.h                |  2 +-
 drivers/net/dsa/lantiq_gswip.c                |  8 +--
 .../net/dsa/sja1105/sja1105_dynamic_config.c  |  2 +-
 .../ethernet/aquantia/atlantic/aq_filters.c   |  2 +-
 .../ethernet/aquantia/atlantic/aq_macsec.c    | 10 ++--
 drivers/net/ethernet/atheros/ag71xx.c         |  2 +-
 drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c  |  4 +-
 drivers/net/ethernet/broadcom/tg3.c           |  2 +-
 .../ethernet/chelsio/cxgb4/cxgb4_ethtool.c    |  2 +-
 .../ethernet/chelsio/cxgb4/cxgb4_tc_flower.c  |  2 +-
 .../chelsio/cxgb4/cxgb4_tc_matchall.c         |  6 +--
 drivers/net/ethernet/chelsio/cxgb4/t4_hw.c    |  2 +-
 drivers/net/ethernet/davicom/dm9000.c         |  4 +-
 drivers/net/ethernet/freescale/fec_main.c     |  2 +-
 .../hisilicon/hns3/hns3pf/hclge_main.c        | 10 ++--
 .../hisilicon/hns3/hns3vf/hclgevf_main.c      |  2 +-
 drivers/net/ethernet/intel/i40e/i40e_client.c |  2 +-
 .../net/ethernet/intel/i40e/i40e_ethtool.c    |  2 +-
 drivers/net/ethernet/intel/i40e/i40e_main.c   | 18 +++----
 drivers/net/ethernet/intel/i40e/i40e_txrx.c   |  2 +-
 drivers/net/ethernet/intel/ice/ice_lib.c      |  4 +-
 drivers/net/ethernet/intel/ice/ice_txrx.c     |  4 +-
 .../net/ethernet/intel/ice/ice_virtchnl_pf.c  |  2 +-
 drivers/net/ethernet/intel/igb/igb_main.c     |  2 +-
 .../net/ethernet/intel/ixgbe/ixgbe_ipsec.c    |  4 +-
 drivers/net/ethernet/lantiq_xrx200.c          |  6 +--
 .../net/ethernet/marvell/mvpp2/mvpp2_cls.c    |  2 +-
 .../net/ethernet/marvell/mvpp2/mvpp2_prs.c    | 10 ++--
 drivers/net/ethernet/mellanox/mlx4/main.c     |  4 +-
 drivers/net/ethernet/mellanox/mlx4/port.c     |  4 +-
 .../ethernet/mellanox/mlx4/resource_tracker.c |  4 +-
 .../ethernet/mellanox/mlx5/core/en/rep/tc.c   |  4 +-
 .../ethernet/mellanox/mlx5/core/en/tc_ct.c    |  4 +-
 .../ethernet/mellanox/mlx5/core/en_dcbnl.c    |  4 +-
 .../mellanox/mlx5/core/en_fs_ethtool.c        |  2 +-
 .../net/ethernet/mellanox/mlx5/core/en_tc.c   |  2 +-
 .../ethernet/mellanox/mlx5/core/esw/chains.c  |  2 +-
 .../ethernet/mellanox/mlx5/core/fpga/ipsec.c  |  2 +-
 .../ethernet/mellanox/mlx5/core/pagealloc.c   |  2 +-
 .../mellanox/mlx5/core/steering/dr_domain.c   |  2 +-
 .../mellanox/mlx5/core/steering/dr_ste.c      |  2 +-
 .../ethernet/mellanox/mlxsw/spectrum_flow.c   |  2 +-
 .../mellanox/mlxsw/spectrum_matchall.c        |  2 +-
 drivers/net/ethernet/micrel/ks8851_common.c   |  4 +-
 drivers/net/ethernet/mscc/ocelot.c            |  2 +-
 drivers/net/ethernet/mscc/ocelot_tc.c         |  4 +-
 drivers/net/ethernet/natsemi/sonic.c          |  2 +-
 drivers/net/ethernet/netronome/nfp/bpf/jit.c  |  2 +-
 .../ethernet/netronome/nfp/flower/lag_conf.c  |  2 +-
 .../ethernet/netronome/nfp/flower/metadata.c  | 10 ++--
 .../ethernet/netronome/nfp/flower/offload.c   |  8 +--
 .../netronome/nfp/flower/tunnel_conf.c        |  2 +-
 drivers/net/ethernet/netronome/nfp/nfp_main.c |  2 +-
 .../netronome/nfp/nfpcore/nfp_resource.c      |  2 +-
 .../netronome/nfp/nfpcore/nfp_rtsym.c         |  2 +-
 drivers/net/ethernet/pasemi/pasemi_mac.c      |  4 +-
 .../net/ethernet/pensando/ionic/ionic_lif.c   |  4 +-
 .../net/ethernet/pensando/ionic/ionic_main.c  |  2 +-
 drivers/net/ethernet/qlogic/qed/qed_main.c    |  2 +-
 drivers/net/ethernet/qlogic/qed/qed_mcp.c     |  2 +-
 drivers/net/ethernet/renesas/sh_eth.c         |  2 +-
 drivers/net/ethernet/rocker/rocker_main.c     |  4 +-
 drivers/net/ethernet/sfc/falcon/farch.c       | 10 ++--
 drivers/net/ethernet/sfc/farch.c              |  6 +--
 drivers/net/ethernet/sfc/mcdi_filters.c       |  6 +--
 drivers/net/ethernet/sfc/siena_sriov.c        |  2 +-
 .../net/ethernet/stmicro/stmmac/stmmac_tc.c   |  4 +-
 drivers/net/ethernet/ti/am65-cpsw-nuss.c      |  8 +--
 drivers/net/ethernet/ti/cpsw-common.c         |  2 +-
 drivers/net/ethernet/ti/cpsw_ale.c            | 14 ++---
 drivers/net/ethernet/ti/cpsw_new.c            |  4 +-
 drivers/net/ethernet/ti/davinci_cpdma.c       |  4 +-
 drivers/net/ethernet/ti/netcp_core.c          |  4 +-
 drivers/net/geneve.c                          |  2 +-
 drivers/net/gtp.c                             |  2 +-
 drivers/net/hamradio/bpqether.c               |  2 +-
 drivers/net/ieee802154/at86rf230.c            |  2 +-
 drivers/net/ieee802154/cc2520.c               |  2 +-
 drivers/net/ieee802154/mac802154_hwsim.c      | 12 ++---
 drivers/net/netdevsim/bpf.c                   |  4 +-
 drivers/net/netdevsim/dev.c                   |  4 +-
 drivers/net/phy/fixed_phy.c                   |  2 +-
 drivers/net/team/team.c                       |  2 +-
 drivers/net/team/team_mode_activebackup.c     |  2 +-
 drivers/net/usb/hso.c                         |  4 +-
 drivers/net/vxlan.c                           |  8 +--
 drivers/net/wan/hdlc_fr.c                     |  4 +-
 drivers/net/wireless/ath/ar5523/ar5523.c      |  2 +-
 drivers/net/wireless/ath/ath10k/core.c        |  8 +--
 drivers/net/wireless/ath/ath10k/htc.c         |  2 +-
 drivers/net/wireless/ath/ath10k/htt_rx.c      | 16 +++---
 drivers/net/wireless/ath/ath10k/mac.c         | 22 ++++----
 drivers/net/wireless/ath/ath10k/pci.c         |  2 +-
 drivers/net/wireless/ath/ath10k/snoc.c        |  2 +-
 drivers/net/wireless/ath/ath10k/txrx.c        |  2 +-
 drivers/net/wireless/ath/ath11k/ahb.c         |  2 +-
 drivers/net/wireless/ath/ath11k/core.c        |  2 +-
 drivers/net/wireless/ath/ath11k/debugfs_sta.c |  4 +-
 drivers/net/wireless/ath/ath11k/dp.c          |  2 +-
 drivers/net/wireless/ath/ath11k/dp_rx.c       |  8 +--
 drivers/net/wireless/ath/ath11k/htc.c         |  2 +-
 drivers/net/wireless/ath/ath11k/mac.c         |  6 +--
 drivers/net/wireless/ath/ath11k/peer.c        |  2 +-
 drivers/net/wireless/ath/ath11k/wmi.c         |  2 +-
 drivers/net/wireless/ath/ath5k/mac80211-ops.c |  2 +-
 drivers/net/wireless/ath/ath6kl/cfg80211.c    | 16 +++---
 drivers/net/wireless/ath/ath6kl/init.c        |  2 +-
 drivers/net/wireless/ath/ath9k/hif_usb.c      |  2 +-
 drivers/net/wireless/ath/ath9k/main.c         |  2 +-
 drivers/net/wireless/ath/ath9k/xmit.c         |  2 +-
 drivers/net/wireless/ath/carl9170/main.c      |  2 +-
 drivers/net/wireless/ath/wcn36xx/main.c       |  4 +-
 drivers/net/wireless/ath/wcn36xx/smd.c        |  4 +-
 drivers/net/wireless/ath/wil6210/cfg80211.c   | 12 ++---
 drivers/net/wireless/ath/wil6210/p2p.c        |  4 +-
 drivers/net/wireless/ath/wil6210/txrx.c       |  4 +-
 drivers/net/wireless/ath/wil6210/wmi.c        |  2 +-
 drivers/net/wireless/atmel/at76c50x-usb.c     |  2 +-
 drivers/net/wireless/atmel/atmel.c            |  2 +-
 drivers/net/wireless/broadcom/b43/main.c      |  2 +-
 .../net/wireless/broadcom/b43/phy_common.c    |  2 +-
 .../net/wireless/broadcom/b43legacy/main.c    |  2 +-
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    |  2 +-
 .../broadcom/brcm80211/brcmfmac/firmware.c    |  2 +-
 .../broadcom/brcm80211/brcmfmac/fwsignal.c    |  8 +--
 .../broadcom/brcm80211/brcmsmac/mac80211_if.c |  2 +-
 .../net/wireless/intel/iwlegacy/4965-mac.c    |  2 +-
 drivers/net/wireless/intel/iwlwifi/dvm/sta.c  |  2 +-
 drivers/net/wireless/intel/iwlwifi/fw/acpi.c  |  8 +--
 drivers/net/wireless/intel/iwlwifi/fw/acpi.h  | 22 ++++----
 drivers/net/wireless/intel/iwlwifi/iwl-drv.c  |  2 +-
 .../wireless/intel/iwlwifi/iwl-eeprom-read.c  |  6 +--
 .../net/wireless/intel/iwlwifi/mvm/debugfs.c  |  2 +-
 .../intel/iwlwifi/mvm/ftm-initiator.c         |  2 +-
 drivers/net/wireless/intel/iwlwifi/mvm/fw.c   |  6 +--
 .../net/wireless/intel/iwlwifi/mvm/mac80211.c |  6 +--
 drivers/net/wireless/intel/iwlwifi/mvm/scan.c |  2 +-
 drivers/net/wireless/intel/iwlwifi/mvm/sta.c  |  2 +-
 .../net/wireless/intel/iwlwifi/pcie/trans.c   |  2 +-
 .../net/wireless/intersil/hostap/hostap_ap.c  |  8 +--
 drivers/net/wireless/intersil/orinoco/fw.c    |  4 +-
 drivers/net/wireless/intersil/p54/main.c      |  2 +-
 drivers/net/wireless/mac80211_hwsim.c         |  4 +-
 .../net/wireless/marvell/libertas/firmware.c  |  2 +-
 .../net/wireless/marvell/libertas_tf/main.c   |  2 +-
 .../net/wireless/marvell/mwifiex/cfg80211.c   | 16 +++---
 drivers/net/wireless/marvell/mwl8k.c          |  4 +-
 drivers/net/wireless/mediatek/mt76/eeprom.c   |  8 +--
 .../wireless/mediatek/mt76/mt76x0/usb_mcu.c   |  2 +-
 .../wireless/mediatek/mt76/mt76x2/eeprom.c    |  2 +-
 .../wireless/mediatek/mt76/mt76x2/pci_mcu.c   |  2 +-
 drivers/net/wireless/mediatek/mt7601u/mcu.c   |  2 +-
 .../net/wireless/quantenna/qtnfmac/cfg80211.c |  8 +--
 .../net/wireless/quantenna/qtnfmac/commands.c |  2 +-
 .../net/wireless/ralink/rt2x00/rt2800lib.c    |  2 +-
 .../wireless/ralink/rt2x00/rt2x00firmware.c   |  4 +-
 drivers/net/wireless/realtek/rtw88/fw.c       |  2 +-
 drivers/net/wireless/realtek/rtw88/main.c     |  2 +-
 drivers/net/wireless/realtek/rtw88/wow.c      |  2 +-
 drivers/net/wireless/rndis_wlan.c             |  8 +--
 drivers/net/wireless/st/cw1200/sta.c          |  4 +-
 drivers/net/wireless/st/cw1200/txrx.c         |  2 +-
 drivers/net/wireless/st/cw1200/wsm.c          |  2 +-
 drivers/net/wireless/ti/wl1251/main.c         |  2 +-
 drivers/net/wireless/ti/wlcore/cmd.c          |  2 +-
 drivers/net/wireless/ti/wlcore/main.c         |  4 +-
 drivers/net/wireless/virt_wifi.c              |  4 +-
 drivers/net/wireless/zydas/zd1211rw/zd_usb.c  |  2 +-
 drivers/net/xen-netback/xenbus.c              |  2 +-
 drivers/net/xen-netfront.c                    |  4 +-
 drivers/nfc/nfcmrvl/fw_dnld.c                 |  2 +-
 drivers/nvme/host/tcp.c                       |  6 +--
 drivers/nvme/target/fc.c                      |  4 +-
 drivers/nvme/target/fcloop.c                  |  6 +--
 drivers/nvmem/snvs_lpgpr.c                    |  2 +-
 drivers/of/address.c                          |  2 +-
 drivers/of/base.c                             |  6 +--
 drivers/of/fdt.c                              |  6 +--
 drivers/opp/of.c                              |  2 +-
 drivers/pci/controller/dwc/pcie-al.c          |  2 +-
 drivers/pci/controller/pci-hyperv.c           |  2 +-
 drivers/pci/controller/pci-mvebu.c            |  2 +-
 drivers/pci/controller/pcie-tango.c           |  4 +-
 drivers/pci/pci.c                             |  2 +-
 drivers/pci/setup-bus.c                       |  2 +-
 drivers/pci/vpd.c                             |  4 +-
 drivers/perf/arm-cci.c                        | 22 ++++----
 drivers/perf/arm-ccn.c                        |  2 +-
 drivers/perf/arm_dsu_pmu.c                    |  4 +-
 drivers/perf/arm_pmu.c                        | 14 ++---
 drivers/perf/arm_smmuv3_pmu.c                 |  2 +-
 drivers/perf/arm_spe_pmu.c                    |  6 +--
 drivers/perf/fsl_imx8_ddr_perf.c              |  6 +--
 drivers/perf/hisilicon/hisi_uncore_pmu.c      |  2 +-
 drivers/perf/qcom_l2_pmu.c                    |  2 +-
 drivers/perf/qcom_l3_pmu.c                    |  2 +-
 drivers/perf/thunderx2_pmu.c                  |  2 +-
 drivers/perf/xgene_pmu.c                      |  2 +-
 drivers/phy/lantiq/phy-lantiq-rcu-usb2.c      |  4 +-
 drivers/phy/rockchip/phy-rockchip-pcie.c      |  2 +-
 drivers/phy/st/phy-miphy28lp.c                |  2 +-
 drivers/phy/ti/phy-dm816x-usb.c               |  2 +-
 drivers/pinctrl/bcm/pinctrl-ns.c              |  2 +-
 drivers/pinctrl/core.c                        |  2 +-
 drivers/pinctrl/devicetree.c                  |  6 +--
 drivers/pinctrl/freescale/pinctrl-imx1-core.c |  2 +-
 drivers/pinctrl/freescale/pinctrl-mxs.c       |  2 +-
 drivers/pinctrl/mvebu/pinctrl-armada-37xx.c   |  2 +-
 drivers/pinctrl/pinctrl-rockchip.c            |  4 +-
 drivers/pinctrl/pinctrl-rza1.c                |  4 +-
 drivers/pinctrl/pinctrl-rza2.c                |  2 +-
 drivers/pinctrl/pinmux.c                      |  2 +-
 drivers/platform/chrome/chromeos_laptop.c     |  2 +-
 drivers/platform/x86/wmi.c                    |  2 +-
 drivers/power/supply/gpio-charger.c           |  2 +-
 drivers/ras/debugfs.c                         |  2 +-
 drivers/regulator/fixed.c                     |  2 +-
 drivers/remoteproc/imx_rproc.c                |  2 +-
 drivers/reset/reset-lantiq.c                  |  4 +-
 drivers/rtc/rtc-bd70528.c                     |  2 +-
 drivers/rtc/rtc-omap.c                        |  4 +-
 drivers/rtc/rtc-puv3.c                        |  6 +--
 drivers/rtc/rtc-sh.c                          |  4 +-
 drivers/s390/block/dasd_proc.c                |  2 +-
 drivers/s390/cio/blacklist.c                  |  2 +-
 drivers/s390/crypto/ap_queue.c                |  2 +-
 drivers/s390/net/qeth_l2_main.c               |  2 +-
 drivers/s390/net/qeth_l3_main.c               |  6 +--
 drivers/scsi/aic94xx/aic94xx_sds.c            | 20 +++----
 drivers/scsi/bnx2fc/bnx2fc_fcoe.c             |  2 +-
 drivers/scsi/csiostor/csio_hw.c               |  2 +-
 drivers/scsi/hisi_sas/hisi_sas_main.c         | 14 ++---
 drivers/scsi/hisi_sas/hisi_sas_v1_hw.c        | 12 ++---
 drivers/scsi/hisi_sas/hisi_sas_v3_hw.c        |  2 +-
 drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c      |  2 +-
 drivers/scsi/scsi_transport_fc.c              |  6 +--
 drivers/sh/clk/core.c                         |  2 +-
 drivers/soc/fsl/qe/ucc.c                      |  2 +-
 drivers/soc/mediatek/mtk-cmdq-helper.c        |  2 +-
 drivers/soc/renesas/rcar-sysc.c               |  2 +-
 drivers/soc/tegra/pmc.c                       |  6 +--
 drivers/soc/xilinx/zynqmp_power.c             |  2 +-
 drivers/spi/spi-coldfire-qspi.c               |  2 +-
 drivers/ssb/sprom.c                           |  2 +-
 drivers/staging/board/board.c                 |  4 +-
 drivers/staging/fieldbus/anybuss/host.c       |  2 +-
 drivers/staging/fsl-dpaa2/ethsw/ethsw.c       |  6 +--
 drivers/staging/fwserial/dma_fifo.c           |  6 +--
 drivers/staging/fwserial/fwserial.c           |  2 +-
 drivers/staging/greybus/power_supply.c        |  2 +-
 .../staging/media/atomisp/pci/atomisp_acc.c   |  2 +-
 drivers/staging/media/rkvdec/rkvdec.c         |  4 +-
 drivers/staging/media/sunxi/cedrus/cedrus.c   |  8 +--
 drivers/staging/most/i2c/i2c.c                |  2 +-
 drivers/staging/most/video/video.c            |  2 +-
 drivers/staging/rtl8188eu/hal/fw.c            |  2 +-
 .../interface/vchiq_arm/vchiq_arm.c           |  2 +-
 drivers/staging/wfx/sta.c                     |  2 +-
 drivers/staging/wilc1000/cfg80211.c           |  6 +--
 drivers/staging/wlan-ng/cfg80211.c            |  2 +-
 drivers/thermal/broadcom/ns-thermal.c         |  2 +-
 drivers/thunderbolt/cap.c                     |  8 +--
 drivers/tty/serial/earlycon.c                 |  2 +-
 drivers/tty/serial/lantiq.c                   |  2 +-
 drivers/usb/atm/cxacru.c                      |  2 +-
 drivers/usb/atm/speedtch.c                    |  2 +-
 drivers/usb/core/devio.c                      |  4 +-
 drivers/usb/core/hcd.c                        |  2 +-
 drivers/usb/core/hub.c                        |  2 +-
 drivers/usb/core/urb.c                        |  2 +-
 drivers/usb/dwc2/gadget.c                     | 10 ++--
 drivers/usb/gadget/function/f_fs.c            |  2 +-
 drivers/usb/gadget/udc/s3c-hsudc.c            |  2 +-
 drivers/usb/host/bcma-hcd.c                   |  2 +-
 drivers/usb/host/ehci-sysfs.c                 |  2 +-
 drivers/usb/host/ehci-tegra.c                 |  2 +-
 drivers/usb/host/xhci-ring.c                  |  2 +-
 drivers/usb/serial/keyspan.c                  |  2 +-
 drivers/usb/serial/keyspan_pda.c              |  2 +-
 drivers/usb/serial/ti_usb_3410_5052.c         |  4 +-
 drivers/usb/serial/whiteheat.c                |  2 +-
 drivers/usb/typec/ucsi/ucsi.c                 |  2 +-
 drivers/vfio/pci/vfio_pci.c                   |  2 +-
 drivers/vfio/platform/vfio_platform_common.c  |  4 +-
 drivers/vfio/vfio_iommu_spapr_tce.c           |  2 +-
 drivers/video/fbdev/amba-clcd.c               |  2 +-
 drivers/video/fbdev/atmel_lcdfb.c             |  2 +-
 drivers/video/fbdev/core/fbcon.c              |  2 +-
 drivers/video/fbdev/da8xx-fb.c                |  2 +-
 drivers/video/fbdev/fb-puv3.c                 |  2 +-
 drivers/video/fbdev/matrox/matroxfb_g450.c    |  2 +-
 drivers/video/fbdev/matrox/matroxfb_maven.c   |  2 +-
 drivers/video/fbdev/omap/lcd_mipid.c          |  2 +-
 drivers/video/fbdev/omap2/omapfb/dss/core.c   |  2 +-
 .../fbdev/omap2/omapfb/dss/display-sysfs.c    | 22 ++++----
 .../fbdev/omap2/omapfb/dss/manager-sysfs.c    |  4 +-
 .../fbdev/omap2/omapfb/dss/overlay-sysfs.c    |  4 +-
 .../video/fbdev/omap2/omapfb/omapfb-ioctl.c   |  4 +-
 .../video/fbdev/omap2/omapfb/omapfb-main.c    |  2 +-
 drivers/video/fbdev/pxa168fb.c                |  4 +-
 drivers/video/fbdev/s3c2410fb.c               |  2 +-
 drivers/video/fbdev/sh_mobile_lcdcfb.c        |  2 +-
 drivers/video/of_display_timing.c             |  2 +-
 drivers/visorbus/visorbus_main.c              |  2 +-
 drivers/watchdog/pika_wdt.c                   |  2 +-
 drivers/watchdog/rza_wdt.c                    |  2 +-
 drivers/xen/events/events_base.c              |  6 +--
 drivers/xen/xenbus/xenbus_client.c            |  2 +-
 drivers/xen/xenbus/xenbus_dev_frontend.c      |  2 +-
 drivers/xen/xenbus/xenbus_probe.c             |  2 +-
 fs/adfs/dir_f.c                               |  8 +--
 fs/adfs/dir_fplus.c                           |  6 +--
 fs/afs/dir.c                                  |  4 +-
 fs/afs/flock.c                                |  2 +-
 fs/afs/misc.c                                 | 10 ++--
 fs/afs/mntpt.c                                |  2 +-
 fs/autofs/root.c                              |  2 +-
 fs/autofs/waitq.c                             | 14 ++---
 fs/bfs/dir.c                                  |  2 +-
 fs/binfmt_elf.c                               |  2 +-
 fs/binfmt_em86.c                              |  2 +-
 fs/binfmt_script.c                            |  2 +-
 fs/btrfs/backref.c                            |  6 +--
 fs/btrfs/delayed-inode.c                      | 10 ++--
 fs/btrfs/export.c                             |  2 +-
 fs/btrfs/extent-tree.c                        |  4 +-
 fs/btrfs/inode.c                              |  2 +-
 fs/btrfs/ioctl.c                              |  8 +--
 fs/btrfs/qgroup.c                             |  8 +--
 fs/btrfs/relocation.c                         |  6 +--
 fs/btrfs/scrub.c                              |  4 +-
 fs/btrfs/send.c                               |  4 +-
 fs/btrfs/tests/free-space-tests.c             | 20 +++----
 fs/btrfs/transaction.c                        |  2 +-
 fs/btrfs/tree-log.c                           |  8 +--
 fs/btrfs/volumes.c                            |  8 +--
 fs/ceph/file.c                                |  2 +-
 fs/ceph/mds_client.c                          |  2 +-
 fs/cifs/cifssmb.c                             |  2 +-
 fs/cifs/dir.c                                 |  2 +-
 fs/cifs/file.c                                |  4 +-
 fs/cifs/inode.c                               |  2 +-
 fs/cifs/readdir.c                             |  4 +-
 fs/cifs/smb2misc.c                            |  2 +-
 fs/cifs/smb2ops.c                             |  2 +-
 fs/cifs/smb2transport.c                       |  2 +-
 fs/cifs/smbencrypt.c                          |  2 +-
 fs/cifs/transport.c                           | 10 ++--
 fs/configfs/symlink.c                         |  6 +--
 fs/crypto/fname.c                             |  2 +-
 fs/dlm/lowcomms.c                             |  2 +-
 fs/dlm/user.c                                 | 16 +++---
 fs/erofs/namei.c                              |  2 +-
 fs/exfat/dir.c                                |  2 +-
 fs/exfat/namei.c                              |  6 +--
 fs/ext4/namei.c                               |  2 +-
 fs/f2fs/file.c                                |  2 +-
 fs/f2fs/node.c                                |  2 +-
 fs/fat/dir.c                                  |  8 +--
 fs/fat/namei_msdos.c                          |  2 +-
 fs/fat/namei_vfat.c                           |  6 +--
 fs/file.c                                     |  2 +-
 fs/fs-writeback.c                             |  2 +-
 fs/fuse/dir.c                                 |  2 +-
 fs/fuse/inode.c                               |  2 +-
 fs/gfs2/dir.c                                 |  2 +-
 fs/gfs2/glock.c                               |  2 +-
 fs/gfs2/inode.c                               |  4 +-
 fs/gfs2/ops_fstype.c                          |  2 +-
 fs/hfs/bfind.c                                |  2 +-
 fs/hfs/brec.c                                 |  2 +-
 fs/hfs/extent.c                               |  2 +-
 fs/hfsplus/attributes.c                       |  4 +-
 fs/hfsplus/bfind.c                            |  2 +-
 fs/hfsplus/bitmap.c                           |  2 +-
 fs/hfsplus/brec.c                             |  2 +-
 fs/hfsplus/extents.c                          |  2 +-
 fs/hfsplus/part_tbl.c                         |  6 +--
 fs/hpfs/dentry.c                              |  2 +-
 fs/hpfs/ea.c                                  |  2 +-
 fs/io_uring.c                                 |  2 +-
 fs/iomap/seek.c                               |  2 +-
 fs/jffs2/readinode.c                          |  2 +-
 fs/jfs/jfs_xtree.c                            |  2 +-
 fs/kernfs/dir.c                               |  4 +-
 fs/namei.c                                    | 20 +++----
 fs/nfs/delegation.c                           |  2 +-
 fs/nfs/dir.c                                  |  4 +-
 fs/nfs/flexfilelayout/flexfilelayout.c        |  2 +-
 fs/nfs/nfs4namespace.c                        |  4 +-
 fs/nfs/nfs4proc.c                             |  4 +-
 fs/nfs/nfs4state.c                            |  2 +-
 fs/nfs/pnfs.c                                 |  2 +-
 fs/nfsd/nfs4recover.c                         | 22 ++++----
 fs/nilfs2/btree.c                             |  8 +--
 fs/nilfs2/cpfile.c                            | 12 ++---
 fs/nilfs2/direct.c                            | 16 +++---
 fs/nilfs2/mdt.c                               |  4 +-
 fs/notify/fanotify/fanotify_user.c            |  4 +-
 fs/notify/inotify/inotify_user.c              |  2 +-
 fs/nsfs.c                                     |  2 +-
 fs/ntfs/attrib.c                              | 16 +++---
 fs/ntfs/mft.c                                 |  2 +-
 fs/ntfs/runlist.c                             |  6 +--
 fs/ocfs2/dir.c                                |  2 +-
 fs/ocfs2/dlm/dlmcommon.h                      |  2 +-
 fs/ocfs2/dlm/dlmmaster.c                      |  4 +-
 fs/ocfs2/extent_map.c                         |  2 +-
 fs/ocfs2/refcounttree.c                       |  4 +-
 fs/ocfs2/slot_map.c                           |  2 +-
 fs/ocfs2/stack_o2cb.c                         |  2 +-
 fs/overlayfs/util.c                           |  2 +-
 fs/proc/base.c                                | 12 ++---
 fs/proc/fd.c                                  |  4 +-
 fs/proc/generic.c                             |  6 +--
 fs/proc/inode.c                               |  4 +-
 fs/proc/namespaces.c                          |  2 +-
 fs/reiserfs/inode.c                           |  6 +--
 fs/reiserfs/namei.c                           |  2 +-
 fs/sysfs/dir.c                                |  2 +-
 fs/sysfs/file.c                               |  6 +--
 fs/sysfs/group.c                              | 14 ++---
 fs/sysfs/symlink.c                            |  2 +-
 fs/ubifs/debug.c                              |  2 +-
 fs/ubifs/tnc.c                                |  6 +--
 fs/vboxsf/utils.c                             |  2 +-
 fs/xfs/libxfs/xfs_btree.c                     |  2 +-
 fs/xfs/libxfs/xfs_dir2.c                      |  2 +-
 fs/xfs/libxfs/xfs_dir2_block.c                |  4 +-
 fs/xfs/libxfs/xfs_dir2_leaf.c                 |  2 +-
 fs/xfs/libxfs/xfs_dir2_node.c                 |  4 +-
 fs/xfs/libxfs/xfs_dir2_sf.c                   |  6 +--
 fs/xfs/scrub/attr.c                           |  2 +-
 fs/xfs/scrub/bmap.c                           |  2 +-
 fs/xfs/scrub/common.c                         |  6 +--
 fs/xfs/scrub/common.h                         |  4 +-
 fs/xfs/scrub/dir.c                            |  2 +-
 fs/xfs/scrub/parent.c                         |  2 +-
 fs/xfs/scrub/quota.c                          |  4 +-
 fs/xfs/scrub/scrub.h                          |  6 +--
 fs/xfs/scrub/symlink.c                        |  2 +-
 fs/xfs/xfs_buf.c                              |  2 +-
 fs/xfs/xfs_dquot.c                            |  4 +-
 fs/xfs/xfs_icache.c                           |  2 +-
 include/acpi/ghes.h                           |  2 +-
 include/linux/errno.h                         |  1 +
 include/linux/fs.h                            |  2 +-
 include/linux/pci.h                           |  2 +-
 include/linux/reset.h                         |  2 +-
 include/linux/rhashtable.h                    |  4 +-
 include/linux/skmsg.h                         |  2 +-
 include/linux/sunrpc/cache.h                  |  6 +--
 include/linux/thermal.h                       |  2 +-
 include/net/cfg80211.h                        |  2 +-
 include/net/netlabel.h                        |  4 +-
 include/net/vxlan.h                           |  2 +-
 ipc/mqueue.c                                  |  2 +-
 kernel/audit_tree.c                           |  2 +-
 kernel/bpf/arraymap.c                         |  8 +--
 kernel/bpf/bpf_iter.c                         |  2 +-
 kernel/bpf/bpf_struct_ops.c                   |  8 +--
 kernel/bpf/btf.c                              |  6 +--
 kernel/bpf/cgroup.c                           |  2 +-
 kernel/bpf/core.c                             |  2 +-
 kernel/bpf/cpumap.c                           |  2 +-
 kernel/bpf/devmap.c                           |  4 +-
 kernel/bpf/hashtab.c                          |  6 +--
 kernel/bpf/inode.c                            |  2 +-
 kernel/bpf/local_storage.c                    |  8 +--
 kernel/bpf/lpm_trie.c                         |  2 +-
 kernel/bpf/net_namespace.c                    |  2 +-
 kernel/bpf/reuseport_array.c                  |  6 +--
 kernel/bpf/stackmap.c                         |  8 +--
 kernel/bpf/syscall.c                          |  4 +-
 kernel/bpf/verifier.c                         |  4 +-
 kernel/cgroup/cgroup-v1.c                     |  4 +-
 kernel/cgroup/cgroup.c                        | 12 ++---
 kernel/debug/debug_core.c                     |  2 +-
 kernel/events/core.c                          | 22 ++++----
 kernel/events/hw_breakpoint.c                 |  2 +-
 kernel/gcov/fs.c                              |  2 +-
 kernel/irq/irqdomain.c                        |  2 +-
 kernel/kcsan/debugfs.c                        |  2 +-
 kernel/kmod.c                                 |  2 +-
 kernel/ksysfs.c                               |  2 +-
 kernel/livepatch/core.c                       |  4 +-
 kernel/module.c                               |  2 +-
 kernel/notifier.c                             |  2 +-
 kernel/params.c                               |  2 +-
 kernel/printk/printk.c                        |  2 +-
 kernel/stop_machine.c                         |  6 +--
 kernel/sys.c                                  |  4 +-
 kernel/trace/blktrace.c                       |  2 +-
 kernel/trace/bpf_trace.c                      |  8 +--
 kernel/trace/ftrace.c                         |  2 +-
 kernel/trace/trace.c                          |  2 +-
 kernel/trace/trace_events.c                   |  4 +-
 kernel/trace/trace_events_hist.c              |  2 +-
 kernel/trace/trace_events_inject.c            |  2 +-
 kernel/trace/trace_events_synth.c             |  2 +-
 kernel/trace/trace_kprobe.c                   |  6 +--
 kernel/trace/trace_probe.c                    |  4 +-
 kernel/workqueue.c                            |  2 +-
 lib/bootconfig.c                              |  2 +-
 lib/btree.c                                   | 10 ++--
 lib/kobject.c                                 |  2 +-
 lib/kunit/test.c                              |  2 +-
 lib/objagg.c                                  |  2 +-
 lib/test_hmm.c                                |  4 +-
 lib/test_rhashtable.c                         |  2 +-
 mm/gup.c                                      |  2 +-
 mm/memory_hotplug.c                           |  2 +-
 mm/shmem.c                                    |  6 +--
 mm/z3fold.c                                   |  2 +-
 mm/zbud.c                                     |  2 +-
 mm/zswap.c                                    |  4 +-
 net/6lowpan/nhc.c                             |  2 +-
 net/atm/addr.c                                |  2 +-
 net/ax25/ax25_uid.c                           |  2 +-
 net/batman-adv/netlink.c                      |  2 +-
 net/batman-adv/soft-interface.c               |  2 +-
 net/batman-adv/sysfs.c                        |  4 +-
 net/bluetooth/6lowpan.c                       | 12 ++---
 net/bluetooth/hci_conn.c                      |  4 +-
 net/bluetooth/hci_core.c                      | 10 ++--
 net/bluetooth/hci_request.c                   |  2 +-
 net/bluetooth/hidp/core.c                     |  2 +-
 net/bluetooth/mgmt.c                          |  2 +-
 net/bridge/br_fdb.c                           |  4 +-
 net/bridge/br_if.c                            |  2 +-
 net/bridge/br_netlink.c                       |  2 +-
 net/bridge/br_sysfs_if.c                      |  2 +-
 net/bridge/br_vlan.c                          |  6 +--
 net/bridge/br_vlan_options.c                  |  8 +--
 net/bridge/br_vlan_tunnel.c                   |  2 +-
 net/bridge/netfilter/ebtables.c               |  2 +-
 net/can/j1939/transport.c                     |  4 +-
 net/ceph/auth.c                               |  2 +-
 net/ceph/messenger.c                          |  2 +-
 net/ceph/osdmap.c                             |  4 +-
 net/core/bpf_sk_storage.c                     |  6 +--
 net/core/dev.c                                |  2 +-
 net/core/dev_addr_lists.c                     |  8 +--
 net/core/devlink.c                            | 16 +++---
 net/core/filter.c                             | 16 +++---
 net/core/flow_offload.c                       |  2 +-
 net/core/neighbour.c                          | 10 ++--
 net/core/net-sysfs.c                          |  6 +--
 net/core/rtnetlink.c                          |  2 +-
 net/core/sock.c                               |  6 +--
 net/core/sock_map.c                           |  4 +-
 net/core/sock_reuseport.c                     |  2 +-
 net/dccp/ipv4.c                               |  2 +-
 net/dccp/ipv6.c                               |  2 +-
 net/dsa/slave.c                               |  2 +-
 net/ethtool/bitset.c                          |  4 +-
 net/hsr/hsr_framereg.c                        |  2 +-
 net/ipv4/cipso_ipv4.c                         |  4 +-
 net/ipv4/fib_frontend.c                       |  2 +-
 net/ipv4/fou.c                                |  4 +-
 net/ipv4/inet_hashtables.c                    |  2 +-
 net/ipv4/ip_gre.c                             |  2 +-
 net/ipv4/ipmr.c                               | 12 ++---
 net/ipv4/ipmr_base.c                          |  2 +-
 net/ipv4/netfilter/ipt_CLUSTERIP.c            |  2 +-
 net/ipv4/nexthop.c                            |  2 +-
 net/ipv4/tcp_ipv4.c                           |  4 +-
 net/ipv4/tcp_ulp.c                            |  2 +-
 net/ipv4/tunnel4.c                            |  6 +--
 net/ipv4/udp.c                                |  2 +-
 net/ipv4/udp_diag.c                           |  4 +-
 net/ipv4/xfrm4_protocol.c                     |  6 +--
 net/ipv4/xfrm4_tunnel.c                       |  2 +-
 net/ipv6/addrconf.c                           |  2 +-
 net/ipv6/anycast.c                            |  4 +-
 net/ipv6/calipso.c                            |  4 +-
 net/ipv6/exthdrs_core.c                       |  4 +-
 net/ipv6/fou6.c                               |  4 +-
 net/ipv6/ip6_fib.c                            |  8 +--
 net/ipv6/ip6_flowlabel.c                      |  2 +-
 net/ipv6/ip6_gre.c                            |  2 +-
 net/ipv6/ip6mr.c                              | 14 ++---
 net/ipv6/mcast.c                              |  2 +-
 net/ipv6/proc.c                               |  4 +-
 net/ipv6/route.c                              |  2 +-
 net/ipv6/seg6_hmac.c                          |  2 +-
 net/ipv6/sit.c                                |  4 +-
 net/ipv6/tcp_ipv6.c                           |  2 +-
 net/ipv6/tunnel6.c                            |  6 +--
 net/ipv6/udp.c                                |  2 +-
 net/ipv6/xfrm6_protocol.c                     |  6 +--
 net/kcm/kcmsock.c                             |  4 +-
 net/key/af_key.c                              |  6 +--
 net/mac80211/agg-tx.c                         |  2 +-
 net/mac80211/cfg.c                            | 26 +++++-----
 net/mac80211/mesh_hwmp.c                      |  6 +--
 net/mac80211/offchannel.c                     |  4 +-
 net/mac80211/rate.c                           |  2 +-
 net/mac80211/sta_info.c                       |  2 +-
 net/mac802154/llsec.c                         | 14 ++---
 net/ncsi/ncsi-aen.c                           |  2 +-
 net/ncsi/ncsi-cmd.c                           |  2 +-
 net/ncsi/ncsi-rsp.c                           |  4 +-
 net/netfilter/ipset/ip_set_core.c             | 18 +++----
 net/netfilter/ipvs/ip_vs_ctl.c                |  6 +--
 net/netfilter/ipvs/ip_vs_ftp.c                |  2 +-
 net/netfilter/ipvs/ip_vs_lblc.c               |  2 +-
 net/netfilter/ipvs/ip_vs_lblcr.c              |  2 +-
 net/netfilter/ipvs/ip_vs_pe.c                 |  2 +-
 net/netfilter/ipvs/ip_vs_sched.c              |  2 +-
 net/netfilter/nf_conntrack_helper.c           |  4 +-
 net/netfilter/nf_conntrack_netlink.c          | 18 +++----
 net/netfilter/nf_conntrack_proto.c            |  4 +-
 net/netfilter/nf_flow_table_offload.c         |  8 +--
 net/netfilter/nf_log.c                        |  4 +-
 net/netfilter/nf_nat_sip.c                    |  2 +-
 net/netfilter/nf_tables_api.c                 |  8 +--
 net/netfilter/nfnetlink_queue.c               |  4 +-
 net/netfilter/nft_ct.c                        |  4 +-
 net/netfilter/nft_exthdr.c                    |  2 +-
 net/netfilter/nft_flow_offload.c              |  2 +-
 net/netfilter/nft_meta.c                      |  2 +-
 net/netfilter/nft_objref.c                    |  2 +-
 net/netfilter/xt_CT.c                         |  4 +-
 net/netfilter/xt_SECMARK.c                    |  2 +-
 net/netfilter/xt_nfacct.c                     |  2 +-
 net/netfilter/xt_set.c                        | 14 ++---
 net/netlabel/netlabel_domainhash.c            |  6 +--
 net/netlabel/netlabel_kapi.c                  | 14 ++---
 net/netlabel/netlabel_unlabeled.c             |  4 +-
 net/netlink/diag.c                            |  2 +-
 net/netlink/genetlink.c                       | 12 ++---
 net/nfc/nci/uart.c                            |  4 +-
 net/openvswitch/conntrack.c                   |  2 +-
 net/phonet/pn_dev.c                           |  2 +-
 net/qrtr/ns.c                                 |  4 +-
 net/sched/act_api.c                           |  2 +-
 net/sched/act_ife.c                           |  6 +--
 net/sched/cls_api.c                           |  8 +--
 net/sched/cls_cgroup.c                        |  2 +-
 net/sched/cls_flower.c                        |  2 +-
 net/sched/cls_tcindex.c                       |  4 +-
 net/sched/cls_u32.c                           |  2 +-
 net/sched/em_ipset.c                          |  2 +-
 net/sched/sch_api.c                           | 20 +++----
 net/sched/sch_atm.c                           |  2 +-
 net/sched/sch_cbs.c                           |  2 +-
 net/sched/sch_hfsc.c                          |  2 +-
 net/sched/sch_netem.c                         |  2 +-
 net/sched/sch_teql.c                          |  2 +-
 net/sctp/input.c                              |  2 +-
 net/sctp/socket.c                             |  6 +--
 net/smc/smc_clc.c                             |  8 +--
 net/smc/smc_core.c                            |  4 +-
 net/smc/smc_pnet.h                            |  2 +-
 net/sunrpc/auth.c                             |  2 +-
 net/sunrpc/auth_gss/gss_mech_switch.c         |  4 +-
 net/sunrpc/cache.c                            |  2 +-
 net/sunrpc/clnt.c                             |  2 +-
 net/sunrpc/svcauth_unix.c                     |  2 +-
 net/unix/af_unix.c                            |  4 +-
 net/wireless/ap.c                             |  2 +-
 net/wireless/mlme.c                           |  4 +-
 net/wireless/nl80211.c                        |  8 +--
 net/wireless/radiotap.c                       |  4 +-
 net/wireless/scan.c                           |  2 +-
 net/wireless/sme.c                            |  2 +-
 net/wireless/util.c                           |  2 +-
 net/xdp/xskmap.c                              |  2 +-
 net/xfrm/xfrm_policy.c                        |  4 +-
 net/xfrm/xfrm_user.c                          |  4 +-
 samples/bpf/xdp_redirect_cpu_user.c           |  2 +-
 samples/vfio-mdev/mbochs.c                    |  2 +-
 security/apparmor/apparmorfs.c                |  4 +-
 security/apparmor/audit.c                     |  2 +-
 security/apparmor/mount.c                     |  2 +-
 security/integrity/evm/evm_crypto.c           |  2 +-
 security/integrity/ima/ima_modsig.c           |  4 +-
 security/integrity/ima/ima_template.c         |  2 +-
 security/keys/keyring.c                       |  2 +-
 security/selinux/include/security.h           |  2 +-
 security/selinux/netif.c                      |  2 +-
 security/selinux/ss/services.c                |  2 +-
 security/selinux/ss/sidtab.c                  |  2 +-
 security/selinux/ss/sidtab.h                  |  2 +-
 security/smack/smack_lsm.c                    |  2 +-
 security/smack/smackfs.c                      |  4 +-
 security/tomoyo/common.c                      |  2 +-
 sound/core/control.c                          | 10 ++--
 sound/core/control_compat.c                   |  2 +-
 sound/core/init.c                             |  2 +-
 sound/core/rawmidi.c                          |  2 +-
 sound/core/seq/seq_clientmgr.c                | 12 ++---
 sound/core/seq/seq_midi_event.c               |  4 +-
 sound/core/seq/seq_ports.c                    |  2 +-
 sound/core/sound.c                            |  2 +-
 sound/core/sound_oss.c                        |  2 +-
 sound/core/vmaster.c                          |  2 +-
 sound/drivers/mts64.c                         |  2 +-
 sound/drivers/portman2x4.c                    |  2 +-
 sound/drivers/vx/vx_hwdep.c                   |  2 +-
 sound/isa/cs423x/cs4236.c                     |  2 +-
 sound/isa/es18xx.c                            |  2 +-
 sound/isa/gus/interwave.c                     |  2 +-
 sound/isa/opl3sa2.c                           |  2 +-
 sound/mips/sgio2audio.c                       |  2 +-
 sound/pci/ac97/ac97_codec.c                   | 18 +++----
 sound/pci/ad1889.c                            |  2 +-
 sound/pci/als300.c                            |  2 +-
 sound/pci/als4000.c                           |  2 +-
 sound/pci/asihpi/asihpi.c                     |  2 +-
 sound/pci/au88x0/au88x0.c                     |  2 +-
 sound/pci/aw2/aw2-alsa.c                      |  2 +-
 sound/pci/bt87x.c                             |  2 +-
 sound/pci/ca0106/ca0106_main.c                |  2 +-
 sound/pci/ca0106/ca0106_mixer.c               |  2 +-
 sound/pci/cmipci.c                            |  2 +-
 sound/pci/cs4281.c                            |  2 +-
 sound/pci/cs46xx/cs46xx.c                     |  2 +-
 sound/pci/cs5530.c                            |  2 +-
 sound/pci/cs5535audio/cs5535audio.c           |  2 +-
 sound/pci/ctxfi/ctatc.c                       | 10 ++--
 sound/pci/ctxfi/ctdaio.c                      |  2 +-
 sound/pci/ctxfi/cthw20k1.c                    |  2 +-
 sound/pci/ctxfi/ctresource.c                  |  4 +-
 sound/pci/ctxfi/xfi.c                         |  2 +-
 sound/pci/echoaudio/echoaudio.c               |  2 +-
 sound/pci/emu10k1/emu10k1.c                   |  2 +-
 sound/pci/emu10k1/emu10k1_main.c              |  2 +-
 sound/pci/emu10k1/emu10k1x.c                  |  2 +-
 sound/pci/emu10k1/emufx.c                     |  2 +-
 sound/pci/emu10k1/emumixer.c                  |  2 +-
 sound/pci/ens1370.c                           |  2 +-
 sound/pci/es1938.c                            |  2 +-
 sound/pci/es1968.c                            |  2 +-
 sound/pci/fm801.c                             |  2 +-
 sound/pci/hda/hda_intel.c                     |  2 +-
 sound/pci/hda/hda_local.h                     |  4 +-
 sound/pci/ice1712/delta.c                     |  2 +-
 sound/pci/ice1712/ice1712.c                   |  2 +-
 sound/pci/ice1712/ice1724.c                   |  2 +-
 sound/pci/ice1712/se.c                        |  2 +-
 sound/pci/korg1212/korg1212.c                 |  2 +-
 sound/pci/lola/lola.c                         |  2 +-
 sound/pci/lx6464es/lx6464es.c                 |  2 +-
 sound/pci/maestro3.c                          |  2 +-
 sound/pci/mixart/mixart.c                     |  2 +-
 sound/pci/mixart/mixart_hwdep.c               |  2 +-
 sound/pci/oxygen/oxygen.c                     |  2 +-
 sound/pci/oxygen/se6x.c                       |  2 +-
 sound/pci/oxygen/virtuoso.c                   |  2 +-
 sound/pci/pcxhr/pcxhr.c                       |  2 +-
 sound/pci/pcxhr/pcxhr_hwdep.c                 |  2 +-
 sound/pci/riptide/riptide.c                   |  2 +-
 sound/pci/rme32.c                             |  2 +-
 sound/pci/rme96.c                             |  2 +-
 sound/pci/rme9652/hdsp.c                      |  4 +-
 sound/pci/rme9652/hdspm.c                     |  2 +-
 sound/pci/rme9652/rme9652.c                   |  2 +-
 sound/pci/sonicvibes.c                        |  2 +-
 sound/pci/trident/trident.c                   |  2 +-
 sound/pci/vx222/vx222.c                       |  2 +-
 sound/pci/ymfpci/ymfpci.c                     |  2 +-
 sound/sh/aica.c                               |  2 +-
 sound/soc/codecs/tas5086.c                    |  2 +-
 sound/soc/intel/boards/ehl_rt5660.c           |  2 +-
 sound/soc/samsung/s3c-i2s-v2.c                |  2 +-
 sound/soc/samsung/smdk_spdif.c                |  4 +-
 sound/soc/sof/debug.c                         |  6 +--
 sound/soc/sof/intel/hda-codec.c               |  2 +-
 sound/soc/ti/omap-mcbsp-st.c                  |  4 +-
 sound/sound_core.c                            |  2 +-
 sound/sparc/amd7930.c                         |  2 +-
 sound/sparc/cs4231.c                          |  2 +-
 sound/sparc/dbri.c                            |  2 +-
 sound/usb/bcd2000/bcd2000.c                   |  2 +-
 sound/usb/midi.c                              | 14 ++---
 sound/usb/misc/ua101.c                        |  2 +-
 sound/usb/pcm.c                               |  6 +--
 tools/bpf/bpftool/tracelog.c                  |  4 +-
 tools/lib/api/fs/fs.c                         |  4 +-
 tools/lib/bpf/btf.c                           | 14 ++---
 tools/lib/bpf/hashmap.c                       |  2 +-
 tools/lib/bpf/hashmap.h                       |  2 +-
 tools/lib/bpf/libbpf.c                        | 30 +++++------
 tools/lib/perf/mmap.c                         |  2 +-
 tools/perf/builtin-kmem.c                     |  4 +-
 tools/perf/builtin-stat.c                     |  2 +-
 tools/perf/builtin-trace.c                    |  4 +-
 tools/perf/pmu-events/jevents.c               |  2 +-
 tools/perf/util/auxtrace.c                    |  2 +-
 tools/perf/util/dwarf-aux.c                   | 26 +++++-----
 tools/perf/util/evswitch.c                    |  4 +-
 tools/perf/util/hashmap.c                     |  2 +-
 tools/perf/util/hashmap.h                     |  2 +-
 tools/perf/util/header.c                      |  2 +-
 .../util/intel-pt-decoder/intel-pt-decoder.c  | 16 +++---
 tools/perf/util/intel-pt.c                    |  2 +-
 tools/perf/util/llvm-utils.c                  |  4 +-
 tools/perf/util/machine.c                     |  2 +-
 tools/perf/util/mem-events.c                  |  2 +-
 tools/perf/util/perf-hooks.c                  |  2 +-
 tools/perf/util/probe-event.c                 | 14 ++---
 tools/perf/util/probe-file.c                  |  2 +-
 tools/perf/util/probe-finder.c                | 52 +++++++++----------
 tools/perf/util/session.c                     |  2 +-
 tools/perf/util/sort.c                        |  4 +-
 tools/perf/util/symbol.c                      |  2 +-
 tools/perf/util/synthetic-events.c            |  2 +-
 tools/testing/selftests/bpf/trace_helpers.c   |  2 +-
 tools/testing/selftests/memfd/fuse_mnt.c      |  8 +--
 tools/testing/selftests/resctrl/resctrlfs.c   |  4 +-
 tools/thermal/tmon/sysfs.c                    |  6 +--
 virt/kvm/kvm_main.c                           | 10 ++--
 1286 files changed, 2486 insertions(+), 2485 deletions(-)

diff --git a/arch/alpha/kernel/perf_event.c b/arch/alpha/kernel/perf_event.c
index e7a59d927..f3f060627 100644
--- a/arch/alpha/kernel/perf_event.c
+++ b/arch/alpha/kernel/perf_event.c
@@ -702,7 +702,7 @@ static int alpha_pmu_event_init(struct perf_event *event)
 		break;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!alpha_pmu)
diff --git a/arch/arc/kernel/perf_event.c b/arch/arc/kernel/perf_event.c
index 661fd842e..1c8a20240 100644
--- a/arch/arc/kernel/perf_event.c
+++ b/arch/arc/kernel/perf_event.c
@@ -154,7 +154,7 @@ static int arc_pmu_cache_event(u64 config)
 	ret = arc_pmu_cache_map[cache_type][cache_op][cache_result];
 
 	if (ret == CACHE_OP_UNSUPPORTED)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pr_debug("init cache event: type/op/result %d/%d/%d with h/w %d \'%s\'\n",
 		 cache_type, cache_op, cache_result, ret,
@@ -190,9 +190,9 @@ static int arc_pmu_event_init(struct perf_event *event)
 	switch (event->attr.type) {
 	case PERF_TYPE_HARDWARE:
 		if (event->attr.config >= PERF_COUNT_HW_MAX)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (arc_pmu->ev_hw_idx[event->attr.config] < 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		hwc->config |= arc_pmu->ev_hw_idx[event->attr.config];
 		pr_debug("init event %d with h/w %08x \'%s\'\n",
 			 (int)event->attr.config, (int)hwc->config,
@@ -210,7 +210,7 @@ static int arc_pmu_event_init(struct perf_event *event)
 
 	case PERF_TYPE_RAW:
 		if (event->attr.config >= arc_pmu->n_events)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		hwc->config |= event->attr.config;
 		pr_debug("init raw event with idx %lld \'%s\'\n",
@@ -220,7 +220,7 @@ static int arc_pmu_event_init(struct perf_event *event)
 		return 0;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/arch/arm/kernel/cpuidle.c b/arch/arm/kernel/cpuidle.c
index 093368e0d..e84ce7257 100644
--- a/arch/arm/kernel/cpuidle.c
+++ b/arch/arm/kernel/cpuidle.c
@@ -91,7 +91,7 @@ static int __init arm_cpuidle_read_ops(struct device_node *dn, int cpu)
 
 	enable_method = of_get_property(dn, "enable-method", NULL);
 	if (!enable_method)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ops = arm_cpuidle_get_ops(enable_method);
 	if (!ops) {
diff --git a/arch/arm/mach-axxia/platsmp.c b/arch/arm/mach-axxia/platsmp.c
index 512943eae..631d8f38a 100644
--- a/arch/arm/mach-axxia/platsmp.c
+++ b/arch/arm/mach-axxia/platsmp.c
@@ -36,7 +36,7 @@ static int axxia_boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 	syscon_np = of_find_compatible_node(NULL, NULL, "lsi,axxia-syscon");
 	if (!syscon_np)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	syscon = of_iomap(syscon_np, 0);
 	if (!syscon)
diff --git a/arch/arm/mach-bcm/bcm63xx_smp.c b/arch/arm/mach-bcm/bcm63xx_smp.c
index 641e1f8fc..e58220ee2 100644
--- a/arch/arm/mach-bcm/bcm63xx_smp.c
+++ b/arch/arm/mach-bcm/bcm63xx_smp.c
@@ -47,7 +47,7 @@ static int __init scu_a9_enable(void)
 	config_base = scu_a9_get_base();
 	if (!config_base) {
 		pr_err("hardware reports only one core\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	scu_base = ioremap((phys_addr_t)config_base, CORTEX_A9_SCU_SIZE);
diff --git a/arch/arm/mach-bcm/platsmp.c b/arch/arm/mach-bcm/platsmp.c
index c9db2a900..aea53b3bd 100644
--- a/arch/arm/mach-bcm/platsmp.c
+++ b/arch/arm/mach-bcm/platsmp.c
@@ -58,7 +58,7 @@ static int __init scu_a9_enable(void)
 	config_base = scu_a9_get_base();
 	if (!config_base) {
 		pr_err("hardware reports only one core\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	scu_base = ioremap((phys_addr_t)config_base, CORTEX_A9_SCU_SIZE);
diff --git a/arch/arm/mach-davinci/cpuidle.c b/arch/arm/mach-davinci/cpuidle.c
index b795f671b..8f9ad39a8 100644
--- a/arch/arm/mach-davinci/cpuidle.c
+++ b/arch/arm/mach-davinci/cpuidle.c
@@ -74,7 +74,7 @@ static int __init davinci_cpuidle_probe(struct platform_device *pdev)
 
 	if (!pdata) {
 		dev_err(&pdev->dev, "cannot get platform data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ddr2_reg_base = pdata->ddr2_ctlr_base;
diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 3bf14ca78..45a5a85ed 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -104,7 +104,7 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 	const struct exynos_wkup_irq *wkup_irq;
 
 	if (!pm_data->wkup_irq)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	wkup_irq = pm_data->wkup_irq;
 
 	while (wkup_irq->mask) {
@@ -118,7 +118,7 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 		++wkup_irq;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct irq_chip exynos_pmu_chip = {
diff --git a/arch/arm/mach-hisi/hotplug.c b/arch/arm/mach-hisi/hotplug.c
index 5c5f255ab..8f58dbd60 100644
--- a/arch/arm/mach-hisi/hotplug.c
+++ b/arch/arm/mach-hisi/hotplug.c
@@ -147,7 +147,7 @@ static int hi3xxx_hotplug_init(void)
 	node = of_find_compatible_node(NULL, NULL, "hisilicon,sysctrl");
 	if (!node) {
 		id = ERROR_CTRL;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ctrl_base = of_iomap(node, 0);
diff --git a/arch/arm/mach-imx/mmdc.c b/arch/arm/mach-imx/mmdc.c
index 0dfd0ae7a..1e2a5a3b1 100644
--- a/arch/arm/mach-imx/mmdc.c
+++ b/arch/arm/mach-imx/mmdc.c
@@ -278,7 +278,7 @@ static int mmdc_pmu_event_init(struct perf_event *event)
 	int cfg = event->attr.config;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (is_sampling_event(event) || event->attach_state & PERF_ATTACH_TASK)
 		return -EOPNOTSUPP;
diff --git a/arch/arm/mach-mvebu/cpu-reset.c b/arch/arm/mach-mvebu/cpu-reset.c
index f33a31c6a..e4b6e1fac 100644
--- a/arch/arm/mach-mvebu/cpu-reset.c
+++ b/arch/arm/mach-mvebu/cpu-reset.c
@@ -47,7 +47,7 @@ static int mvebu_cpu_reset_map(struct device_node *np, int res_idx)
 
 	if (of_address_to_resource(np, res_idx, &res)) {
 		pr_err("unable to get resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!request_mem_region(res.start, resource_size(&res),
diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 15b29a179..743fd797f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1451,7 +1451,7 @@ static int _lookup_hardreset(struct omap_hwmod *oh, const char *name,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
@@ -1695,7 +1695,7 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* clocks must be on for this operation */
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
@@ -2202,7 +2202,7 @@ int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
 
 	ranges = of_get_property(np, "ranges", &len);
 	if (!ranges)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	len /= sizeof(*ranges);
 
@@ -2214,15 +2214,15 @@ int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
 			break;
 
 	if (!name)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = of_property_read_u32(np, "#address-cells", &nr_addr);
 	if (error)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = of_property_read_u32(np, "#size-cells", &nr_size);
 	if (error)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (nr_addr != 1 || nr_size != 1) {
 		pr_err("%s: invalid range for %s->%pOFn\n", __func__,
diff --git a/arch/arm/mach-omap2/pm.c b/arch/arm/mach-omap2/pm.c
index 01ec1ba48..92f0e52d0 100644
--- a/arch/arm/mach-omap2/pm.c
+++ b/arch/arm/mach-omap2/pm.c
@@ -80,7 +80,7 @@ static int omap_pm_enter(suspend_state_t suspend_state)
 	int ret = 0;
 
 	if (!omap_pm_suspend)
-		return -ENOENT; /* XXX doublecheck */
+		ENOENT_DUMPER(stackdump_tuneable); /* XXX doublecheck */
 
 	switch (suspend_state) {
 	case PM_SUSPEND_MEM:
diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 65b2d82ef..bfcb191c5 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -171,14 +171,14 @@ int omap_prcm_event_to_irq(const char *name)
 	int i;
 
 	if (!prcm_irq_setup || !name)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < prcm_irq_setup->nr_irqs; i++)
 		if (!strcmp(prcm_irq_setup->irqs[i].name, name))
 			return prcm_irq_setup->base_irq +
 				prcm_irq_setup->irqs[i].offset;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/arch/arm/mach-prima2/pm.c b/arch/arm/mach-prima2/pm.c
index c24bc89f3..d62323d27 100644
--- a/arch/arm/mach-prima2/pm.c
+++ b/arch/arm/mach-prima2/pm.c
@@ -99,7 +99,7 @@ static int __init sirfsoc_of_pwrc_init(void)
 	np = of_find_matching_node(NULL, pwrc_ids);
 	if (!np) {
 		pr_err("unable to find compatible sirf pwrc node in dtb\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/arch/arm/mach-s3c24xx/irq-pm.c b/arch/arm/mach-s3c24xx/irq-pm.c
index e0131b16a..2ff4367cc 100644
--- a/arch/arm/mach-s3c24xx/irq-pm.c
+++ b/arch/arm/mach-s3c24xx/irq-pm.c
@@ -29,7 +29,7 @@ int s3c_irq_wake(struct irq_data *data, unsigned int state)
 	unsigned long irqbit = 1 << data->hwirq;
 
 	if (!(s3c_irqwake_intallow & irqbit))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pr_info("wake %s for hwirq %lu\n",
 		state ? "enabled" : "disabled", data->hwirq);
diff --git a/arch/arm/mm/cache-l2x0-pmu.c b/arch/arm/mm/cache-l2x0-pmu.c
index 993fefdc1..df26ec319 100644
--- a/arch/arm/mm/cache-l2x0-pmu.c
+++ b/arch/arm/mm/cache-l2x0-pmu.c
@@ -296,7 +296,7 @@ static int l2x0_pmu_event_init(struct perf_event *event)
 	struct hw_perf_event *hw = &event->hw;
 
 	if (event->attr.type != l2x0_pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (is_sampling_event(event) ||
 	    event->attach_state & PERF_ATTACH_TASK)
diff --git a/arch/arm/mm/pmsa-v7.c b/arch/arm/mm/pmsa-v7.c
index 699fa2e88..c5ac57b5b 100644
--- a/arch/arm/mm/pmsa-v7.c
+++ b/arch/arm/mm/pmsa-v7.c
@@ -371,7 +371,7 @@ static int __init mpu_setup_region(unsigned int number, phys_addr_t start,
 	/* We kept a region free for probing resolution of MPU regions*/
 	if (number > mpu_max_regions
 	    || number >= MPU_MAX_REGIONS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (size_order > 32)
 		return -ENOMEM;
diff --git a/arch/arm/mm/pmsa-v8.c b/arch/arm/mm/pmsa-v8.c
index 0d7d5fb59..c071740af 100644
--- a/arch/arm/mm/pmsa-v8.c
+++ b/arch/arm/mm/pmsa-v8.c
@@ -141,7 +141,7 @@ static int __init __pmsav8_setup_region(unsigned int number, u32 bar, u32 lar)
 {
 	if (number > mpu_max_regions
 	    || number >= MPU_MAX_REGIONS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dsb();
 	prsel_write(number);
diff --git a/arch/arm/plat-samsung/adc.c b/arch/arm/plat-samsung/adc.c
index 55b1925f6..52da406e3 100644
--- a/arch/arm/plat-samsung/adc.c
+++ b/arch/arm/plat-samsung/adc.c
@@ -354,7 +354,7 @@ static int s3c_adc_probe(struct platform_device *pdev)
 
 	adc->irq = platform_get_irq(pdev, 1);
 	if (adc->irq <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = devm_request_irq(dev, adc->irq, s3c_adc_irq, 0, dev_name(dev),
 				adc);
diff --git a/arch/arm/plat-samsung/pm.c b/arch/arm/plat-samsung/pm.c
index d6bfd6659..0f086b822 100644
--- a/arch/arm/plat-samsung/pm.c
+++ b/arch/arm/plat-samsung/pm.c
@@ -43,7 +43,7 @@ int s3c_irqext_wake(struct irq_data *data, unsigned int state)
 	unsigned long bit = 1L << IRQ_EINT_BIT(data->irq);
 
 	if (!(s3c_irqwake_eintallow & bit))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	printk(KERN_INFO "wake %s for irq %d\n",
 	       state ? "enabled" : "disabled", data->irq);
diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h
index a45366c39..8a7c01fb3 100644
--- a/arch/arm64/include/asm/acpi.h
+++ b/arch/arm64/include/asm/acpi.h
@@ -115,7 +115,7 @@ void __init acpi_init_cpus(void);
 int apei_claim_sea(struct pt_regs *regs);
 #else
 static inline void acpi_init_cpus(void) { }
-static inline int apei_claim_sea(struct pt_regs *regs) { return -ENOENT; }
+static inline int apei_claim_sea(struct pt_regs *regs) { ENOENT_DUMPER(stackdump_tuneable); }
 #endif /* CONFIG_ACPI */
 
 #ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
diff --git a/arch/arm64/kvm/arm.c b/arch/arm64/kvm/arm.c
index 90cb90561..45b36cc50 100644
--- a/arch/arm64/kvm/arm.c
+++ b/arch/arm64/kvm/arm.c
@@ -944,7 +944,7 @@ static int kvm_vcpu_set_target(struct kvm_vcpu *vcpu,
 		bool set = (init->features[i / 32] & (1 << (i % 32)));
 
 		if (set && i >= KVM_VCPU_MAX_FEATURES)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/*
 		 * Secondary and subsequent calls to KVM_ARM_VCPU_INIT must
diff --git a/arch/arm64/kvm/guest.c b/arch/arm64/kvm/guest.c
index aea43ec60..483d6d9a3 100644
--- a/arch/arm64/kvm/guest.c
+++ b/arch/arm64/kvm/guest.c
@@ -133,7 +133,7 @@ static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 	off = core_reg_offset_from_id(reg->id);
 	if (off >= nr_regs ||
 	    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (validate_core_offset(vcpu, reg))
 		return -EINVAL;
@@ -158,7 +158,7 @@ static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 	off = core_reg_offset_from_id(reg->id);
 	if (off >= nr_regs ||
 	    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (validate_core_offset(vcpu, reg))
 		return -EINVAL;
@@ -220,7 +220,7 @@ static int get_sve_vls(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 	u64 vqs[KVM_ARM64_SVE_VLS_WORDS];
 
 	if (!vcpu_has_sve(vcpu))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (WARN_ON(!sve_vl_valid(vcpu->arch.sve_max_vl)))
 		return -EINVAL;
@@ -244,7 +244,7 @@ static int set_sve_vls(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 	u64 vqs[KVM_ARM64_SVE_VLS_WORDS];
 
 	if (!vcpu_has_sve(vcpu))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (kvm_arm_vcpu_sve_finalized(vcpu))
 		return -EPERM; /* too late! */
@@ -353,7 +353,7 @@ static int sve_reg_to_region(struct sve_state_reg_region *region,
 
 	if (reg->id >= zreg_id_min && reg->id <= zreg_id_max) {
 		if (!vcpu_has_sve(vcpu) || (reg->id & SVE_REG_SLICE_MASK) > 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		vq = sve_vq_from_vl(vcpu->arch.sve_max_vl);
 
@@ -363,7 +363,7 @@ static int sve_reg_to_region(struct sve_state_reg_region *region,
 		maxlen = SVE_SIG_ZREG_SIZE(vq);
 	} else if (reg->id >= preg_id_min && reg->id <= preg_id_max) {
 		if (!vcpu_has_sve(vcpu) || (reg->id & SVE_REG_SLICE_MASK) > 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		vq = sve_vq_from_vl(vcpu->arch.sve_max_vl);
 
diff --git a/arch/arm64/kvm/psci.c b/arch/arm64/kvm/psci.c
index 83415e96b..e7e38de86 100644
--- a/arch/arm64/kvm/psci.c
+++ b/arch/arm64/kvm/psci.c
@@ -472,7 +472,7 @@ int kvm_arm_get_fw_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 			val |= KVM_REG_ARM_SMCCC_ARCH_WORKAROUND_2_ENABLED;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (copy_to_user(uaddr, &val, KVM_REG_SIZE(reg->id)))
@@ -557,7 +557,7 @@ int kvm_arm_set_fw_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 
 		return 0;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return -EINVAL;
diff --git a/arch/arm64/kvm/sys_regs.c b/arch/arm64/kvm/sys_regs.c
index baf5ce922..98c7da668 100644
--- a/arch/arm64/kvm/sys_regs.c
+++ b/arch/arm64/kvm/sys_regs.c
@@ -1203,7 +1203,7 @@ static int get_id_aa64zfr0_el1(struct kvm_vcpu *vcpu,
 	u64 val;
 
 	if (WARN_ON(!vcpu_has_sve(vcpu)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	val = guest_id_aa64zfr0_el1(vcpu);
 	return reg_to_user(uaddr, &val, reg->id);
@@ -1218,7 +1218,7 @@ static int set_id_aa64zfr0_el1(struct kvm_vcpu *vcpu,
 	u64 val;
 
 	if (WARN_ON(!vcpu_has_sve(vcpu)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = reg_from_user(&val, uaddr, id);
 	if (err)
@@ -2571,7 +2571,7 @@ static int get_invariant_sys_reg(u64 id, void __user *uaddr)
 	r = find_reg_by_id(id, &params, invariant_sys_regs,
 			   ARRAY_SIZE(invariant_sys_regs));
 	if (!r)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return reg_to_user(uaddr, &r->val, id);
 }
@@ -2586,7 +2586,7 @@ static int set_invariant_sys_reg(u64 id, void __user *uaddr)
 	r = find_reg_by_id(id, &params, invariant_sys_regs,
 			   ARRAY_SIZE(invariant_sys_regs));
 	if (!r)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = reg_from_user(&val, uaddr, id);
 	if (err)
@@ -2633,20 +2633,20 @@ static int demux_c15_get(u64 id, void __user *uaddr)
 	/* Fail if we have unknown bits set. */
 	if (id & ~(KVM_REG_ARCH_MASK|KVM_REG_SIZE_MASK|KVM_REG_ARM_COPROC_MASK
 		   | ((1 << KVM_REG_ARM_COPROC_SHIFT)-1)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (id & KVM_REG_ARM_DEMUX_ID_MASK) {
 	case KVM_REG_ARM_DEMUX_ID_CCSIDR:
 		if (KVM_REG_SIZE(id) != 4)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		val = (id & KVM_REG_ARM_DEMUX_VAL_MASK)
 			>> KVM_REG_ARM_DEMUX_VAL_SHIFT;
 		if (!is_valid_cache(val))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		return put_user(get_ccsidr(val), uval);
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
@@ -2658,16 +2658,16 @@ static int demux_c15_set(u64 id, void __user *uaddr)
 	/* Fail if we have unknown bits set. */
 	if (id & ~(KVM_REG_ARCH_MASK|KVM_REG_SIZE_MASK|KVM_REG_ARM_COPROC_MASK
 		   | ((1 << KVM_REG_ARM_COPROC_SHIFT)-1)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (id & KVM_REG_ARM_DEMUX_ID_MASK) {
 	case KVM_REG_ARM_DEMUX_ID_CCSIDR:
 		if (KVM_REG_SIZE(id) != 4)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		val = (id & KVM_REG_ARM_DEMUX_VAL_MASK)
 			>> KVM_REG_ARM_DEMUX_VAL_SHIFT;
 		if (!is_valid_cache(val))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (get_user(newval, uval))
 			return -EFAULT;
@@ -2677,7 +2677,7 @@ static int demux_c15_set(u64 id, void __user *uaddr)
 			return -EINVAL;
 		return 0;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
@@ -2690,7 +2690,7 @@ int kvm_arm_sys_reg_get_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg
 		return demux_c15_get(reg->id, uaddr);
 
 	if (KVM_REG_SIZE(reg->id) != sizeof(__u64))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	r = index_to_sys_reg_desc(vcpu, reg->id);
 	if (!r)
@@ -2698,7 +2698,7 @@ int kvm_arm_sys_reg_get_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg
 
 	/* Check for regs disabled by runtime config */
 	if (sysreg_hidden_from_user(vcpu, r))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (r->get_user)
 		return (r->get_user)(vcpu, r, reg, uaddr);
@@ -2715,7 +2715,7 @@ int kvm_arm_sys_reg_set_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg
 		return demux_c15_set(reg->id, uaddr);
 
 	if (KVM_REG_SIZE(reg->id) != sizeof(__u64))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	r = index_to_sys_reg_desc(vcpu, reg->id);
 	if (!r)
@@ -2723,7 +2723,7 @@ int kvm_arm_sys_reg_set_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg
 
 	/* Check for regs disabled by runtime config */
 	if (sysreg_hidden_from_user(vcpu, r))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (r->set_user)
 		return (r->set_user)(vcpu, r, reg, uaddr);
diff --git a/arch/csky/kernel/perf_event.c b/arch/csky/kernel/perf_event.c
index 1a29f1157..b4f05f31a 100644
--- a/arch/csky/kernel/perf_event.c
+++ b/arch/csky/kernel/perf_event.c
@@ -973,25 +973,25 @@ static int csky_pmu_event_init(struct perf_event *event)
 	switch (event->attr.type) {
 	case PERF_TYPE_HARDWARE:
 		if (event->attr.config >= PERF_COUNT_HW_MAX)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		ret = csky_pmu_hw_map[event->attr.config];
 		if (ret == HW_OP_UNSUPPORTED)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		hwc->idx = ret;
 		break;
 	case PERF_TYPE_HW_CACHE:
 		ret = csky_pmu_cache_event(event->attr.config);
 		if (ret == CACHE_OP_UNSUPPORTED)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		hwc->idx = ret;
 		break;
 	case PERF_TYPE_RAW:
 		if (hw_raw_read_mapping[event->attr.config] == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		hwc->idx = event->attr.config;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (event->attr.exclude_user)
diff --git a/arch/mips/alchemy/devboards/pm.c b/arch/mips/alchemy/devboards/pm.c
index 73c778146..e757b84bd 100644
--- a/arch/mips/alchemy/devboards/pm.c
+++ b/arch/mips/alchemy/devboards/pm.c
@@ -142,7 +142,7 @@ static ssize_t db1x_pmattr_show(struct kobject *kobj,
 		return sprintf(buf, "%08lx\n", db1x_pm_wakemsk);
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static ssize_t db1x_pmattr_store(struct kobject *kobj,
diff --git a/arch/mips/kernel/cacheinfo.c b/arch/mips/kernel/cacheinfo.c
index 47312c529..11e3793ce 100644
--- a/arch/mips/kernel/cacheinfo.c
+++ b/arch/mips/kernel/cacheinfo.c
@@ -30,7 +30,7 @@ static int __init_cache_level(unsigned int cpu)
 	if (c->dcache.waysize)
 		levels += 1;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 
 	leaves += (c->icache.waysize) ? 2 : 1;
diff --git a/arch/mips/kernel/perf_event_mipsxx.c b/arch/mips/kernel/perf_event_mipsxx.c
index efce5defc..5e2e09809 100644
--- a/arch/mips/kernel/perf_event_mipsxx.c
+++ b/arch/mips/kernel/perf_event_mipsxx.c
@@ -664,7 +664,7 @@ static int mipspmu_event_init(struct perf_event *event)
 		break;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (event->cpu >= 0 && !cpu_online(event->cpu))
diff --git a/arch/mips/lantiq/xway/gptu.c b/arch/mips/lantiq/xway/gptu.c
index 3d5683e75..e161da586 100644
--- a/arch/mips/lantiq/xway/gptu.c
+++ b/arch/mips/lantiq/xway/gptu.c
@@ -152,7 +152,7 @@ static int gptu_probe(struct platform_device *pdev)
 	clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(clk)) {
 		dev_err(&pdev->dev, "Failed to get clock\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	clk_enable(clk);
 
diff --git a/arch/nds32/kernel/perf_event_cpu.c b/arch/nds32/kernel/perf_event_cpu.c
index 0ce6f9f30..7c3600990 100644
--- a/arch/nds32/kernel/perf_event_cpu.c
+++ b/arch/nds32/kernel/perf_event_cpu.c
@@ -60,7 +60,7 @@ static int nds32_pmu_map_cache_event(const unsigned int (*cache_map)
 	ret = (int)(*cache_map)[cache_type][cache_op][cache_result];
 
 	if (ret == CACHE_OP_UNSUPPORTED)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ret;
 }
@@ -72,7 +72,7 @@ nds32_pmu_map_hw_event(const unsigned int (*event_map)[PERF_COUNT_HW_MAX],
 	int mapping;
 
 	if (config >= PERF_COUNT_HW_MAX)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mapping = (*event_map)[config];
 	return mapping == HW_OP_UNSUPPORTED ? -ENOENT : mapping;
@@ -87,20 +87,20 @@ static int nds32_pmu_map_raw_event(u32 raw_event_mask, u64 config)
 	case 0:
 		ev_type = PFM_OFFSET_MAGIC_0 + ev_type;
 		if (ev_type >= SPAV3_0_SEL_LAST || ev_type <= SPAV3_0_SEL_BASE)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		break;
 	case 1:
 		ev_type = PFM_OFFSET_MAGIC_1 + ev_type;
 		if (ev_type >= SPAV3_1_SEL_LAST || ev_type <= SPAV3_1_SEL_BASE)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		break;
 	case 2:
 		ev_type = PFM_OFFSET_MAGIC_2 + ev_type;
 		if (ev_type >= SPAV3_2_SEL_LAST || ev_type <= SPAV3_2_SEL_BASE)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return ev_type;
@@ -125,7 +125,7 @@ nds32_pmu_map_event(struct perf_event *event,
 		return nds32_pmu_map_raw_event(raw_event_mask, config);
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int nds32_spav3_map_event(struct perf_event *event)
@@ -865,7 +865,7 @@ static int nds32_pmu_event_init(struct perf_event *event)
 		return -EOPNOTSUPP;
 
 	if (nds32_pmu->map_event(event) == -ENOENT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!atomic_inc_not_zero(active_events)) {
 		if (atomic_read(active_events) == 0) {
diff --git a/arch/parisc/kernel/module.c b/arch/parisc/kernel/module.c
index 7df140545..4716086bd 100644
--- a/arch/parisc/kernel/module.c
+++ b/arch/parisc/kernel/module.c
@@ -547,7 +547,7 @@ int apply_relocate_add(Elf_Shdr *sechdrs,
 		if (!sym->st_value) {
 			printk(KERN_WARNING "%s: Unknown symbol %s\n",
 			       me->name, strtab + sym->st_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		//dot = (sechdrs[relsec].sh_addr + rel->r_offset) & ~0x03;
 		dot =  (Elf32_Addr)loc & ~0x03;
@@ -691,7 +691,7 @@ int apply_relocate_add(Elf_Shdr *sechdrs,
 		if (!sym->st_value) {
 			printk(KERN_WARNING "%s: Unknown symbol %s\n",
 			       me->name, strtab + sym->st_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		//dot = (sechdrs[relsec].sh_addr + rel->r_offset) & ~0x03;
 		dot = (Elf64_Addr)loc & ~0x03;
diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h
index ccf66b3a4..65e8fa77e 100644
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@ -705,7 +705,7 @@ static inline int kvmppc_xive_set_mapped(struct kvm *kvm, unsigned long guest_ir
 static inline int kvmppc_xive_clr_mapped(struct kvm *kvm, unsigned long guest_irq,
 					 struct irq_desc *host_desc) { return -ENODEV; }
 static inline u64 kvmppc_xive_get_icp(struct kvm_vcpu *vcpu) { return 0; }
-static inline int kvmppc_xive_set_icp(struct kvm_vcpu *vcpu, u64 icpval) { return -ENOENT; }
+static inline int kvmppc_xive_set_icp(struct kvm_vcpu *vcpu, u64 icpval) { ENOENT_DUMPER(stackdump_tuneable); }
 
 static inline int kvmppc_xive_set_irq(struct kvm *kvm, int irq_source_id, u32 irq,
 				      int level, bool line_status) { return -ENODEV; }
@@ -723,7 +723,7 @@ static inline int kvmppc_xive_native_get_vp(struct kvm_vcpu *vcpu,
 { return 0; }
 static inline int kvmppc_xive_native_set_vp(struct kvm_vcpu *vcpu,
 					    union kvmppc_one_reg *val)
-{ return -ENOENT; }
+{ ENOENT_DUMPER(stackdump_tuneable); }
 
 #endif /* CONFIG_KVM_XIVE */
 
diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c
index d407981de..c73bee756 100644
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@ -1528,7 +1528,7 @@ int eeh_pe_get_state(struct eeh_pe *pe)
 		return -ENODEV;
 
 	if (!eeh_ops || !eeh_ops->get_state)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * If the parent PE is owned by the host kernel and is undergoing
@@ -1616,7 +1616,7 @@ int eeh_pe_reset(struct eeh_pe *pe, int option, bool include_passed)
 		return -ENODEV;
 
 	if (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (option) {
 	case EEH_RESET_DEACTIVATE:
@@ -1690,7 +1690,7 @@ int eeh_pe_inject_err(struct eeh_pe *pe, int type, int func,
 
 	/* Unsupported operation ? */
 	if (!eeh_ops || !eeh_ops->err_inject)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Check on PCI error type */
 	if (type != EEH_ERR_TYPE_32 && type != EEH_ERR_TYPE_64)
diff --git a/arch/powerpc/kernel/iommu.c b/arch/powerpc/kernel/iommu.c
index 9704f3f76..72721bf35 100644
--- a/arch/powerpc/kernel/iommu.c
+++ b/arch/powerpc/kernel/iommu.c
@@ -1106,7 +1106,7 @@ int iommu_add_device(struct iommu_table_group *table_group, struct device *dev)
 	 * ready, we simply bail.
 	 */
 	if (!device_is_registered(dev))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (device_iommu_mapped(dev)) {
 		pr_debug("%s: Skipping device %s with iommu group %d\n",
diff --git a/arch/powerpc/kernel/module_32.c b/arch/powerpc/kernel/module_32.c
index c27b8687b..66c015ecd 100644
--- a/arch/powerpc/kernel/module_32.c
+++ b/arch/powerpc/kernel/module_32.c
@@ -286,7 +286,7 @@ int module_finalize_ftrace(struct module *module, const Elf_Shdr *sechdrs)
 					 (unsigned long)ftrace_caller,
 					 sechdrs, module);
 	if (!module->arch.tramp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/arch/powerpc/kernel/module_64.c b/arch/powerpc/kernel/module_64.c
index ae2b18836..92358fe6d 100644
--- a/arch/powerpc/kernel/module_64.c
+++ b/arch/powerpc/kernel/module_64.c
@@ -637,7 +637,7 @@ int apply_relocate_add(Elf64_Shdr *sechdrs,
 				value = stub_for_addr(sechdrs, value, me,
 						strtab + sym->st_name);
 				if (!value)
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 				if (!restore_r2(strtab + sym->st_name,
 							(u32 *)location + 1, me))
 					return -ENOEXEC;
@@ -790,11 +790,11 @@ int module_finalize_ftrace(struct module *mod, const Elf_Shdr *sechdrs)
 					mod,
 					"ftrace_regs_caller");
 	if (!mod->arch.tramp_regs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 #endif
 
 	if (!mod->arch.tramp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/arch/powerpc/kernel/ptrace/ptrace-adv.c b/arch/powerpc/kernel/ptrace/ptrace-adv.c
index 3990c01ef..94804825c 100644
--- a/arch/powerpc/kernel/ptrace/ptrace-adv.c
+++ b/arch/powerpc/kernel/ptrace/ptrace-adv.c
@@ -230,7 +230,7 @@ static int del_instruction_bp(struct task_struct *child, int slot)
 	switch (slot) {
 	case 1:
 		if ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (dbcr_iac_range(child) & DBCR_IAC12MODE) {
 			/* address range - clear slots 1 & 2 */
@@ -242,7 +242,7 @@ static int del_instruction_bp(struct task_struct *child, int slot)
 		break;
 	case 2:
 		if ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (dbcr_iac_range(child) & DBCR_IAC12MODE)
 			/* used in a range */
@@ -253,7 +253,7 @@ static int del_instruction_bp(struct task_struct *child, int slot)
 #if CONFIG_PPC_ADV_DEBUG_IACS > 2
 	case 3:
 		if ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (dbcr_iac_range(child) & DBCR_IAC34MODE) {
 			/* address range - clear slots 3 & 4 */
@@ -265,7 +265,7 @@ static int del_instruction_bp(struct task_struct *child, int slot)
 		break;
 	case 4:
 		if ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (dbcr_iac_range(child) & DBCR_IAC34MODE)
 			/* Used in a range */
@@ -345,7 +345,7 @@ static int del_dac(struct task_struct *child, int slot)
 {
 	if (slot == 1) {
 		if ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		child->thread.debug.dac1 = 0;
 		dbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);
@@ -361,7 +361,7 @@ static int del_dac(struct task_struct *child, int slot)
 #endif
 	} else if (slot == 2) {
 		if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 #ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE
 		if (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)
diff --git a/arch/powerpc/kernel/ptrace/ptrace-noadv.c b/arch/powerpc/kernel/ptrace/ptrace-noadv.c
index 697c7e4b5..0979f3f4b 100644
--- a/arch/powerpc/kernel/ptrace/ptrace-noadv.c
+++ b/arch/powerpc/kernel/ptrace/ptrace-noadv.c
@@ -287,7 +287,7 @@ long ppc_del_hwdebug(struct task_struct *child, long data)
 	return ret;
 #else /* CONFIG_HAVE_HW_BREAKPOINT */
 	if (child->thread.hw_brk[data - 1].address == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	child->thread.hw_brk[data - 1].address = 0;
 	child->thread.hw_brk[data - 1].type = 0;
diff --git a/arch/powerpc/kernel/rtas.c b/arch/powerpc/kernel/rtas.c
index a09eba03f..b2d7dbcce 100644
--- a/arch/powerpc/kernel/rtas.c
+++ b/arch/powerpc/kernel/rtas.c
@@ -554,7 +554,7 @@ int rtas_get_power_level(int powerdomain, int *level)
 	int rc;
 
 	if (token == RTAS_UNKNOWN_SERVICE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	while ((rc = rtas_call(token, 1, 2, level, powerdomain)) == RTAS_BUSY)
 		udelay(1);
@@ -571,7 +571,7 @@ int rtas_set_power_level(int powerdomain, int level, int *setlevel)
 	int rc;
 
 	if (token == RTAS_UNKNOWN_SERVICE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	do {
 		rc = rtas_call(token, 2, 2, setlevel, powerdomain, level);
@@ -589,7 +589,7 @@ int rtas_get_sensor(int sensor, int index, int *state)
 	int rc;
 
 	if (token == RTAS_UNKNOWN_SERVICE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	do {
 		rc = rtas_call(token, 2, 2, state, sensor, index);
@@ -607,7 +607,7 @@ int rtas_get_sensor_fast(int sensor, int index, int *state)
 	int rc;
 
 	if (token == RTAS_UNKNOWN_SERVICE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = rtas_call(token, 2, 2, state, sensor, index);
 	WARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&
@@ -650,7 +650,7 @@ int rtas_set_indicator(int indicator, int index, int new_value)
 	int rc;
 
 	if (token == RTAS_UNKNOWN_SERVICE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	do {
 		rc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);
@@ -671,7 +671,7 @@ int rtas_set_indicator_fast(int indicator, int index, int new_value)
 	int token = rtas_token("set-indicator");
 
 	if (token == RTAS_UNKNOWN_SERVICE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);
 
diff --git a/arch/powerpc/kernel/smp.c b/arch/powerpc/kernel/smp.c
index 73199470c..919211251 100644
--- a/arch/powerpc/kernel/smp.c
+++ b/arch/powerpc/kernel/smp.c
@@ -1052,7 +1052,7 @@ int __cpu_up(unsigned int cpu, struct task_struct *tidle)
 
 	if (!cpu_callin_map[cpu]) {
 		printk(KERN_ERR "Processor %u is stuck.\n", cpu);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	DBG("Processor %u found.\n", cpu);
diff --git a/arch/powerpc/kexec/core.c b/arch/powerpc/kexec/core.c
index 56da5eb2b..fe291dd18 100644
--- a/arch/powerpc/kexec/core.c
+++ b/arch/powerpc/kexec/core.c
@@ -265,7 +265,7 @@ static int __init kexec_setup(void)
 
 	node = of_find_node_by_path("/chosen");
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* remove any stale properties so ours can be found */
 	of_remove_property(node, of_find_property(node, kernel_end_prop.name, NULL));
diff --git a/arch/powerpc/kexec/file_load.c b/arch/powerpc/kexec/file_load.c
index 143c91724..fad2e030f 100644
--- a/arch/powerpc/kexec/file_load.c
+++ b/arch/powerpc/kexec/file_load.c
@@ -116,7 +116,7 @@ int delete_fdt_mem_rsv(void *fdt, unsigned long start, unsigned long size)
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/arch/powerpc/kexec/ima.c b/arch/powerpc/kexec/ima.c
index 720e50e49..3099a7aaf 100644
--- a/arch/powerpc/kexec/ima.c
+++ b/arch/powerpc/kexec/ima.c
@@ -38,7 +38,7 @@ static int do_get_kexec_buffer(const void *prop, int len, unsigned long *addr,
 		return ret;
 
 	if (len < 4 * (addr_cells + size_cells))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*addr = of_read_number(prop, addr_cells);
 	*size = of_read_number(prop + 4 * addr_cells, size_cells);
@@ -62,7 +62,7 @@ int ima_get_kexec_buffer(void **addr, size_t *size)
 
 	prop = of_get_property(of_chosen, "linux,ima-kexec-buffer", &len);
 	if (!prop)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = do_get_kexec_buffer(prop, len, &tmp_addr, &tmp_size);
 	if (ret)
@@ -86,7 +86,7 @@ int ima_free_kexec_buffer(void)
 
 	prop = of_find_property(of_chosen, "linux,ima-kexec-buffer", NULL);
 	if (!prop)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = do_get_kexec_buffer(prop->value, prop->length, &addr, &size);
 	if (ret)
diff --git a/arch/powerpc/kvm/book3s_32_mmu.c b/arch/powerpc/kvm/book3s_32_mmu.c
index 3fbd570f9..2c524cc48 100644
--- a/arch/powerpc/kvm/book3s_32_mmu.c
+++ b/arch/powerpc/kvm/book3s_32_mmu.c
@@ -176,7 +176,7 @@ static int kvmppc_mmu_book3s_32_xlate_bat(struct kvm_vcpu *vcpu, gva_t eaddr,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int kvmppc_mmu_book3s_32_xlate_pte(struct kvm_vcpu *vcpu, gva_t eaddr,
@@ -284,7 +284,7 @@ static int kvmppc_mmu_book3s_32_xlate_pte(struct kvm_vcpu *vcpu, gva_t eaddr,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int kvmppc_mmu_book3s_32_xlate(struct kvm_vcpu *vcpu, gva_t eaddr,
diff --git a/arch/powerpc/kvm/book3s_64_mmu.c b/arch/powerpc/kvm/book3s_64_mmu.c
index 26b8b27a3..278ee03a2 100644
--- a/arch/powerpc/kvm/book3s_64_mmu.c
+++ b/arch/powerpc/kvm/book3s_64_mmu.c
@@ -354,7 +354,7 @@ static int kvmppc_mmu_book3s_64_xlate(struct kvm_vcpu *vcpu, gva_t eaddr,
 
 no_page_found:
 	mutex_unlock(&vcpu->kvm->arch.hpt_mutex);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 
 no_seg_found:
 	dprintk("KVM MMU: Trigger segment fault\n");
@@ -420,7 +420,7 @@ static int kvmppc_mmu_book3s_64_slbfee(struct kvm_vcpu *vcpu, gva_t eaddr,
 		return 0;
 	}
 	*ret_slb = 0;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static u64 kvmppc_mmu_book3s_64_slbmfee(struct kvm_vcpu *vcpu, u64 slb_nr)
diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c
index 7c5a1812a..582d5060d 100644
--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c
+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c
@@ -356,7 +356,7 @@ static int kvmppc_mmu_book3s_64_hv_xlate(struct kvm_vcpu *vcpu, gva_t eaddr,
 					 HPTE_V_VALID | HPTE_V_ABSENT);
 	if (index < 0) {
 		preempt_enable();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	hptep = (__be64 *)(kvm->arch.hpt.virt + (index << 4));
 	v = orig_v = be64_to_cpu(hptep[0]) & ~HPTE_V_HVLOCK;
diff --git a/arch/powerpc/kvm/book3s_64_mmu_radix.c b/arch/powerpc/kvm/book3s_64_mmu_radix.c
index 6a7371475..b1f47083e 100644
--- a/arch/powerpc/kvm/book3s_64_mmu_radix.c
+++ b/arch/powerpc/kvm/book3s_64_mmu_radix.c
@@ -169,7 +169,7 @@ int kvmppc_mmu_walk_radix_tree(struct kvm_vcpu *vcpu, gva_t eaddr,
 		}
 		pte = __be64_to_cpu(rpte);
 		if (!(pte & _PAGE_PRESENT))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		/* Check if a leaf entry */
 		if (pte & _PAGE_PTE)
 			break;
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index 6bf66649a..442e76eda 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -5061,7 +5061,7 @@ static int kvmppc_set_passthru_irq(struct kvm *kvm, int host_irq, int guest_gsi)
 		pr_warn("kvmppc_set_passthru_irq_hv: Could not assign IRQ map for (%d,%d)\n",
 			host_irq, guest_gsi);
 		mutex_unlock(&kvm->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/arch/powerpc/kvm/book3s_rtas.c b/arch/powerpc/kvm/book3s_rtas.c
index 26b25994c..29af62922 100644
--- a/arch/powerpc/kvm/book3s_rtas.c
+++ b/arch/powerpc/kvm/book3s_rtas.c
@@ -181,7 +181,7 @@ static int rtas_token_define(struct kvm *kvm, char *name, u64 token)
 	}
 
 	if (!found)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	d = kzalloc(sizeof(*d), GFP_KERNEL);
 	if (!d)
diff --git a/arch/powerpc/kvm/book3s_xics.c b/arch/powerpc/kvm/book3s_xics.c
index 381bf8dea..3df717c61 100644
--- a/arch/powerpc/kvm/book3s_xics.c
+++ b/arch/powerpc/kvm/book3s_xics.c
@@ -1119,7 +1119,7 @@ int kvmppc_xics_set_icp(struct kvm_vcpu *vcpu, u64 icpval)
 	bool resend;
 
 	if (!icp || !xics)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cppr = icpval >> KVM_REG_PPC_ICP_CPPR_SHIFT;
 	xisr = (icpval >> KVM_REG_PPC_ICP_XISR_SHIFT) &
@@ -1194,7 +1194,7 @@ static int xics_get_source(struct kvmppc_xics *xics, long irq, u64 addr)
 
 	ics = kvmppc_xics_find_ics(xics, irq, &idx);
 	if (!ics)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	irqp = &ics->irq_state[idx];
 	local_irq_save(flags);
@@ -1244,7 +1244,7 @@ static int xics_set_source(struct kvmppc_xics *xics, long irq, u64 addr)
 	unsigned long flags;
 
 	if (irq < KVMPPC_XICS_FIRST_IRQ || irq >= KVMPPC_XICS_NR_IRQS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ics = kvmppc_xics_find_ics(xics, irq, &idx);
 	if (!ics) {
diff --git a/arch/powerpc/kvm/book3s_xive.c b/arch/powerpc/kvm/book3s_xive.c
index 85215e79d..f0e12ba58 100644
--- a/arch/powerpc/kvm/book3s_xive.c
+++ b/arch/powerpc/kvm/book3s_xive.c
@@ -842,7 +842,7 @@ int kvmppc_xive_set_icp(struct kvm_vcpu *vcpu, u64 icpval)
 	u32 xisr;
 
 	if (!xc || !xive)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Grab individual state fields. We don't use pending_pri */
 	cppr = icpval >> KVM_REG_PPC_ICP_CPPR_SHIFT;
@@ -1533,12 +1533,12 @@ static int xive_get_source(struct kvmppc_xive *xive, long irq, u64 addr)
 
 	sb = kvmppc_xive_find_source(xive, irq, &idx);
 	if (!sb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	state = &sb->irq_state[idx];
 
 	if (!state->valid)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pr_devel("get_source(%ld)...\n", irq);
 
@@ -1678,7 +1678,7 @@ static int xive_set_source(struct kvmppc_xive *xive, long irq, u64 addr)
 	int rc = 0;
 
 	if (irq < KVMPPC_XICS_FIRST_IRQ || irq >= KVMPPC_XICS_NR_IRQS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pr_devel("set_source(irq=0x%lx)\n", irq);
 
diff --git a/arch/powerpc/kvm/book3s_xive_native.c b/arch/powerpc/kvm/book3s_xive_native.c
index bdea91df1..17b37f86e 100644
--- a/arch/powerpc/kvm/book3s_xive_native.c
+++ b/arch/powerpc/kvm/book3s_xive_native.c
@@ -466,7 +466,7 @@ static int kvmppc_xive_native_set_source_config(struct kvmppc_xive *xive,
 
 	sb = kvmppc_xive_find_source(xive, irq, &src);
 	if (!sb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	state = &sb->irq_state[src];
 
@@ -511,7 +511,7 @@ static int kvmppc_xive_native_sync_source(struct kvmppc_xive *xive,
 
 	sb = kvmppc_xive_find_source(xive, irq, &src);
 	if (!sb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	state = &sb->irq_state[src];
 
@@ -579,7 +579,7 @@ static int kvmppc_xive_native_set_queue_config(struct kvmppc_xive *xive,
 	vcpu = kvmppc_xive_find_server(kvm, server);
 	if (!vcpu) {
 		pr_err("Can't find server %d\n", server);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	xc = vcpu->arch.xive_vcpu;
 
@@ -724,7 +724,7 @@ static int kvmppc_xive_native_get_queue_config(struct kvmppc_xive *xive,
 	vcpu = kvmppc_xive_find_server(kvm, server);
 	if (!vcpu) {
 		pr_err("Can't find server %d\n", server);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	xc = vcpu->arch.xive_vcpu;
 
@@ -886,7 +886,7 @@ static int kvmppc_xive_native_vcpu_eq_sync(struct kvm_vcpu *vcpu)
 	int srcu_idx;
 
 	if (!xc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (prio = 0; prio < KVMPPC_XIVE_Q_COUNT; prio++) {
 		struct xive_q *q = &xc->queues[prio];
@@ -1129,7 +1129,7 @@ int kvmppc_xive_native_get_vp(struct kvm_vcpu *vcpu, union kvmppc_one_reg *val)
 		return -EPERM;
 
 	if (!xc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Thread context registers. We only care about IPB and CPPR */
 	val->xive_timaval[0] = vcpu->arch.xive_saved_state.w01;
@@ -1169,7 +1169,7 @@ int kvmppc_xive_native_set_vp(struct kvm_vcpu *vcpu, union kvmppc_one_reg *val)
 		return -EPERM;
 
 	if (!xc || !xive)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* We can't update the state of a "pushed" VCPU	 */
 	if (WARN_ON(vcpu->arch.xive_pushed))
diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c
index c0d62a917..2d4d0801e 100644
--- a/arch/powerpc/kvm/booke.c
+++ b/arch/powerpc/kvm/booke.c
@@ -1965,7 +1965,7 @@ int kvmppc_xlate(struct kvm_vcpu *vcpu, ulong eaddr, enum xlate_instdata xlid,
 
 	/* Do we have a TLB entry at all? */
 	if (gtlb_index < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	gpaddr = kvmppc_mmu_xlate(vcpu, gtlb_index, eaddr);
 
diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.c
index dd7d141e3..a0ab45250 100644
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@ -450,7 +450,7 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 		goto err_out;
 
 	if (kvm_ops->owner && !try_module_get(kvm_ops->owner))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kvm->arch.kvm_ops = kvm_ops;
 	return kvmppc_core_init_vm(kvm);
diff --git a/arch/powerpc/mm/book3s64/hash_native.c b/arch/powerpc/mm/book3s64/hash_native.c
index cf20e5229..b411804a8 100644
--- a/arch/powerpc/mm/book3s64/hash_native.c
+++ b/arch/powerpc/mm/book3s64/hash_native.c
@@ -579,7 +579,7 @@ static int native_hpte_removebolted(unsigned long ea, int psize, int ssize)
 
 	slot = native_hpte_find(vpn, psize, ssize);
 	if (slot == -1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hptep = htab_address + slot;
 
diff --git a/arch/powerpc/mm/book3s64/subpage_prot.c b/arch/powerpc/mm/book3s64/subpage_prot.c
index 60c6ea16a..988254cc1 100644
--- a/arch/powerpc/mm/book3s64/subpage_prot.c
+++ b/arch/powerpc/mm/book3s64/subpage_prot.c
@@ -199,7 +199,7 @@ SYSCALL_DEFINE3(subpage_prot, unsigned long, addr,
 	int err;
 
 	if (radix_enabled())
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Check parameters */
 	if ((addr & ~PAGE_MASK) || (len & ~PAGE_MASK) ||
diff --git a/arch/powerpc/perf/8xx-pmu.c b/arch/powerpc/perf/8xx-pmu.c
index e53c3c161..e04c85092 100644
--- a/arch/powerpc/perf/8xx-pmu.c
+++ b/arch/powerpc/perf/8xx-pmu.c
@@ -64,7 +64,7 @@ static int event_type(struct perf_event *event)
 	case PERF_TYPE_RAW:
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return -EOPNOTSUPP;
 }
diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c
index cd6a742ac..4502bf491 100644
--- a/arch/powerpc/perf/core-book3s.c
+++ b/arch/powerpc/perf/core-book3s.c
@@ -1844,7 +1844,7 @@ static int power_pmu_event_init(struct perf_event *event)
 	u64 bhrb_filter;
 
 	if (!ppmu)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (has_branch_stack(event)) {
 	        /* PMU has BHRB enabled */
@@ -1877,7 +1877,7 @@ static int power_pmu_event_init(struct perf_event *event)
 			return -EINVAL;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	event->hw.config_base = ev;
diff --git a/arch/powerpc/perf/core-fsl-emb.c b/arch/powerpc/perf/core-fsl-emb.c
index e0e7e276b..ffa922045 100644
--- a/arch/powerpc/perf/core-fsl-emb.c
+++ b/arch/powerpc/perf/core-fsl-emb.c
@@ -513,7 +513,7 @@ static int fsl_emb_pmu_event_init(struct perf_event *event)
 		break;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	event->hw.config = ppmu->xlate_event(ev);
diff --git a/arch/powerpc/perf/hv-24x7.c b/arch/powerpc/perf/hv-24x7.c
index db213eb7c..3db827e11 100644
--- a/arch/powerpc/perf/hv-24x7.c
+++ b/arch/powerpc/perf/hv-24x7.c
@@ -1370,7 +1370,7 @@ static int h_24x7_event_init(struct perf_event *event)
 
 	/* Not our event */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Unused areas must be 0 */
 	if (event_get_reserved1(event) ||
diff --git a/arch/powerpc/perf/hv-gpci.c b/arch/powerpc/perf/hv-gpci.c
index 6884d16ec..f1b8912be 100644
--- a/arch/powerpc/perf/hv-gpci.c
+++ b/arch/powerpc/perf/hv-gpci.c
@@ -220,7 +220,7 @@ static int h_gpci_event_init(struct perf_event *event)
 
 	/* Not our event */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* config2 is unused */
 	if (event->attr.config2) {
diff --git a/arch/powerpc/perf/imc-pmu.c b/arch/powerpc/perf/imc-pmu.c
index 0edcfd0b4..c49b2a1e7 100644
--- a/arch/powerpc/perf/imc-pmu.c
+++ b/arch/powerpc/perf/imc-pmu.c
@@ -504,7 +504,7 @@ static int nest_imc_event_init(struct perf_event *event)
 	bool flag = false;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Sampling not supported */
 	if (event->hw.sample_period)
@@ -809,7 +809,7 @@ static int core_imc_event_init(struct perf_event *event)
 	struct imc_pmu_ref *ref;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Sampling not supported */
 	if (event->hw.sample_period)
@@ -974,7 +974,7 @@ static int thread_imc_event_init(struct perf_event *event)
 	struct imc_pmu *pmu;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!perfmon_capable())
 		return -EACCES;
@@ -1410,14 +1410,14 @@ static int trace_imc_event_init(struct perf_event *event)
 	struct task_struct *target;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!perfmon_capable())
 		return -EACCES;
 
 	/* Return if this is a couting event */
 	if (event->attr.sample_period == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Take the global lock, and make sure
diff --git a/arch/powerpc/platforms/44x/iss4xx.c b/arch/powerpc/platforms/44x/iss4xx.c
index c5f825914..20f2ad178 100644
--- a/arch/powerpc/platforms/44x/iss4xx.c
+++ b/arch/powerpc/platforms/44x/iss4xx.c
@@ -99,7 +99,7 @@ static int smp_iss4xx_kick_cpu(int cpu)
 					       NULL);
 	if (spin_table_addr_prop == NULL) {
 		pr_err("CPU%d: Can't start, missing cpu-release-addr !\n", cpu);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Assume it's mapped as part of the linear mapping. This is a bit
diff --git a/arch/powerpc/platforms/44x/warp.c b/arch/powerpc/platforms/44x/warp.c
index 665f18e37..3587bff0f 100644
--- a/arch/powerpc/platforms/44x/warp.c
+++ b/arch/powerpc/platforms/44x/warp.c
@@ -66,12 +66,12 @@ static int __init warp_post_info(void)
 	/* Sighhhh... POST information is in the sd area. */
 	np = of_find_compatible_node(NULL, NULL, "pika,fpga-sd");
 	if (np == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	fpga = of_iomap(np, 0);
 	of_node_put(np);
 	if (fpga == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	post1 = in_be32(fpga + 0x40);
 	post2 = in_be32(fpga + 0x44);
@@ -168,7 +168,7 @@ static int pika_setup_leds(void)
 	np = of_find_compatible_node(NULL, NULL, "gpio-leds");
 	if (!np) {
 		printk(KERN_ERR __FILE__ ": Unable to find leds\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for_each_child_of_node(np, child)
@@ -230,12 +230,12 @@ static int pika_dtm_thread(void __iomem *fpga)
 
 	np = of_find_compatible_node(NULL, NULL, "adi,ad7414");
 	if (np == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	client = of_find_i2c_device_by_node(np);
 	if (client == NULL) {
 		of_node_put(np);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pika_setup_critical_temp(np, client);
@@ -271,12 +271,12 @@ static int __init pika_dtm_start(void)
 
 	np = of_find_compatible_node(NULL, NULL, "pika,fpga");
 	if (np == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dtm_fpga = of_iomap(np, 0);
 	of_node_put(np);
 	if (dtm_fpga == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Must get post info before thread starts. */
 	warp_post_info();
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index fda108bae..1f90ac907 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -199,7 +199,7 @@ static int smp_85xx_start_cpu(int cpu)
 	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
 	if (!cpu_rel_addr) {
 		pr_err("No cpu-release-addr for cpu %d\n", cpu);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -287,7 +287,7 @@ static int smp_85xx_kick_cpu(int nr)
 #ifdef CONFIG_PPC64
 	if (threads_per_core == 2) {
 		if (WARN_ON_ONCE(!cpu_has_feature(CPU_FTR_SMT)))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		booting_thread_hwid = cpu_thread_in_core(nr);
 		primary = cpu_first_thread_sibling(nr);
diff --git a/arch/powerpc/platforms/86xx/mpc86xx_smp.c b/arch/powerpc/platforms/86xx/mpc86xx_smp.c
index 87f524e4b..f024478e9 100644
--- a/arch/powerpc/platforms/86xx/mpc86xx_smp.c
+++ b/arch/powerpc/platforms/86xx/mpc86xx_smp.c
@@ -62,7 +62,7 @@ smp_86xx_kick_cpu(int nr)
 	unsigned int *vector = (unsigned int *)(KERNELBASE + 0x100);
 
 	if (nr < 0 || nr >= NR_CPUS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pr_debug("smp_86xx_kick_cpu: kick CPU #%d\n", nr);
 
diff --git a/arch/powerpc/platforms/cell/axon_msi.c b/arch/powerpc/platforms/cell/axon_msi.c
index ca2555b8a..7bbcaffae 100644
--- a/arch/powerpc/platforms/cell/axon_msi.c
+++ b/arch/powerpc/platforms/cell/axon_msi.c
@@ -226,7 +226,7 @@ static int setup_msi_msg_address(struct pci_dev *dev, struct msi_msg *msg)
 	if (!prop) {
 		dev_dbg(&dev->dev,
 			"axon_msi: no msi-address-(32|64) properties found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	switch (len) {
diff --git a/arch/powerpc/platforms/cell/smp.c b/arch/powerpc/platforms/cell/smp.c
index c855a0aeb..6e1f750fe 100644
--- a/arch/powerpc/platforms/cell/smp.c
+++ b/arch/powerpc/platforms/cell/smp.c
@@ -115,7 +115,7 @@ static int smp_cell_kick_cpu(int nr)
 		return -EINVAL;
 
 	if (!smp_startup_cpu(nr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * The processor is currently spinning, waiting for the
diff --git a/arch/powerpc/platforms/powermac/smp.c b/arch/powerpc/platforms/powermac/smp.c
index eb2326491..88c3de889 100644
--- a/arch/powerpc/platforms/powermac/smp.c
+++ b/arch/powerpc/platforms/powermac/smp.c
@@ -800,7 +800,7 @@ static int smp_core99_kick_cpu(int nr)
 	unsigned int *vector = (unsigned int *)(PAGE_OFFSET+0x100);
 
 	if (nr < 0 || nr > 3)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ppc_md.progress)
 		ppc_md.progress("smp_core99_kick_cpu", 0x346);
diff --git a/arch/powerpc/platforms/powernv/ocxl.c b/arch/powerpc/platforms/powernv/ocxl.c
index 8c65aacda..d290ba07f 100644
--- a/arch/powerpc/platforms/powernv/ocxl.c
+++ b/arch/powerpc/platforms/powernv/ocxl.c
@@ -493,13 +493,13 @@ int pnv_ocxl_alloc_xive_irq(u32 *irq, u64 *trigger_addr)
 
 	hwirq = xive_native_alloc_irq();
 	if (!hwirq)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = opal_xive_get_irq_info(hwirq, &flags, NULL, &trigger_page, NULL,
 				NULL);
 	if (rc || !trigger_page) {
 		xive_native_free_irq(hwirq);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	*irq = hwirq;
 	*trigger_addr = be64_to_cpu(trigger_page);
diff --git a/arch/powerpc/platforms/powernv/ultravisor.c b/arch/powerpc/platforms/powernv/ultravisor.c
index e4a00ad06..d4fd024da 100644
--- a/arch/powerpc/platforms/powernv/ultravisor.c
+++ b/arch/powerpc/platforms/powernv/ultravisor.c
@@ -56,7 +56,7 @@ static int __init uv_init(void)
 
 	uv_memcons = memcons_init(node, "memcons");
 	if (!uv_memcons)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	uv_msglog_attr.size = memcons_get_size(uv_memcons);
 
diff --git a/arch/powerpc/platforms/powernv/vas.c b/arch/powerpc/platforms/powernv/vas.c
index 598e4cd56..904f954a7 100644
--- a/arch/powerpc/platforms/powernv/vas.c
+++ b/arch/powerpc/platforms/powernv/vas.c
@@ -107,7 +107,7 @@ static int init_vas_instance(struct platform_device *pdev)
 	if (!hwirq) {
 		pr_err("Inst%d: Unable to allocate global irq for chip %d\n",
 				vinst->vas_id, chipid);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	vinst->virq = irq_create_mapping(NULL, hwirq);
diff --git a/arch/powerpc/platforms/ps3/repository.c b/arch/powerpc/platforms/ps3/repository.c
index 21712964e..d571770a4 100644
--- a/arch/powerpc/platforms/ps3/repository.c
+++ b/arch/powerpc/platforms/ps3/repository.c
@@ -126,7 +126,7 @@ static int read_node(unsigned int lpar_id, u64 n1, u64 n2, u64 n3, u64 n4,
 		pr_warn("%s:%d: lv1_read_repository_node failed: %s\n",
 			__func__, __LINE__, ps3_result(result));
 		dump_node_name(lpar_id, n1, n2, n3, n4);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	dump_node(lpar_id, n1, n2, n3, n4, v1, v2);
@@ -1057,7 +1057,7 @@ static int create_node(u64 n1, u64 n2, u64 n3, u64 n4, u64 v1, u64 v2)
 	if (result) {
 		pr_devel("%s:%d: lv1_create_repository_node failed: %s\n",
 			__func__, __LINE__, ps3_result(result));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -1074,7 +1074,7 @@ static int delete_node(u64 n1, u64 n2, u64 n3, u64 n4)
 	if (result) {
 		pr_devel("%s:%d: lv1_delete_repository_node failed: %s\n",
 			__func__, __LINE__, ps3_result(result));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -1094,7 +1094,7 @@ static int write_node(u64 n1, u64 n2, u64 n3, u64 n4, u64 v1, u64 v2)
 	if (result) {
 		pr_devel("%s:%d: lv1_write_repository_node failed: %s\n",
 			__func__, __LINE__, ps3_result(result));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c
index fd26f3d21..a21769552 100644
--- a/arch/powerpc/platforms/pseries/lpar.c
+++ b/arch/powerpc/platforms/pseries/lpar.c
@@ -1266,7 +1266,7 @@ static int pSeries_lpar_hpte_removebolted(unsigned long ea,
 
 	slot = pSeries_lpar_hpte_find(vpn, psize, ssize);
 	if (slot == -1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * lpar doesn't use the passed actual page size
diff --git a/arch/powerpc/platforms/pseries/mobility.c b/arch/powerpc/platforms/pseries/mobility.c
index 10d982997..1031f5c86 100644
--- a/arch/powerpc/platforms/pseries/mobility.c
+++ b/arch/powerpc/platforms/pseries/mobility.c
@@ -62,7 +62,7 @@ static int delete_dt_node(__be32 phandle)
 
 	dn = of_find_node_by_phandle(be32_to_cpu(phandle));
 	if (!dn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dlpar_detach_node(dn);
 	of_node_put(dn);
@@ -152,7 +152,7 @@ static int update_dt_node(__be32 phandle, s32 scope)
 	dn = of_find_node_by_phandle(be32_to_cpu(phandle));
 	if (!dn) {
 		kfree(rtas_buf);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	upwa = (struct update_props_workarea *)&rtas_buf[0];
@@ -228,12 +228,12 @@ static int add_dt_node(__be32 parent_phandle, __be32 drc_index)
 
 	parent_dn = of_find_node_by_phandle(be32_to_cpu(parent_phandle));
 	if (!parent_dn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dn = dlpar_configure_connector(drc_index, parent_dn);
 	if (!dn) {
 		of_node_put(parent_dn);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rc = dlpar_attach_node(dn, parent_dn);
diff --git a/arch/powerpc/platforms/pseries/msi.c b/arch/powerpc/platforms/pseries/msi.c
index 133f6adcb..e588c6311 100644
--- a/arch/powerpc/platforms/pseries/msi.c
+++ b/arch/powerpc/platforms/pseries/msi.c
@@ -135,7 +135,7 @@ static int check_req(struct pci_dev *pdev, int nvec, char *prop_name)
 	p = of_get_property(dn, prop_name, NULL);
 	if (!p) {
 		pr_debug("rtas_msi: No %s on %pOF\n", prop_name, dn);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	req_msi = be32_to_cpup(p);
diff --git a/arch/powerpc/platforms/pseries/rtas-fadump.c b/arch/powerpc/platforms/pseries/rtas-fadump.c
index 81343908e..1843c0ce1 100644
--- a/arch/powerpc/platforms/pseries/rtas-fadump.c
+++ b/arch/powerpc/platforms/pseries/rtas-fadump.c
@@ -319,7 +319,7 @@ static int __init rtas_fadump_build_cpu_notes(struct fw_dump *fadump_conf)
 	if (be64_to_cpu(reg_header->magic_number) !=
 	    fadump_str_to_u64("REGSAVE")) {
 		pr_err("Unable to read register save area.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pr_debug("--------CPU State Data------------\n");
diff --git a/arch/powerpc/platforms/pseries/smp.c b/arch/powerpc/platforms/pseries/smp.c
index 689171083..f2710c441 100644
--- a/arch/powerpc/platforms/pseries/smp.c
+++ b/arch/powerpc/platforms/pseries/smp.c
@@ -155,7 +155,7 @@ static int smp_pSeries_kick_cpu(int nr)
 		return -EINVAL;
 
 	if (!smp_startup_cpu(nr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * The processor is currently spinning, waiting for the
diff --git a/arch/powerpc/sysdev/fsl_lbc.c b/arch/powerpc/sysdev/fsl_lbc.c
index 1985e067e..33692480c 100644
--- a/arch/powerpc/sysdev/fsl_lbc.c
+++ b/arch/powerpc/sysdev/fsl_lbc.c
@@ -78,7 +78,7 @@ int fsl_lbc_find(phys_addr_t addr_base)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(fsl_lbc_find);
 
diff --git a/arch/riscv/kernel/module.c b/arch/riscv/kernel/module.c
index 7191342c5..fd759c512 100644
--- a/arch/riscv/kernel/module.c
+++ b/arch/riscv/kernel/module.c
@@ -321,7 +321,7 @@ int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 				continue;
 			pr_warn("%s: Unknown symbol %s\n",
 				me->name, strtab + sym->st_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		type = ELF_RISCV_R_TYPE(rel[i].r_info);
diff --git a/arch/riscv/kernel/perf_event.c b/arch/riscv/kernel/perf_event.c
index c835f0362..7ff1d5ba3 100644
--- a/arch/riscv/kernel/perf_event.c
+++ b/arch/riscv/kernel/perf_event.c
@@ -150,7 +150,7 @@ static int riscv_map_hw_event(u64 config)
 static int riscv_map_cache_decode(u64 config, unsigned int *type,
 			   unsigned int *op, unsigned int *result)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int riscv_map_cache_event(u64 config)
@@ -408,7 +408,7 @@ static int riscv_event_init(struct perf_event *event)
 	case PERF_TYPE_RAW:
 		return -EOPNOTSUPP;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	event->destroy = riscv_event_destroy;
diff --git a/arch/s390/kernel/perf_cpum_cf.c b/arch/s390/kernel/perf_cpum_cf.c
index 0eb1d1cc5..ca2e06569 100644
--- a/arch/s390/kernel/perf_cpum_cf.c
+++ b/arch/s390/kernel/perf_cpum_cf.c
@@ -219,7 +219,7 @@ static int __hw_perf_event_init(struct perf_event *event, unsigned int type)
 
 	case PERF_TYPE_HARDWARE:
 		if (is_sampling_event(event))	/* No sampling support */
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		ev = attr->config;
 		/* Count user space (problem-state) only */
 		if (!attr->exclude_user && attr->exclude_kernel) {
@@ -240,14 +240,14 @@ static int __hw_perf_event_init(struct perf_event *event, unsigned int type)
 		break;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (ev == -1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ev > PERF_CPUM_CF_MAX_CTR)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Obtain the counter set to which the specified counter belongs */
 	set = get_counter_set(ev);
@@ -303,7 +303,7 @@ static int cpumf_pmu_event_init(struct perf_event *event)
 		/* Registered as unknown PMU */
 		err = __hw_perf_event_init(event, PERF_TYPE_RAW);
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (unlikely(err) && event->destroy)
 		event->destroy(event);
@@ -422,7 +422,7 @@ static int cpumf_pmu_add(struct perf_event *event, int flags)
 	 */
 	if (!(cpuhw->txn_flags & PERF_PMU_TXN_ADD))
 		if (validate_ctr_auth(&event->hw))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 	ctr_set_enable(&cpuhw->state, event->hw.config_base);
 	event->hw.state = PERF_HES_UPTODATE | PERF_HES_STOPPED;
@@ -520,7 +520,7 @@ static int cpumf_pmu_commit_txn(struct pmu *pmu)
 	state = cpuhw->state & ~((1 << CPUMF_LCCTL_ENABLE_SHIFT) - 1);
 	state >>= CPUMF_LCCTL_ENABLE_SHIFT;
 	if ((state & cpuhw->info.auth_ctl) != state)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cpuhw->txn_flags = 0;
 	perf_pmu_enable(pmu);
diff --git a/arch/s390/kernel/perf_cpum_sf.c b/arch/s390/kernel/perf_cpum_sf.c
index 4f9e4626d..44ac94202 100644
--- a/arch/s390/kernel/perf_cpum_sf.c
+++ b/arch/s390/kernel/perf_cpum_sf.c
@@ -902,7 +902,7 @@ static int cpumsf_pmu_event_init(struct perf_event *event)
 	case PERF_TYPE_RAW:
 		if ((event->attr.config != PERF_EVENT_CPUM_SF) &&
 		    (event->attr.config != PERF_EVENT_CPUM_SF_DIAG))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		break;
 	case PERF_TYPE_HARDWARE:
 		/* Support sampling of CPU cycles in addition to the
@@ -911,12 +911,12 @@ static int cpumsf_pmu_event_init(struct perf_event *event)
 		 * sampling events only.
 		 */
 		if (event->attr.config != PERF_COUNT_HW_CPU_CYCLES)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (!is_sampling_event(event))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Check online status of the CPU to which the event is pinned */
diff --git a/arch/s390/mm/extmem.c b/arch/s390/mm/extmem.c
index 9e0aa7aa0..62fcc6dd0 100644
--- a/arch/s390/mm/extmem.c
+++ b/arch/s390/mm/extmem.c
@@ -153,7 +153,7 @@ dcss_diag(int *func, void *parameter,
 static inline int
 dcss_diag_translate_rc (int vm_rc) {
 	if (vm_rc == 44)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return -EIO;
 }
 
diff --git a/arch/s390/net/pnet.c b/arch/s390/net/pnet.c
index 79211bec0..92491419f 100644
--- a/arch/s390/net/pnet.c
+++ b/arch/s390/net/pnet.c
@@ -75,7 +75,7 @@ int pnet_id_by_dev_port(struct device *dev, unsigned short port, u8 *pnetid)
 	int rc = 0;
 
 	if (!dev || port >= MAX_PNETID_PORTS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!pnet_ids_by_device(dev, (u8 *)pnetids) &&
 	    memcmp(pnetids[port], zero, MAX_PNETID_LEN))
diff --git a/arch/sh/drivers/dma/dmabrg.c b/arch/sh/drivers/dma/dmabrg.c
index 5b2c1fd25..6886b1134 100644
--- a/arch/sh/drivers/dma/dmabrg.c
+++ b/arch/sh/drivers/dma/dmabrg.c
@@ -126,7 +126,7 @@ int dmabrg_request_irq(unsigned int dmairq, void(*handler)(void*),
 		       void *data)
 {
 	if ((dmairq > 9) || !handler)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (dmabrg_handlers[dmairq].handler)
 		return -EBUSY;
 
diff --git a/arch/sh/kernel/perf_event.c b/arch/sh/kernel/perf_event.c
index 445e3ece4..2cf76d14f 100644
--- a/arch/sh/kernel/perf_event.c
+++ b/arch/sh/kernel/perf_event.c
@@ -311,7 +311,7 @@ static int sh_pmu_event_init(struct perf_event *event)
 		break;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (unlikely(err)) {
diff --git a/arch/sh/kernel/smp.c b/arch/sh/kernel/smp.c
index 372acdc90..7e01059a1 100644
--- a/arch/sh/kernel/smp.c
+++ b/arch/sh/kernel/smp.c
@@ -241,7 +241,7 @@ int __cpu_up(unsigned int cpu, struct task_struct *tsk)
 	if (cpu_online(cpu))
 		return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void __init smp_cpus_done(unsigned int max_cpus)
diff --git a/arch/sparc/kernel/pci_msi.c b/arch/sparc/kernel/pci_msi.c
index fb5899cbf..1df9e7564 100644
--- a/arch/sparc/kernel/pci_msi.c
+++ b/arch/sparc/kernel/pci_msi.c
@@ -101,7 +101,7 @@ static int alloc_msi(struct pci_pbm_info *pbm)
 			return i + pbm->msi_first;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void free_msi(struct pci_pbm_info *pbm, int msi_num)
diff --git a/arch/sparc/kernel/perf_event.c b/arch/sparc/kernel/perf_event.c
index a58ae9c42..15810dc15 100644
--- a/arch/sparc/kernel/perf_event.c
+++ b/arch/sparc/kernel/perf_event.c
@@ -1447,7 +1447,7 @@ static int sparc_pmu_event_init(struct perf_event *event)
 		break;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	}
 
diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c
index 02e6e5e0f..b86ffc49c 100644
--- a/arch/sparc/mm/init_64.c
+++ b/arch/sparc/mm/init_64.c
@@ -1232,7 +1232,7 @@ static int __init grab_mlgroups(struct mdesc_handle *md)
 	mdesc_for_each_node_by_name(md, node, "memory-latency-group")
 		count++;
 	if (!count)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	paddr = memblock_phys_alloc(count * sizeof(struct mdesc_mlgroup),
 				    SMP_CACHE_BYTES);
@@ -1273,7 +1273,7 @@ static int __init grab_mblocks(struct mdesc_handle *md)
 	mdesc_for_each_node_by_name(md, node, "mblock")
 		count++;
 	if (!count)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	paddr = memblock_phys_alloc(count * sizeof(struct mdesc_mblock),
 				    SMP_CACHE_BYTES);
@@ -1403,7 +1403,7 @@ static int __init numa_attach_mlgroup(struct mdesc_handle *md, u64 grp,
 		}
 	}
 	if (!candidate)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (num_node_masks != index) {
 		printk(KERN_ERR "Inconsistent NUMA state, "
@@ -1454,7 +1454,7 @@ static int __init numa_parse_mdesc(void)
 	node = mdesc_node_by_name(md, MDESC_NODE_NULL, "latency-groups");
 	if (node == MDESC_NODE_NULL) {
 		mdesc_release(md);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = grab_mblocks(md);
diff --git a/arch/um/drivers/pty.c b/arch/um/drivers/pty.c
index 39c60068c..138990296 100644
--- a/arch/um/drivers/pty.c
+++ b/arch/um/drivers/pty.c
@@ -107,7 +107,7 @@ static int getmaster(char *line)
 	}
 
 	printk(UM_KERN_ERR "getmaster - no usable host pty devices\n");
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int pty_open(int input, int output, int primary, void *d,
diff --git a/arch/um/os-Linux/execvp.c b/arch/um/os-Linux/execvp.c
index 84a0777c2..160c5f264 100644
--- a/arch/um/os-Linux/execvp.c
+++ b/arch/um/os-Linux/execvp.c
@@ -39,7 +39,7 @@
 int execvp_noalloc(char *buf, const char *file, char *const argv[])
 {
 	if (*file == '\0') {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (strchr (file, '/') != NULL) {
diff --git a/arch/x86/events/amd/core.c b/arch/x86/events/amd/core.c
index 39eb276d0..909f4ee90 100644
--- a/arch/x86/events/amd/core.c
+++ b/arch/x86/events/amd/core.c
@@ -8,7 +8,7 @@
 #include <linux/jiffies.h>
 #include <asm/apicdef.h>
 #include <asm/nmi.h>
-
+#include <linux/errno.h>
 #include "../perf_event.h"
 
 static DEFINE_PER_CPU(unsigned long, perf_nmi_tstamp);
@@ -364,7 +364,7 @@ static int amd_pmu_hw_config(struct perf_event *event)
 
 	/* pass precise event sampling to ibs: */
 	if (event->attr.precise_ip && get_ibs_caps())
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (has_branch_stack(event))
 		return -EOPNOTSUPP;
diff --git a/arch/x86/events/amd/ibs.c b/arch/x86/events/amd/ibs.c
index 26c36357c..976b42b42 100644
--- a/arch/x86/events/amd/ibs.c
+++ b/arch/x86/events/amd/ibs.c
@@ -220,7 +220,7 @@ static int perf_ibs_precise_event(struct perf_event *event, u64 *config)
 {
 	switch (event->attr.precise_ip) {
 	case 0:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case 1:
 	case 2:
 		break;
@@ -247,7 +247,7 @@ static int perf_ibs_precise_event(struct perf_event *event, u64 *config)
 		}
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return -EOPNOTSUPP;
@@ -271,7 +271,7 @@ static int perf_ibs_init(struct perf_event *event)
 	}
 
 	if (event->pmu != &perf_ibs->pmu)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (config & ~perf_ibs->config_mask)
 		return -EINVAL;
diff --git a/arch/x86/events/amd/iommu.c b/arch/x86/events/amd/iommu.c
index fb616203c..56db6f204 100644
--- a/arch/x86/events/amd/iommu.c
+++ b/arch/x86/events/amd/iommu.c
@@ -210,7 +210,7 @@ static int perf_iommu_event_init(struct perf_event *event)
 
 	/* test the event attr type check for PMU enumeration */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * IOMMU counters are shared across all cores.
diff --git a/arch/x86/events/amd/power.c b/arch/x86/events/amd/power.c
index 43b09e9c9..cb5a30f1d 100644
--- a/arch/x86/events/amd/power.c
+++ b/arch/x86/events/amd/power.c
@@ -130,7 +130,7 @@ static int pmu_event_init(struct perf_event *event)
 
 	/* Only look at AMD power events. */
 	if (event->attr.type != pmu_class.type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Unsupported modes and filters. */
 	if (event->attr.sample_period)
diff --git a/arch/x86/events/amd/uncore.c b/arch/x86/events/amd/uncore.c
index 76400c052..8b65d564c 100644
--- a/arch/x86/events/amd/uncore.c
+++ b/arch/x86/events/amd/uncore.c
@@ -4,7 +4,7 @@
  *
  * Author: Jacob Shin <jacob.shin@amd.com>
  */
-
+#include <linux/errno.h>
 #include <linux/perf_event.h>
 #include <linux/percpu.h>
 #include <linux/types.h>
@@ -211,7 +211,7 @@ static int amd_uncore_event_init(struct perf_event *event)
 	struct hw_perf_event *hwc = &event->hw;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * NB and Last level cache counters (MSRs) are shared across all cores
diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c
index 4103665c6..4e794b462 100644
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@ -11,7 +11,7 @@
  *
  *  For licencing details see kernel-base/COPYING
  */
-
+#include <linux/errno.h>
 #include <linux/perf_event.h>
 #include <linux/capability.h>
 #include <linux/notifier.h>
@@ -324,7 +324,7 @@ set_ext_hw_attr(struct hw_perf_event *hwc, struct perf_event *event)
 	val = hw_cache_event_ids[cache_type][cache_op][cache_result];
 
 	if (val == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (val == -1)
 		return -EINVAL;
@@ -439,7 +439,7 @@ int x86_setup_perfctr(struct perf_event *event)
 	config = x86_pmu.event_map(attr->config);
 
 	if (config == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (config == -1LL)
 		return -EINVAL;
@@ -2134,7 +2134,7 @@ static int x86_pmu_event_init(struct perf_event *event)
 		break;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = __x86_pmu_event_init(event);
diff --git a/arch/x86/events/intel/bts.c b/arch/x86/events/intel/bts.c
index 731dd8d0d..da308bf47 100644
--- a/arch/x86/events/intel/bts.c
+++ b/arch/x86/events/intel/bts.c
@@ -544,7 +544,7 @@ static int bts_event_init(struct perf_event *event)
 	int ret;
 
 	if (event->attr.type != bts_pmu.type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * BTS leaks kernel addresses even when CPL0 tracing is
diff --git a/arch/x86/events/intel/cstate.c b/arch/x86/events/intel/cstate.c
index 442e1ed4a..6d430b173 100644
--- a/arch/x86/events/intel/cstate.c
+++ b/arch/x86/events/intel/cstate.c
@@ -307,7 +307,7 @@ static int cstate_pmu_event_init(struct perf_event *event)
 	int cpu;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* unsupported modes and filters */
 	if (event->attr.sample_period) /* no sampling */
@@ -335,7 +335,7 @@ static int cstate_pmu_event_init(struct perf_event *event)
 		cpu = cpumask_any_and(&cstate_pkg_cpu_mask,
 				      topology_die_cpumask(event->cpu));
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (cpu >= nr_cpu_ids)
diff --git a/arch/x86/events/intel/pt.c b/arch/x86/events/intel/pt.c
index e94af4a54..4a6f921a9 100644
--- a/arch/x86/events/intel/pt.c
+++ b/arch/x86/events/intel/pt.c
@@ -1668,7 +1668,7 @@ static void pt_event_destroy(struct perf_event *event)
 static int pt_event_init(struct perf_event *event)
 {
 	if (event->attr.type != pt_pmu.pmu.type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!pt_event_valid(event))
 		return -EINVAL;
diff --git a/arch/x86/events/intel/uncore.c b/arch/x86/events/intel/uncore.c
index cf76d6631..118837e31 100644
--- a/arch/x86/events/intel/uncore.c
+++ b/arch/x86/events/intel/uncore.c
@@ -701,12 +701,12 @@ static int uncore_pmu_event_init(struct perf_event *event)
 	int ret;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pmu = uncore_event_to_pmu(event);
 	/* no device found for this pmu */
 	if (pmu->func_id < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Sampling not supported yet */
 	if (hwc->sample_period)
diff --git a/arch/x86/events/intel/uncore_snb.c b/arch/x86/events/intel/uncore_snb.c
index 3de1065ee..336273c21 100644
--- a/arch/x86/events/intel/uncore_snb.c
+++ b/arch/x86/events/intel/uncore_snb.c
@@ -459,12 +459,12 @@ static int snb_uncore_imc_event_init(struct perf_event *event)
 	int idx, base;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pmu = uncore_event_to_pmu(event);
 	/* no device found for this pmu */
 	if (pmu->func_id < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Sampling not supported yet */
 	if (hwc->sample_period)
diff --git a/arch/x86/events/msr.c b/arch/x86/events/msr.c
index a949f6f55..a147df6d6 100644
--- a/arch/x86/events/msr.c
+++ b/arch/x86/events/msr.c
@@ -4,7 +4,7 @@
 #include <linux/nospec.h>
 #include <asm/intel-family.h>
 #include "probe.h"
-
+#include <linux/errno.h>
 enum perf_msr_id {
 	PERF_MSR_TSC			= 0,
 	PERF_MSR_APERF			= 1,
@@ -191,7 +191,7 @@ static int msr_event_init(struct perf_event *event)
 	u64 cfg = event->attr.config;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* unsupported modes and filters */
 	if (event->attr.sample_period) /* no sampling */
diff --git a/arch/x86/events/rapl.c b/arch/x86/events/rapl.c
index 0f2bf59f4..e47498ce0 100644
--- a/arch/x86/events/rapl.c
+++ b/arch/x86/events/rapl.c
@@ -340,7 +340,7 @@ static int rapl_pmu_event_init(struct perf_event *event)
 
 	/* only look at RAPL events */
 	if (event->attr.type != rapl_pmus->pmu.type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* check only supported bits are set */
 	if (event->attr.config & ~RAPL_EVENT_MASK)
diff --git a/arch/x86/kernel/cpu/cacheinfo.c b/arch/x86/kernel/cpu/cacheinfo.c
index c7503be92..701abdcc8 100644
--- a/arch/x86/kernel/cpu/cacheinfo.c
+++ b/arch/x86/kernel/cpu/cacheinfo.c
@@ -990,7 +990,7 @@ static int __init_cache_level(unsigned int cpu)
 	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
 
 	if (!num_cache_leaves)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (!this_cpu_ci)
 		return -EINVAL;
 	this_cpu_ci->num_levels = 3;
diff --git a/arch/x86/kernel/cpu/resctrl/ctrlmondata.c b/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
index 934c8fb8a..4aec7e5af 100644
--- a/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
+++ b/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
@@ -379,7 +379,7 @@ ssize_t rdtgroup_schemata_write(struct kernfs_open_file *of,
 	if (!rdtgrp) {
 		rdtgroup_kn_unlock(of->kn);
 		cpus_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	rdt_last_cmd_clear();
 
diff --git a/arch/x86/kernel/cpu/resctrl/rdtgroup.c b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
index 3f844f14f..d612ec62f 100644
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@ -681,7 +681,7 @@ static ssize_t rdtgroup_tasks_write(struct kernfs_open_file *of,
 	rdtgrp = rdtgroup_kn_lock_live(of->kn);
 	if (!rdtgrp) {
 		rdtgroup_kn_unlock(of->kn);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	rdt_last_cmd_clear();
 
@@ -1047,7 +1047,7 @@ static int rdtgroup_mode_show(struct kernfs_open_file *of,
 	rdtgrp = rdtgroup_kn_lock_live(of->kn);
 	if (!rdtgrp) {
 		rdtgroup_kn_unlock(of->kn);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	seq_printf(s, "%s\n", rdtgroup_mode_str(rdtgrp->mode));
@@ -1278,7 +1278,7 @@ static ssize_t rdtgroup_mode_write(struct kernfs_open_file *of,
 	rdtgrp = rdtgroup_kn_lock_live(of->kn);
 	if (!rdtgrp) {
 		rdtgroup_kn_unlock(of->kn);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rdt_last_cmd_clear();
@@ -1386,7 +1386,7 @@ static int rdtgroup_size_show(struct kernfs_open_file *of,
 	rdtgrp = rdtgroup_kn_lock_live(of->kn);
 	if (!rdtgrp) {
 		rdtgroup_kn_unlock(of->kn);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (rdtgrp->mode == RDT_MODE_PSEUDO_LOCKED) {
@@ -1625,7 +1625,7 @@ int rdtgroup_kn_mode_restrict(struct rdtgroup *r, const char *name)
 
 	kn = kernfs_find_and_get_ns(r->kn, name, NULL);
 	if (!kn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (kernfs_type(kn)) {
 	case KERNFS_DIR:
@@ -1673,7 +1673,7 @@ int rdtgroup_kn_mode_restore(struct rdtgroup *r, const char *name,
 
 	kn = kernfs_find_and_get_ns(r->kn, name, NULL);
 	if (!kn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (kernfs_type(kn)) {
 	case KERNFS_DIR:
diff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c
index af9cdb426..a668e177a 100644
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@ -430,7 +430,7 @@ static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)
 
 	vector = synic_get_sint_vector(synic_read_sint(synic, sint));
 	if (vector < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memset(&irq, 0, sizeof(irq));
 	irq.shorthand = APIC_DEST_SELF;
@@ -690,7 +690,7 @@ static int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,
 	int r;
 
 	if (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	msg_page_gfn = synic->msg_page >> PAGE_SHIFT;
 
@@ -1921,7 +1921,7 @@ static int kvm_hv_eventfd_deassign(struct kvm *kvm, u32 conn_id)
 	mutex_unlock(&hv->hv_lock);
 
 	if (!eventfd)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	synchronize_srcu(&kvm->srcu);
 	eventfd_ctx_put(eventfd);
diff --git a/arch/x86/kvm/vmx/evmcs.h b/arch/x86/kvm/vmx/evmcs.h
index e5f7a7ebf..79677b040 100644
--- a/arch/x86/kvm/vmx/evmcs.h
+++ b/arch/x86/kvm/vmx/evmcs.h
@@ -84,7 +84,7 @@ static __always_inline int get_evmcs_offset(unsigned long field,
 	if (unlikely(index >= nr_evmcs_1_fields)) {
 		WARN_ONCE(1, "KVM: accessing unsupported EVMCS field %lx\n",
 			  field);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	evmcs_field = &vmcs_field_to_evmcs_1[index];
diff --git a/arch/x86/kvm/vmx/vmcs12.h b/arch/x86/kvm/vmx/vmcs12.h
index 80232daf0..91f39e735 100644
--- a/arch/x86/kvm/vmx/vmcs12.h
+++ b/arch/x86/kvm/vmx/vmcs12.h
@@ -374,16 +374,16 @@ static inline short vmcs_field_to_offset(unsigned long field)
 	unsigned int index;
 
 	if (field >> 15)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	index = ROL16(field, 6);
 	if (index >= nr_vmcs12_fields)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	index = array_index_nospec(index, nr_vmcs12_fields);
 	offset = vmcs_field_to_offset_table[index];
 	if (offset == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return offset;
 }
 
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 13745f2a5..c0289b463 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -832,7 +832,7 @@ int vmx_find_msr_index(struct vmx_msrs *m, u32 msr)
 		if (m->val[i].index == msr)
 			return i;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)
diff --git a/arch/x86/mm/amdtopology.c b/arch/x86/mm/amdtopology.c
index 058b2f36b..d07370818 100644
--- a/arch/x86/mm/amdtopology.c
+++ b/arch/x86/mm/amdtopology.c
@@ -49,7 +49,7 @@ static __init int find_northbridge(void)
 		return num;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int __init amd_numa_init(void)
@@ -74,7 +74,7 @@ int __init amd_numa_init(void)
 	reg = read_pci_config(0, nb, 0, 0x60);
 	numnodes = ((reg >> 4) & 0xF) + 1;
 	if (numnodes <= 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pr_info("Number of physical nodes %d\n", numnodes);
 
@@ -155,7 +155,7 @@ int __init amd_numa_init(void)
 	}
 
 	if (!nodes_weight(numa_nodes_parsed))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * We seem to have valid NUMA configuration.  Map apicids to nodes
diff --git a/arch/x86/mm/numa_emulation.c b/arch/x86/mm/numa_emulation.c
index c5174b4e3..a537236ae 100644
--- a/arch/x86/mm/numa_emulation.c
+++ b/arch/x86/mm/numa_emulation.c
@@ -25,7 +25,7 @@ static int __init emu_find_memblk_by_nid(int nid, const struct numa_meminfo *mi)
 	for (i = 0; i < mi->nr_blks; i++)
 		if (mi->blk[i].nid == nid)
 			return i;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static u64 __init mem_hole_size(u64 start, u64 end)
diff --git a/arch/x86/pci/mmconfig-shared.c b/arch/x86/pci/mmconfig-shared.c
index 6fa42e9c4..bc4b244f1 100644
--- a/arch/x86/pci/mmconfig-shared.c
+++ b/arch/x86/pci/mmconfig-shared.c
@@ -811,5 +811,5 @@ int pci_mmconfig_delete(u16 seg, u8 start, u8 end)
 		}
 	mutex_unlock(&pci_mmcfg_lock);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
diff --git a/arch/xtensa/kernel/hw_breakpoint.c b/arch/xtensa/kernel/hw_breakpoint.c
index 285fb2942..003c005ab 100644
--- a/arch/xtensa/kernel/hw_breakpoint.c
+++ b/arch/xtensa/kernel/hw_breakpoint.c
@@ -304,5 +304,5 @@ int check_hw_breakpoint(struct pt_regs *regs)
 		}
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
diff --git a/arch/xtensa/kernel/perf_event.c b/arch/xtensa/kernel/perf_event.c
index 99fcd63ce..7ce91a63e 100644
--- a/arch/xtensa/kernel/perf_event.c
+++ b/arch/xtensa/kernel/perf_event.c
@@ -228,7 +228,7 @@ static int xtensa_pmu_event_init(struct perf_event *event)
 		return 0;
 
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/block/blk-mq-debugfs.c b/block/blk-mq-debugfs.c
index e0b2bc131..8bb89ebbe 100644
--- a/block/blk-mq-debugfs.c
+++ b/block/blk-mq-debugfs.c
@@ -153,7 +153,7 @@ static ssize_t queue_state_write(void *data, const char __user *buf,
 	 * triggering a use-after-free.
 	 */
 	if (blk_queue_dead(q))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (count >= sizeof(opbuf)) {
 		pr_err("%s: operation too long\n", __func__);
diff --git a/block/elevator.c b/block/elevator.c
index 4eab3d70e..4737b2b6f 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -734,7 +734,7 @@ static int __elevator_change(struct request_queue *q, const char *name)
 
 	/* Make sure queue is not in the middle of being removed */
 	if (!blk_queue_registered(q))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Special case for mq, turn off scheduling
diff --git a/crypto/algapi.c b/crypto/algapi.c
index 92abdf675..b78ba106e 100644
--- a/crypto/algapi.c
+++ b/crypto/algapi.c
@@ -434,7 +434,7 @@ EXPORT_SYMBOL_GPL(crypto_register_alg);
 static int crypto_remove_alg(struct crypto_alg *alg, struct list_head *list)
 {
 	if (unlikely(list_empty(&alg->cra_list)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	alg->cra_flags |= CRYPTO_ALG_DEAD;
 
@@ -854,7 +854,7 @@ int crypto_attr_u32(struct rtattr *rta, u32 *num)
 	struct crypto_attr_u32 *nu32;
 
 	if (!rta)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (RTA_PAYLOAD(rta) < sizeof(*nu32))
 		return -EINVAL;
 	if (rta->rta_type != CRYPTOA_U32)
diff --git a/crypto/crypto_user_base.c b/crypto/crypto_user_base.c
index 3fa20f129..9fc1db8c8 100644
--- a/crypto/crypto_user_base.c
+++ b/crypto/crypto_user_base.c
@@ -196,7 +196,7 @@ static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,
 
 	alg = crypto_alg_match(p, 0);
 	if (!alg)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = -ENOMEM;
 	skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
@@ -276,7 +276,7 @@ static int crypto_update_alg(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 	alg = crypto_alg_match(p, 1);
 	if (!alg)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	down_write(&crypto_alg_sem);
 
@@ -308,7 +308,7 @@ static int crypto_del_alg(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 	alg = crypto_alg_match(p, 1);
 	if (!alg)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* We can not unregister core algorithms such as aes-generic.
 	 * We would loose the reference in the crypto_alg_list to this algorithm
diff --git a/crypto/crypto_user_stat.c b/crypto/crypto_user_stat.c
index 154884bf9..716a84615 100644
--- a/crypto/crypto_user_stat.c
+++ b/crypto/crypto_user_stat.c
@@ -307,7 +307,7 @@ int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,
 
 	alg = crypto_alg_match(p, 0);
 	if (!alg)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = -ENOMEM;
 	skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);
diff --git a/drivers/acpi/acpi_apd.c b/drivers/acpi/acpi_apd.c
index ba2612e9a..2d2bb7364 100644
--- a/drivers/acpi/acpi_apd.c
+++ b/drivers/acpi/acpi_apd.c
@@ -96,7 +96,7 @@ static int st_misc_setup(struct apd_private_data *pdata)
 	ret = acpi_dev_get_resources(adev, &resource_list, misc_check_res,
 				     NULL);
 	if (ret < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_for_each_entry(rentry, &resource_list, node) {
 		clk_data->base = devm_ioremap(&adev->dev, rentry->res->start,
diff --git a/drivers/acpi/acpi_lpat.c b/drivers/acpi/acpi_lpat.c
index 851f67c96..04a859e52 100644
--- a/drivers/acpi/acpi_lpat.c
+++ b/drivers/acpi/acpi_lpat.c
@@ -33,7 +33,7 @@ int acpi_lpat_raw_to_temp(struct acpi_lpat_conversion_table *lpat_table,
 	}
 
 	if (i == lpat_table->lpat_count - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	delta_temp = lpat[i+1].temp - lpat[i].temp;
 	delta_raw = lpat[i+1].raw - lpat[i].raw;
@@ -66,7 +66,7 @@ int acpi_lpat_temp_to_raw(struct acpi_lpat_conversion_table *lpat_table,
 	}
 
 	if (i ==  lpat_table->lpat_count - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	delta_temp = lpat[i+1].temp - lpat[i].temp;
 	delta_raw = lpat[i+1].raw - lpat[i].raw;
diff --git a/drivers/acpi/apei/erst.c b/drivers/acpi/apei/erst.c
index 2e0b0fcad..658cf34ea 100644
--- a/drivers/acpi/apei/erst.c
+++ b/drivers/acpi/apei/erst.c
@@ -91,7 +91,7 @@ static inline int erst_errno(int command_status)
 		return -ENOSPC;
 	case ERST_STATUS_RECORD_STORE_EMPTY:
 	case ERST_STATUS_RECORD_NOT_FOUND:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c
index 81bf71b10..513ac381c 100644
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@ -344,13 +344,13 @@ static int __ghes_peek_estatus(struct ghes *ghes,
 		return -EIO;
 	}
 	if (!*buf_paddr)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ghes_copy_tofrom_phys(estatus, *buf_paddr, sizeof(*estatus), 1,
 			      fixmap_idx);
 	if (!estatus->block_status) {
 		*buf_paddr = 0;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -1103,7 +1103,7 @@ static int __ghes_sdei_callback(struct ghes *ghes,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int ghes_sdei_normal_callback(u32 event_num, struct pt_regs *regs,
diff --git a/drivers/acpi/numa/srat.c b/drivers/acpi/numa/srat.c
index 5be5a977d..d15fcbd44 100644
--- a/drivers/acpi/numa/srat.c
+++ b/drivers/acpi/numa/srat.c
@@ -417,7 +417,7 @@ int __init acpi_numa_init(void)
 	if (cnt < 0)
 		return cnt;
 	else if (!parsed_numa_memblks)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return 0;
 }
 
diff --git a/drivers/acpi/pmic/intel_pmic.c b/drivers/acpi/pmic/intel_pmic.c
index a371f273f..e093d0bf8 100644
--- a/drivers/acpi/pmic/intel_pmic.c
+++ b/drivers/acpi/pmic/intel_pmic.c
@@ -44,7 +44,7 @@ static int pmic_get_reg_bit(int address, struct pmic_table *table,
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static acpi_status intel_pmic_power_handler(u32 function,
diff --git a/drivers/acpi/pmic/tps68470_pmic.c b/drivers/acpi/pmic/tps68470_pmic.c
index ebd03e472..b81581fda 100644
--- a/drivers/acpi/pmic/tps68470_pmic.c
+++ b/drivers/acpi/pmic/tps68470_pmic.c
@@ -203,7 +203,7 @@ static int pmic_get_reg_bit(u64 address,
 
 	i = address / 4;
 	if (i >= table_size)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!reg || !bitmask)
 		return -EINVAL;
diff --git a/drivers/acpi/pptt.c b/drivers/acpi/pptt.c
index 4ae93350b..61a29fb69 100644
--- a/drivers/acpi/pptt.c
+++ b/drivers/acpi/pptt.c
@@ -519,7 +519,7 @@ static int topology_get_acpi_cpu_tag(struct acpi_table_header *table,
 	}
 	pr_warn_once("PPTT table found, but unable to locate core %d (%d)\n",
 		    cpu, acpi_cpu_id);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int find_acpi_cpu_topology_tag(unsigned int cpu, int level, int flag)
@@ -531,7 +531,7 @@ static int find_acpi_cpu_topology_tag(unsigned int cpu, int level, int flag)
 	status = acpi_get_table(ACPI_SIG_PPTT, 0, &table);
 	if (ACPI_FAILURE(status)) {
 		acpi_pptt_warn_missing();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	retval = topology_get_acpi_cpu_tag(table, cpu, level, flag);
 	pr_debug("Topology Setup ACPI CPU %d, level %d ret = %d\n",
@@ -634,7 +634,7 @@ int cache_setup_acpi(unsigned int cpu)
 	status = acpi_get_table(ACPI_SIG_PPTT, 0, &table);
 	if (ACPI_FAILURE(status)) {
 		acpi_pptt_warn_missing();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	cache_setup_acpi_cpu(table, cpu);
@@ -702,7 +702,7 @@ int find_acpi_cpu_cache_topology(unsigned int cpu, int level)
 	status = acpi_get_table(ACPI_SIG_PPTT, 0, &table);
 	if (ACPI_FAILURE(status)) {
 		acpi_pptt_warn_missing();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	found_cache = acpi_find_cache_node(table, acpi_cpu_id,
diff --git a/drivers/acpi/property.c b/drivers/acpi/property.c
index e601c4511..0744aaa82 100644
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@ -680,7 +680,7 @@ int __acpi_node_get_property_reference(const struct fwnode_handle *fwnode,
 
 	data = acpi_device_data_of_node(fwnode);
 	if (!data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = acpi_data_get_property(data, propname, ACPI_TYPE_ANY, &obj);
 	if (ret)
@@ -715,7 +715,7 @@ int __acpi_node_get_property_reference(const struct fwnode_handle *fwnode,
 	if (obj->type != ACPI_TYPE_PACKAGE)
 		return -EINVAL;
 	if (index >= obj->package.count)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	element = obj->package.elements;
 	end = element + obj->package.count;
@@ -774,7 +774,7 @@ int __acpi_node_get_property_reference(const struct fwnode_handle *fwnode,
 			element += nargs;
 		} else if (element->type == ACPI_TYPE_INTEGER) {
 			if (idx == index)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			element++;
 		} else {
 			return -EINVAL;
@@ -783,7 +783,7 @@ int __acpi_node_get_property_reference(const struct fwnode_handle *fwnode,
 		idx++;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(__acpi_node_get_property_reference);
 
diff --git a/drivers/acpi/spcr.c b/drivers/acpi/spcr.c
index d73b4535e..a08f851a7 100644
--- a/drivers/acpi/spcr.c
+++ b/drivers/acpi/spcr.c
@@ -101,7 +101,7 @@ int __init acpi_parse_spcr(bool enable_earlycon, bool enable_console)
 				(struct acpi_table_header **)&table);
 
 	if (ACPI_FAILURE(status))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (table->header.revision < 2)
 		pr_info("SPCR table version %d\n", table->header.revision);
diff --git a/drivers/ata/ata_piix.c b/drivers/ata/ata_piix.c
index 3ca7720e7..3377297a2 100644
--- a/drivers/ata/ata_piix.c
+++ b/drivers/ata/ata_piix.c
@@ -540,7 +540,7 @@ static int piix_pata_prereset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (!pci_test_config_bits(pdev, &piix_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return ata_sff_prereset(link, deadline);
 }
 
diff --git a/drivers/ata/libata-acpi.c b/drivers/ata/libata-acpi.c
index 224e3486e..1f608a931 100644
--- a/drivers/ata/libata-acpi.c
+++ b/drivers/ata/libata-acpi.c
@@ -369,7 +369,7 @@ int ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm)
 				      &input, NULL);
 
 	if (status == AE_NOT_FOUND)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (ACPI_FAILURE(status)) {
 		ata_port_err(ap, "ACPI set timing mode failed (status=0x%x)\n",
 			     status);
@@ -795,7 +795,7 @@ static int ata_acpi_push_id(struct ata_device *dev)
 	swap_buf_le16(dev->id, ATA_ID_WORDS);
 
 	if (status == AE_NOT_FOUND)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ACPI_FAILURE(status)) {
 		ata_dev_warn(dev, "ACPI _SDD failed (AE 0x%x)\n", status);
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index b1cd4d97b..7691510e0 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -1834,7 +1834,7 @@ int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 	if (err_mask) {
 		if (err_mask & AC_ERR_NODEV_HINT) {
 			ata_dev_dbg(dev, "NODEV after polling detection\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (is_semb) {
@@ -1867,7 +1867,7 @@ int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			 */
 			ata_dev_dbg(dev,
 				    "both IDENTIFYs aborted, assuming NODEV\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		rc = -EIO;
@@ -1901,7 +1901,7 @@ int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 							ata_id_is_ata(id)) {
 			ata_dev_dbg(dev,
 				"host indicates ignore ATA devices, ignored\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} else {
 		if (ata_id_is_ata(id))
@@ -3143,12 +3143,12 @@ int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel)
 			highbit = fls(udma_mask) - 1;
 			udma_mask &= ~(1 << highbit);
 			if (!udma_mask)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 		} else if (mwdma_mask) {
 			highbit = fls(mwdma_mask) - 1;
 			mwdma_mask &= ~(1 << highbit);
 			if (!mwdma_mask)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 		}
 		break;
 
@@ -3171,7 +3171,7 @@ int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel)
 	xfer_mask &= ata_pack_xfermask(pio_mask, mwdma_mask, udma_mask);
 
 	if (!(xfer_mask & ATA_MASK_PIO) || xfer_mask == orig_mask)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!quiet) {
 		if (xfer_mask & (ATA_MASK_MWDMA | ATA_MASK_UDMA))
diff --git a/drivers/ata/libata-sata.c b/drivers/ata/libata-sata.c
index c16423e44..a43288503 100644
--- a/drivers/ata/libata-sata.c
+++ b/drivers/ata/libata-sata.c
@@ -1386,7 +1386,7 @@ static int ata_eh_read_log_10h(struct ata_device *dev,
 			     csum);
 
 	if (buf[0] & 0x80)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*tag = buf[0] & 0x1f;
 
diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c
index ae7189d1a..b8b256d3e 100644
--- a/drivers/ata/libata-sff.c
+++ b/drivers/ata/libata-sff.c
@@ -3103,7 +3103,7 @@ int ata_pci_bmdma_clear_simplex(struct pci_dev *pdev)
 	u8 simplex;
 
 	if (bmdma == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	simplex = inb(bmdma + 0x02);
 	outb(simplex & 0x60, bmdma + 0x02);
diff --git a/drivers/ata/pata_amd.c b/drivers/ata/pata_amd.c
index 987967f97..5d7883acd 100644
--- a/drivers/ata/pata_amd.c
+++ b/drivers/ata/pata_amd.c
@@ -140,7 +140,7 @@ static int amd_pre_reset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (!pci_test_config_bits(pdev, &amd_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
@@ -338,7 +338,7 @@ static int nv_pre_reset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (!pci_test_config_bits(pdev, &nv_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_arasan_cf.c b/drivers/ata/pata_arasan_cf.c
index e9cf31f38..5814ce423 100644
--- a/drivers/ata/pata_arasan_cf.c
+++ b/drivers/ata/pata_arasan_cf.c
@@ -806,7 +806,7 @@ static int arasan_cf_probe(struct platform_device *pdev)
 	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
 				DRIVER_NAME)) {
 		dev_warn(&pdev->dev, "Failed to get memory region resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	acdev = devm_kzalloc(&pdev->dev, sizeof(*acdev), GFP_KERNEL);
diff --git a/drivers/ata/pata_artop.c b/drivers/ata/pata_artop.c
index 6bd2228bb..8c7abeada 100644
--- a/drivers/ata/pata_artop.c
+++ b/drivers/ata/pata_artop.c
@@ -60,7 +60,7 @@ static int artop62x0_pre_reset(struct ata_link *link, unsigned long deadline)
 	/* Odd numbered device ids are the units with enable bits. */
 	if ((pdev->device & 1) &&
 	    !pci_test_config_bits(pdev, &artop_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_atiixp.c b/drivers/ata/pata_atiixp.c
index c68aa3f58..d1a1a3145 100644
--- a/drivers/ata/pata_atiixp.c
+++ b/drivers/ata/pata_atiixp.c
@@ -84,7 +84,7 @@ static int atiixp_prereset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (!pci_test_config_bits(pdev, &atiixp_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_efar.c b/drivers/ata/pata_efar.c
index 21da59f35..61467e327 100644
--- a/drivers/ata/pata_efar.c
+++ b/drivers/ata/pata_efar.c
@@ -44,7 +44,7 @@ static int efar_pre_reset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (!pci_test_config_bits(pdev, &efar_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_hpt37x.c b/drivers/ata/pata_hpt37x.c
index fad6c6a87..e7a5e69c3 100644
--- a/drivers/ata/pata_hpt37x.c
+++ b/drivers/ata/pata_hpt37x.c
@@ -396,7 +396,7 @@ static int hpt37x_pre_reset(struct ata_link *link, unsigned long deadline)
 	};
 
 	if (!pci_test_config_bits(pdev, &hpt37x_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Reset the state machine */
 	pci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);
diff --git a/drivers/ata/pata_it8213.c b/drivers/ata/pata_it8213.c
index 8a3e87781..6d6292174 100644
--- a/drivers/ata/pata_it8213.c
+++ b/drivers/ata/pata_it8213.c
@@ -38,7 +38,7 @@ static int it8213_pre_reset(struct ata_link *link, unsigned long deadline)
 	struct ata_port *ap = link->ap;
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 	if (!pci_test_config_bits(pdev, &it8213_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_jmicron.c b/drivers/ata/pata_jmicron.c
index c3dedd3e7..290a1146b 100644
--- a/drivers/ata/pata_jmicron.c
+++ b/drivers/ata/pata_jmicron.c
@@ -52,7 +52,7 @@ static int jmicron_pre_reset(struct ata_link *link, unsigned long deadline)
 	/* Check if our port is enabled */
 	pci_read_config_dword(pdev, 0x40, &control);
 	if ((control & port_mask) == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* There are two basic mappings. One has the two SATA ports merged
 	   as master/slave and the secondary as PATA, the other has only the
@@ -83,7 +83,7 @@ static int jmicron_pre_reset(struct ata_link *link, unsigned long deadline)
 	switch (port_map[port]) {
 	case PORT_PATA0:
 		if ((control & (1 << 5)) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (control & (1 << 3))	/* 40/80 pin primary */
 			ap->cbl = ATA_CBL_PATA40;
 		else
@@ -92,7 +92,7 @@ static int jmicron_pre_reset(struct ata_link *link, unsigned long deadline)
 	case PORT_PATA1:
 		/* Bit 21 is set if the port is enabled */
 		if ((control5 & (1 << 21)) == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (control5 & (1 << 19))	/* 40/80 pin secondary */
 			ap->cbl = ATA_CBL_PATA40;
 		else
diff --git a/drivers/ata/pata_marvell.c b/drivers/ata/pata_marvell.c
index b066809ba..f44afa09e 100644
--- a/drivers/ata/pata_marvell.c
+++ b/drivers/ata/pata_marvell.c
@@ -72,7 +72,7 @@ static int marvell_pre_reset(struct ata_link *link, unsigned long deadline)
 
 	if (pdev->device == 0x6145 && ap->port_no == 0 &&
 		!marvell_pata_active(pdev))	/* PATA enable ? */
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_mpiix.c b/drivers/ata/pata_mpiix.c
index 8fda0e32c..77a89b92d 100644
--- a/drivers/ata/pata_mpiix.c
+++ b/drivers/ata/pata_mpiix.c
@@ -53,7 +53,7 @@ static int mpiix_pre_reset(struct ata_link *link, unsigned long deadline)
 	static const struct pci_bits mpiix_enable_bits = { 0x6D, 1, 0x80, 0x80 };
 
 	if (!pci_test_config_bits(pdev, &mpiix_enable_bits))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_ns87410.c b/drivers/ata/pata_ns87410.c
index ca3ab2736..7f6b0b2b9 100644
--- a/drivers/ata/pata_ns87410.c
+++ b/drivers/ata/pata_ns87410.c
@@ -33,7 +33,7 @@ static int ns87410_pre_reset(struct ata_link *link, unsigned long deadline)
 	};
 
 	if (!pci_test_config_bits(pdev, &ns87410_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_oldpiix.c b/drivers/ata/pata_oldpiix.c
index 22a020374..9568792a4 100644
--- a/drivers/ata/pata_oldpiix.c
+++ b/drivers/ata/pata_oldpiix.c
@@ -45,7 +45,7 @@ static int oldpiix_pre_reset(struct ata_link *link, unsigned long deadline)
 	};
 
 	if (!pci_test_config_bits(pdev, &oldpiix_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_opti.c b/drivers/ata/pata_opti.c
index 06a800a3b..df230ade9 100644
--- a/drivers/ata/pata_opti.c
+++ b/drivers/ata/pata_opti.c
@@ -61,7 +61,7 @@ static int opti_pre_reset(struct ata_link *link, unsigned long deadline)
 	};
 
 	if (!pci_test_config_bits(pdev, &opti_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_optidma.c b/drivers/ata/pata_optidma.c
index fbcf0af34..e29a6818d 100644
--- a/drivers/ata/pata_optidma.c
+++ b/drivers/ata/pata_optidma.c
@@ -61,7 +61,7 @@ static int optidma_pre_reset(struct ata_link *link, unsigned long deadline)
 	};
 
 	if (ap->port_no && !pci_test_config_bits(pdev, &optidma_enable_bits))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_pdc2027x.c b/drivers/ata/pata_pdc2027x.c
index de834fbb6..32ab8309e 100644
--- a/drivers/ata/pata_pdc2027x.c
+++ b/drivers/ata/pata_pdc2027x.c
@@ -246,7 +246,7 @@ static int pdc2027x_prereset(struct ata_link *link, unsigned long deadline)
 {
 	/* Check whether port enabled */
 	if (!pdc2027x_port_enabled(link->ap))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return ata_sff_prereset(link, deadline);
 }
 
diff --git a/drivers/ata/pata_rb532_cf.c b/drivers/ata/pata_rb532_cf.c
index 479c4b29b..2865ffb60 100644
--- a/drivers/ata/pata_rb532_cf.c
+++ b/drivers/ata/pata_rb532_cf.c
@@ -117,7 +117,7 @@ static int rb532_pata_driver_probe(struct platform_device *pdev)
 	irq = platform_get_irq(pdev, 0);
 	if (irq <= 0) {
 		dev_err(&pdev->dev, "no IRQ resource found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	gpiod = devm_gpiod_get(&pdev->dev, NULL, GPIOD_IN);
diff --git a/drivers/ata/pata_rdc.c b/drivers/ata/pata_rdc.c
index ecb229c2c..af76169e1 100644
--- a/drivers/ata/pata_rdc.c
+++ b/drivers/ata/pata_rdc.c
@@ -68,7 +68,7 @@ static int rdc_pata_prereset(struct ata_link *link, unsigned long deadline)
 	};
 
 	if (!pci_test_config_bits(pdev, &rdc_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return ata_sff_prereset(link, deadline);
 }
 
diff --git a/drivers/ata/pata_sis.c b/drivers/ata/pata_sis.c
index d7cd39a98..882e30e92 100644
--- a/drivers/ata/pata_sis.c
+++ b/drivers/ata/pata_sis.c
@@ -173,7 +173,7 @@ static int sis_pre_reset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (!pci_test_config_bits(pdev, &sis_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Clear the FIFO settings. We can't enable the FIFO until
 	   we know we are poking at a disk */
diff --git a/drivers/ata/pata_sl82c105.c b/drivers/ata/pata_sl82c105.c
index ac7ddd87f..94987d4b7 100644
--- a/drivers/ata/pata_sl82c105.c
+++ b/drivers/ata/pata_sl82c105.c
@@ -59,7 +59,7 @@ static int sl82c105_pre_reset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (ap->port_no && !pci_test_config_bits(pdev, &sl82c105_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return ata_sff_prereset(link, deadline);
 }
 
diff --git a/drivers/ata/pata_triflex.c b/drivers/ata/pata_triflex.c
index 2a4d38b98..453027fdb 100644
--- a/drivers/ata/pata_triflex.c
+++ b/drivers/ata/pata_triflex.c
@@ -51,7 +51,7 @@ static int triflex_prereset(struct ata_link *link, unsigned long deadline)
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (!pci_test_config_bits(pdev, &triflex_enable_bits[ap->port_no]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ata_sff_prereset(link, deadline);
 }
diff --git a/drivers/ata/pata_via.c b/drivers/ata/pata_via.c
index 38044e679..a5e59e8e6 100644
--- a/drivers/ata/pata_via.c
+++ b/drivers/ata/pata_via.c
@@ -220,7 +220,7 @@ static int via_pre_reset(struct ata_link *link, unsigned long deadline)
 		};
 		struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 		if (!pci_test_config_bits(pdev, &via_enable_bits[ap->port_no]))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return ata_sff_prereset(link, deadline);
diff --git a/drivers/atm/solos-pci.c b/drivers/atm/solos-pci.c
index c32f7dd98..b8d25df95 100644
--- a/drivers/atm/solos-pci.c
+++ b/drivers/atm/solos-pci.c
@@ -675,7 +675,7 @@ static int flash_upgrade(struct solos_card *card, int chip)
 	}
 
 	if (request_firmware(&fw, fw_name, &card->dev->dev))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dev_info(&card->dev->dev, "Flash upgrade starting\n");
 
diff --git a/drivers/base/cacheinfo.c b/drivers/base/cacheinfo.c
index 8d553c92c..795c82fdb 100644
--- a/drivers/base/cacheinfo.c
+++ b/drivers/base/cacheinfo.c
@@ -173,7 +173,7 @@ static int cache_setup_of_node(unsigned int cpu)
 	np = cpu_dev->of_node;
 	if (!np) {
 		pr_err("Failed to find cpu%d device node\n", cpu);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	while (index < cache_leaves(cpu)) {
@@ -190,7 +190,7 @@ static int cache_setup_of_node(unsigned int cpu)
 	}
 
 	if (index != cache_leaves(cpu)) /* not all OF nodes populated */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -301,12 +301,12 @@ static void free_cache_attributes(unsigned int cpu)
 
 int __weak init_cache_level(unsigned int cpu)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int __weak populate_cache_leaves(unsigned int cpu)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int detect_cache_attributes(unsigned int cpu)
@@ -314,7 +314,7 @@ static int detect_cache_attributes(unsigned int cpu)
 	int ret;
 
 	if (init_cache_level(cpu) || !cache_leaves(cpu))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	per_cpu_cacheinfo(cpu) = kcalloc(cache_leaves(cpu),
 					 sizeof(struct cacheinfo), GFP_KERNEL);
@@ -581,7 +581,7 @@ static int cpu_cache_sysfs_init(unsigned int cpu)
 	struct device *dev = get_cpu_device(cpu);
 
 	if (per_cpu_cacheinfo(cpu) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	per_cpu_cache_dev(cpu) = cpu_device_create(dev, NULL, NULL, "cache");
 	if (IS_ERR(per_cpu_cache_dev(cpu)))
diff --git a/drivers/base/devres.c b/drivers/base/devres.c
index 0bbb328bd..b6c010e74 100644
--- a/drivers/base/devres.c
+++ b/drivers/base/devres.c
@@ -380,7 +380,7 @@ int devres_destroy(struct device *dev, dr_release_t release,
 
 	res = devres_remove(dev, release, match, match_data);
 	if (unlikely(!res))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	devres_free(res);
 	return 0;
@@ -410,7 +410,7 @@ int devres_release(struct device *dev, dr_release_t release,
 
 	res = devres_remove(dev, release, match, match_data);
 	if (unlikely(!res))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	(*release)(dev, res);
 	devres_free(res);
diff --git a/drivers/base/firmware_loader/fallback.h b/drivers/base/firmware_loader/fallback.h
index 2afdb6adb..fb92e6564 100644
--- a/drivers/base/firmware_loader/fallback.h
+++ b/drivers/base/firmware_loader/fallback.h
@@ -72,7 +72,7 @@ int firmware_fallback_platform(struct fw_priv *fw_priv, u32 opt_flags);
 static inline int firmware_fallback_platform(struct fw_priv *fw_priv,
 					     u32 opt_flags)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
diff --git a/drivers/base/firmware_loader/fallback_platform.c b/drivers/base/firmware_loader/fallback_platform.c
index cdd2c9a9f..6032f2284 100644
--- a/drivers/base/firmware_loader/fallback_platform.c
+++ b/drivers/base/firmware_loader/fallback_platform.c
@@ -15,7 +15,7 @@ int firmware_fallback_platform(struct fw_priv *fw_priv, u32 opt_flags)
 	int rc;
 
 	if (!(opt_flags & FW_OPT_FALLBACK_PLATFORM))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = security_kernel_load_data(LOADING_FIRMWARE_EFI_EMBEDDED);
 	if (rc)
diff --git a/drivers/base/firmware_loader/firmware.h b/drivers/base/firmware_loader/firmware.h
index 933e2192f..0014a2763 100644
--- a/drivers/base/firmware_loader/firmware.h
+++ b/drivers/base/firmware_loader/firmware.h
@@ -98,7 +98,7 @@ static inline int __fw_state_wait_common(struct fw_priv *fw_priv, long timeout)
 
 	ret = wait_for_completion_killable_timeout(&fw_st->completion, timeout);
 	if (ret != 0 && fw_st->status == FW_STATUS_ABORTED)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (!ret)
 		return -ETIMEDOUT;
 
diff --git a/drivers/base/firmware_loader/main.c b/drivers/base/firmware_loader/main.c
index ca871b135..c6e8cf3b7 100644
--- a/drivers/base/firmware_loader/main.c
+++ b/drivers/base/firmware_loader/main.c
@@ -640,7 +640,7 @@ int assign_fw(struct firmware *fw, struct device *device, u32 opt_flags)
 	mutex_lock(&fw_lock);
 	if (!fw_priv->size || fw_state_is_aborted(fw_priv)) {
 		mutex_unlock(&fw_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/drivers/base/power/clock_ops.c b/drivers/base/power/clock_ops.c
index ced6863a1..604ebc1c4 100644
--- a/drivers/base/power/clock_ops.c
+++ b/drivers/base/power/clock_ops.c
@@ -99,7 +99,7 @@ static int __pm_clk_add(struct device *dev, const char *con_id,
 	} else {
 		if (IS_ERR(clk)) {
 			kfree(ce);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		ce->clk = clk;
 	}
diff --git a/drivers/base/regmap/regcache-rbtree.c b/drivers/base/regmap/regcache-rbtree.c
index cfa29dc89..8fe1037b6 100644
--- a/drivers/base/regmap/regcache-rbtree.c
+++ b/drivers/base/regmap/regcache-rbtree.c
@@ -249,10 +249,10 @@ static int regcache_rbtree_read(struct regmap *map,
 	if (rbnode) {
 		reg_tmp = (reg - rbnode->base_reg) / map->reg_stride;
 		if (!test_bit(reg_tmp, rbnode->cache_present))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		*value = regcache_rbtree_get_register(map, rbnode, reg_tmp);
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c
index a93cafd7b..adbaafd88 100644
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -654,7 +654,7 @@ int regcache_lookup_reg(struct regmap *map, unsigned int reg)
 	if (r)
 		return r - map->reg_defaults;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static bool regcache_reg_present(unsigned long *cache_present, unsigned int idx)
diff --git a/drivers/base/swnode.c b/drivers/base/swnode.c
index e5eb27375..d2994bfa7 100644
--- a/drivers/base/swnode.c
+++ b/drivers/base/swnode.c
@@ -488,11 +488,11 @@ software_node_get_reference_args(const struct fwnode_handle *fwnode,
 	int i;
 
 	if (!swnode)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	prop = property_entry_get(swnode->node->properties, propname);
 	if (!prop)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (prop->type != DEV_PROP_REF)
 		return -EINVAL;
@@ -505,14 +505,14 @@ software_node_get_reference_args(const struct fwnode_handle *fwnode,
 		return -EINVAL;
 
 	if (index * sizeof(*ref) >= prop->length)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ref_array = prop->pointer;
 	ref = &ref_array[index];
 
 	refnode = software_node_fwnode(ref->node);
 	if (!refnode)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (nargs_prop) {
 		error = property_entry_read_int_array(swnode->node->properties,
diff --git a/drivers/bcma/scan.c b/drivers/bcma/scan.c
index 1a942f734..937aae1df 100644
--- a/drivers/bcma/scan.c
+++ b/drivers/bcma/scan.c
@@ -170,9 +170,9 @@ static s32 bcma_erom_get_ci(struct bcma_bus *bus, u32 __iomem **eromptr)
 {
 	u32 ent = bcma_erom_get_ent(bus, eromptr);
 	if (!(ent & SCAN_ER_VALID))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if ((ent & SCAN_ER_TAG) != SCAN_ER_TAG_CI)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return ent;
 }
 
@@ -210,9 +210,9 @@ static s32 bcma_erom_get_mst_port(struct bcma_bus *bus, u32 __iomem **eromptr)
 {
 	u32 ent = bcma_erom_get_ent(bus, eromptr);
 	if (!(ent & SCAN_ER_VALID))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if ((ent & SCAN_ER_TAG) != SCAN_ER_TAG_MP)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return ent;
 }
 
diff --git a/drivers/bcma/sprom.c b/drivers/bcma/sprom.c
index bd2c923a6..6a9d09669 100644
--- a/drivers/bcma/sprom.c
+++ b/drivers/bcma/sprom.c
@@ -167,7 +167,7 @@ static int bcma_sprom_valid(struct bcma_bus *bus, const u16 *sprom,
 	revision = sprom[words - 1] & SSB_SPROM_REVISION_REV;
 	if (revision != 8 && revision != 9 && revision != 10) {
 		pr_err("Unsupported SPROM revision: %d\n", revision);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bus->sprom.revision = revision;
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index 4f61e9209..a792dfc4a 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -672,7 +672,7 @@ static int rbd_open(struct block_device *bdev, fmode_t mode)
 		rbd_dev->open_count++;
 	spin_unlock_irq(&rbd_dev->lock);
 	if (removing)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	(void) get_device(&rbd_dev->dev);
 
@@ -1235,7 +1235,7 @@ static int rbd_snap_size(struct rbd_device *rbd_dev, u64 snap_id,
 
 		which = rbd_dev_snap_index(rbd_dev, snap_id);
 		if (which == BAD_SNAP_INDEX)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		*snap_size = rbd_dev->header.snap_sizes[which];
 	} else {
@@ -6042,7 +6042,7 @@ static int rbd_spec_fill_snap_id(struct rbd_device *rbd_dev)
 
 		snap_id = rbd_snap_id_by_name(rbd_dev, spec->snap_name);
 		if (snap_id == CEPH_NOSNAP)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		spec->snap_id = snap_id;
 	} else {
diff --git a/drivers/block/sx8.c b/drivers/block/sx8.c
index 4478eb7ef..652ec70ff 100644
--- a/drivers/block/sx8.c
+++ b/drivers/block/sx8.c
@@ -447,7 +447,7 @@ static inline int carm_lookup_bucket(u32 msg_size)
 		if (msg_size <= msg_sizes[i])
 			return i;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void carm_init_buckets(void __iomem *mmio)
diff --git a/drivers/block/xen-blkback/xenbus.c b/drivers/block/xen-blkback/xenbus.c
index 42944d41a..63aca5186 100644
--- a/drivers/block/xen-blkback/xenbus.c
+++ b/drivers/block/xen-blkback/xenbus.c
@@ -495,7 +495,7 @@ static int xen_vbd_create(struct xen_blkif *blkif, blkif_vdev_t handle,
 	if (IS_ERR(bdev)) {
 		pr_warn("xen_vbd_create: device %08x could not be opened\n",
 			vbd->pdevice);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	vbd->bdev = bdev;
@@ -503,7 +503,7 @@ static int xen_vbd_create(struct xen_blkif *blkif, blkif_vdev_t handle,
 		pr_warn("xen_vbd_create: device %08x doesn't exist\n",
 			vbd->pdevice);
 		xen_vbd_free(vbd);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	vbd->size = vbd_sz(vbd);
 
diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index 3a9afc905..469a67bb6 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -807,7 +807,7 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 
 	if (!found) {
 		rtl_dev_err(hdev, "no UART config entry found");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rtl_dev_dbg(hdev, "device baudrate = 0x%08x", *device_baudrate);
diff --git a/drivers/bluetooth/btrtl.h b/drivers/bluetooth/btrtl.h
index 2a5826821..829b436a6 100644
--- a/drivers/bluetooth/btrtl.h
+++ b/drivers/bluetooth/btrtl.h
@@ -95,7 +95,7 @@ static inline int btrtl_get_uart_settings(struct hci_dev *hdev,
 					  u32 *device_baudrate,
 					  bool *flow_control)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #endif
diff --git a/drivers/bus/fsl-mc/fsl-mc-msi.c b/drivers/bus/fsl-mc/fsl-mc-msi.c
index 8b9c66d7c..5bc79fa1b 100644
--- a/drivers/bus/fsl-mc/fsl-mc-msi.c
+++ b/drivers/bus/fsl-mc/fsl-mc-msi.c
@@ -189,7 +189,7 @@ int fsl_mc_find_msi_domain(struct device *mc_platform_dev,
 		pr_err("Unable to find fsl-mc MSI domain for %pOF\n",
 		       mc_of_node);
 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	*mc_msi_domain = msi_domain;
diff --git a/drivers/bus/ti-sysc.c b/drivers/bus/ti-sysc.c
index 191c97b84..18d589b4a 100644
--- a/drivers/bus/ti-sysc.c
+++ b/drivers/bus/ti-sysc.c
@@ -600,7 +600,7 @@ static int sysc_parse_and_check_child_range(struct sysc *ddata)
 	if (!ranges) {
 		dev_err(ddata->dev, "missing ranges for %pOF\n", np);
 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	len /= sizeof(*ranges);
@@ -613,11 +613,11 @@ static int sysc_parse_and_check_child_range(struct sysc *ddata)
 
 	error = of_property_read_u32(np, "#address-cells", &nr_addr);
 	if (error)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = of_property_read_u32(np, "#size-cells", &nr_size);
 	if (error)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (nr_addr != 1 || nr_size != 1) {
 		dev_err(ddata->dev, "invalid ranges for %pOF\n", np);
diff --git a/drivers/bus/uniphier-system-bus.c b/drivers/bus/uniphier-system-bus.c
index f70dedace..2f24cad8d 100644
--- a/drivers/bus/uniphier-system-bus.c
+++ b/drivers/bus/uniphier-system-bus.c
@@ -216,7 +216,7 @@ static int uniphier_system_bus_probe(struct platform_device *pdev)
 	ranges = of_get_property(dev->of_node, "ranges", &rlen);
 	if (!ranges) {
 		dev_err(dev, "failed to get ranges property\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rlen /= sizeof(*ranges);
diff --git a/drivers/char/hw_random/octeon-rng.c b/drivers/char/hw_random/octeon-rng.c
index 7be8067ac..211d00b9f 100644
--- a/drivers/char/hw_random/octeon-rng.c
+++ b/drivers/char/hw_random/octeon-rng.c
@@ -74,31 +74,31 @@ static int octeon_rng_probe(struct platform_device *pdev)
 
 	res_ports = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res_ports)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	res_result = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 	if (!res_result)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 
 	rng->control_status = devm_ioremap(&pdev->dev,
 						   res_ports->start,
 						   sizeof(u64));
 	if (!rng->control_status)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rng->result = devm_ioremap(&pdev->dev,
 					   res_result->start,
 					   sizeof(u64));
 	if (!rng->result)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rng->ops = ops;
 
 	platform_set_drvdata(pdev, &rng->ops);
 	ret = devm_hwrng_register(&pdev->dev, &rng->ops);
 	if (ret)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dev_info(&pdev->dev, "Octeon Random Number Generator\n");
 
diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index e1b22fe09..fd1e4aefe 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -2470,7 +2470,7 @@ static int __bmc_get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc,
 retry_bmc_lock:
 		if (list_empty(&bmc->intfs)) {
 			mutex_unlock(&bmc->dyn_mutex);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		intf = list_first_entry(&bmc->intfs, struct ipmi_smi,
 					bmc_link);
@@ -2760,7 +2760,7 @@ static ssize_t guid_show(struct device *dev, struct device_attribute *attr,
 	if (rv)
 		return rv;
 	if (!guid_set)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return snprintf(buf, UUID_STRING_LEN + 1 + 1, "%pUl\n", &guid);
 }
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 2a41b2162..a5975d5ab 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1688,7 +1688,7 @@ int add_random_ready_callback(struct random_ready_callback *rdy)
 
 	owner = rdy->owner;
 	if (!try_module_get(owner))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock_irqsave(&random_ready_list_lock, flags);
 	if (crng_ready())
diff --git a/drivers/char/tpm/tpm2-space.c b/drivers/char/tpm/tpm2-space.c
index 982d341d8..99a75811b 100644
--- a/drivers/char/tpm/tpm2-space.c
+++ b/drivers/char/tpm/tpm2-space.c
@@ -101,7 +101,7 @@ static int tpm2_load_context(struct tpm_chip *chip, u8 *buf,
 		 */
 		*handle = 0;
 		tpm_buf_destroy(&tbuf);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (rc > 0) {
 		dev_warn(&chip->dev, "%s: failed with a TPM error 0x%04X\n",
 			 __func__, rc);
@@ -137,7 +137,7 @@ static int tpm2_save_context(struct tpm_chip *chip, u32 handle, u8 *buf,
 		return -EFAULT;
 	} else if (tpm2_rc_value(rc) == TPM2_RC_REFERENCE_H0) {
 		tpm_buf_destroy(&tbuf);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (rc) {
 		dev_warn(&chip->dev, "%s: failed with a TPM error 0x%04X\n",
 			 __func__, rc);
diff --git a/drivers/clk/bcm/clk-raspberrypi.c b/drivers/clk/bcm/clk-raspberrypi.c
index 1654fd0ee..c790af5e2 100644
--- a/drivers/clk/bcm/clk-raspberrypi.c
+++ b/drivers/clk/bcm/clk-raspberrypi.c
@@ -259,7 +259,7 @@ static int raspberrypi_clk_probe(struct platform_device *pdev)
 					"raspberrypi,bcm2835-firmware");
 	if (!firmware_node) {
 		dev_err(dev, "Missing firmware node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	firmware = rpi_firmware_get(firmware_node);
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 3f588ed06..2f8337363 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -344,7 +344,7 @@ static inline int of_parse_clkspec(const struct device_node *np, int index,
 				   const char *name,
 				   struct of_phandle_args *out_args)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 static inline struct clk_hw *
 of_clk_get_hw_from_clkspec(struct of_phandle_args *clkspec)
diff --git a/drivers/clk/hisilicon/crg-hi3516cv300.c b/drivers/clk/hisilicon/crg-hi3516cv300.c
index 5d4e61c7a..61566c312 100644
--- a/drivers/clk/hisilicon/crg-hi3516cv300.c
+++ b/drivers/clk/hisilicon/crg-hi3516cv300.c
@@ -268,7 +268,7 @@ static int hi3516cv300_crg_probe(struct platform_device *pdev)
 
 	crg->funcs = of_device_get_match_data(&pdev->dev);
 	if (!crg->funcs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	crg->rstc = hisi_reset_init(pdev);
 	if (!crg->rstc)
diff --git a/drivers/clk/hisilicon/crg-hi3798cv200.c b/drivers/clk/hisilicon/crg-hi3798cv200.c
index 08a19ba77..48ec60748 100644
--- a/drivers/clk/hisilicon/crg-hi3798cv200.c
+++ b/drivers/clk/hisilicon/crg-hi3798cv200.c
@@ -351,7 +351,7 @@ static int hi3798cv200_crg_probe(struct platform_device *pdev)
 
 	crg->funcs = of_device_get_match_data(&pdev->dev);
 	if (!crg->funcs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	crg->rstc = hisi_reset_init(pdev);
 	if (!crg->rstc)
diff --git a/drivers/clk/imx/clk-imx6q.c b/drivers/clk/imx/clk-imx6q.c
index ba33c7915..1cabba1d7 100644
--- a/drivers/clk/imx/clk-imx6q.c
+++ b/drivers/clk/imx/clk-imx6q.c
@@ -152,7 +152,7 @@ static int ldb_di_sel_by_clock_id(int clock_id)
 	case IMX6QDL_CLK_PLL5_VIDEO_DIV:
 		if (clk_on_imx6q() &&
 		    imx_get_soc_revision() == IMX_CHIP_REVISION_1_0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		return 0;
 	case IMX6QDL_CLK_PLL2_PFD0_352M:
 		return 1;
@@ -163,7 +163,7 @@ static int ldb_di_sel_by_clock_id(int clock_id)
 	case IMX6QDL_CLK_PLL3_USB_OTG:
 		return 4;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/drivers/clk/qcom/common.c b/drivers/clk/qcom/common.c
index 60d2a78d1..b44f0212d 100644
--- a/drivers/clk/qcom/common.c
+++ b/drivers/clk/qcom/common.c
@@ -65,7 +65,7 @@ int qcom_find_src_index(struct clk_hw *hw, const struct parent_map *map, u8 src)
 		if (src == map[i].src)
 			return i;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(qcom_find_src_index);
 
diff --git a/drivers/clk/renesas/rcar-usb2-clock-sel.c b/drivers/clk/renesas/rcar-usb2-clock-sel.c
index d4c02986c..b541270fa 100644
--- a/drivers/clk/renesas/rcar-usb2-clock-sel.c
+++ b/drivers/clk/renesas/rcar-usb2-clock-sel.c
@@ -180,7 +180,7 @@ static int rcar_usb2_clock_sel_probe(struct platform_device *pdev)
 
 	if (!priv->extal && !priv->xtal) {
 		dev_err(dev, "This driver needs usb_extal or usb_xtal\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	platform_set_drvdata(pdev, priv);
diff --git a/drivers/clk/tegra/clk-dfll.c b/drivers/clk/tegra/clk-dfll.c
index cfbaa90c7..f80f2043f 100644
--- a/drivers/clk/tegra/clk-dfll.c
+++ b/drivers/clk/tegra/clk-dfll.c
@@ -809,7 +809,7 @@ static int find_lut_index_for_rate(struct tegra_dfll *td, unsigned long rate)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/drivers/clk/tegra/clk-tegra124-emc.c b/drivers/clk/tegra/clk-tegra124-emc.c
index 745f9faa9..f252d29c2 100644
--- a/drivers/clk/tegra/clk-tegra124-emc.c
+++ b/drivers/clk/tegra/clk-tegra124-emc.c
@@ -208,7 +208,7 @@ static int emc_set_timing(struct tegra_clk_emc *tegra,
 	struct tegra_emc *emc = emc_ensure_emc_driver(tegra);
 
 	if (!emc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pr_debug("going to rate %ld prate %ld p %s\n", timing->rate,
 		 timing->parent_rate, __clk_get_name(timing->parent));
diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index 3da33c786..f7223ba60 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -275,7 +275,7 @@ int ti_clk_get_reg_addr(struct device_node *node, int index,
 
 	if (i == CLK_MAX_MEMMAPS) {
 		pr_err("clk-provider not found for %pOFn!\n", node);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	reg->index = i;
diff --git a/drivers/cpufreq/brcmstb-avs-cpufreq.c b/drivers/cpufreq/brcmstb-avs-cpufreq.c
index 4f86ce2db..d1a1d7baa 100644
--- a/drivers/cpufreq/brcmstb-avs-cpufreq.c
+++ b/drivers/cpufreq/brcmstb-avs-cpufreq.c
@@ -527,7 +527,7 @@ static int brcm_avs_prepare_init(struct platform_device *pdev)
 	if (!priv->base) {
 		dev_err(dev, "Couldn't find property %s in device tree.\n",
 			BRCM_AVS_CPU_DATA);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	priv->avs_intr_base = __map_region(BRCM_AVS_CPU_INTR);
diff --git a/drivers/cpufreq/freq_table.c b/drivers/cpufreq/freq_table.c
index e117b0059..93d4992a7 100644
--- a/drivers/cpufreq/freq_table.c
+++ b/drivers/cpufreq/freq_table.c
@@ -210,7 +210,7 @@ int cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,
 
 	if (unlikely(!table)) {
 		pr_debug("%s: Unable to find frequency table\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	cpufreq_for_each_valid_entry_idx(pos, table, idx)
diff --git a/drivers/cpufreq/highbank-cpufreq.c b/drivers/cpufreq/highbank-cpufreq.c
index 5a7f6dafc..dbf249717 100644
--- a/drivers/cpufreq/highbank-cpufreq.c
+++ b/drivers/cpufreq/highbank-cpufreq.c
@@ -76,7 +76,7 @@ static int hb_cpufreq_driver_init(void)
 	np = of_node_get(cpu_dev->of_node);
 	if (!np) {
 		pr_err("failed to find highbank cpufreq node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	cpu_clk = clk_get(cpu_dev, NULL);
diff --git a/drivers/cpufreq/imx6q-cpufreq.c b/drivers/cpufreq/imx6q-cpufreq.c
index fdb2ffffb..6784525e3 100644
--- a/drivers/cpufreq/imx6q-cpufreq.c
+++ b/drivers/cpufreq/imx6q-cpufreq.c
@@ -230,7 +230,7 @@ static int imx6q_opp_check_speed_grading(struct device *dev)
 	} else {
 		np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-ocotp");
 		if (!np)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		base = of_iomap(np, 0);
 		of_node_put(np);
@@ -293,7 +293,7 @@ static int imx6ul_opp_check_speed_grading(struct device *dev)
 			np = of_find_compatible_node(NULL, NULL,
 						     "fsl,imx6ull-ocotp");
 		if (!np)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		base = of_iomap(np, 0);
 		of_node_put(np);
@@ -355,7 +355,7 @@ static int imx6q_cpufreq_probe(struct platform_device *pdev)
 	np = of_node_get(cpu_dev->of_node);
 	if (!np) {
 		dev_err(cpu_dev, "failed to find cpu0 node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (of_machine_is_compatible("fsl,imx6ul") ||
diff --git a/drivers/cpufreq/qcom-cpufreq-nvmem.c b/drivers/cpufreq/qcom-cpufreq-nvmem.c
index d06b37822..fb6fb703c 100644
--- a/drivers/cpufreq/qcom-cpufreq-nvmem.c
+++ b/drivers/cpufreq/qcom-cpufreq-nvmem.c
@@ -275,12 +275,12 @@ static int qcom_cpufreq_probe(struct platform_device *pdev)
 
 	np = dev_pm_opp_of_get_opp_desc_node(cpu_dev);
 	if (!np)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = of_device_is_compatible(np, "operating-points-v2-kryo-cpu");
 	if (!ret) {
 		of_node_put(np);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	drv = kzalloc(sizeof(*drv), GFP_KERNEL);
diff --git a/drivers/cpufreq/s3c2412-cpufreq.c b/drivers/cpufreq/s3c2412-cpufreq.c
index 53385a9ab..d89ef9dd2 100644
--- a/drivers/cpufreq/s3c2412-cpufreq.c
+++ b/drivers/cpufreq/s3c2412-cpufreq.c
@@ -197,7 +197,7 @@ static int s3c2412_cpufreq_add(struct device *dev,
 	hclk = clk_get(NULL, "hclk");
 	if (IS_ERR(hclk)) {
 		pr_err("cannot find hclk clock\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fclk = clk_get(NULL, "fclk");
@@ -236,7 +236,7 @@ static int s3c2412_cpufreq_add(struct device *dev,
 err_fclk:
 	clk_put(hclk);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct subsys_interface s3c2412_cpufreq_interface = {
diff --git a/drivers/cpufreq/s3c2440-cpufreq.c b/drivers/cpufreq/s3c2440-cpufreq.c
index 3f772ba88..f405bbcd2 100644
--- a/drivers/cpufreq/s3c2440-cpufreq.c
+++ b/drivers/cpufreq/s3c2440-cpufreq.c
@@ -273,7 +273,7 @@ static int s3c2440_cpufreq_add(struct device *dev,
 
 	if (IS_ERR(xtal) || IS_ERR(hclk) || IS_ERR(fclk) || IS_ERR(armclk)) {
 		pr_err("%s: failed to get clocks\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return s3c_cpufreq_register(&s3c2440_cpufreq_info);
diff --git a/drivers/cpufreq/s3c24xx-cpufreq.c b/drivers/cpufreq/s3c24xx-cpufreq.c
index ed0e713b1..0bc6cda6b 100644
--- a/drivers/cpufreq/s3c24xx-cpufreq.c
+++ b/drivers/cpufreq/s3c24xx-cpufreq.c
@@ -366,7 +366,7 @@ static int __init s3c_cpufreq_initclks(void)
 	if (IS_ERR(clk_fclk) || IS_ERR(clk_hclk) || IS_ERR(clk_pclk) ||
 	    IS_ERR(_clk_mpll) || IS_ERR(clk_arm) || IS_ERR(_clk_xtal)) {
 		pr_err("%s: could not get clock(s)\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pr_info("%s: clocks f=%lu,h=%lu,p=%lu,a=%lu\n",
@@ -488,7 +488,7 @@ static int __init s3c_cpufreq_auto_io(void)
 
 	if (!cpu_cur.info->get_iotiming) {
 		pr_err("%s: get_iotiming undefined\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pr_info("%s: working out IO settings\n", __func__);
diff --git a/drivers/cpufreq/speedstep-centrino.c b/drivers/cpufreq/speedstep-centrino.c
index 75b10ecdb..e13319dac 100644
--- a/drivers/cpufreq/speedstep-centrino.c
+++ b/drivers/cpufreq/speedstep-centrino.c
@@ -247,7 +247,7 @@ static int centrino_cpu_init_table(struct cpufreq_policy *policy)
 		pr_debug("no support for CPU model \"%s\": "
 		       "send /proc/cpuinfo to " MAINTAINER "\n",
 		       cpu->x86_model_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (model->op_points == NULL) {
@@ -255,7 +255,7 @@ static int centrino_cpu_init_table(struct cpufreq_policy *policy)
 		pr_debug("no table support for CPU model \"%s\"\n",
 		       cpu->x86_model_id);
 		pr_debug("try using the acpi-cpufreq driver\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	per_cpu(centrino_model, policy->cpu) = model;
diff --git a/drivers/cpufreq/sun50i-cpufreq-nvmem.c b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
index 9907a1651..fd4c7bc77 100644
--- a/drivers/cpufreq/sun50i-cpufreq-nvmem.c
+++ b/drivers/cpufreq/sun50i-cpufreq-nvmem.c
@@ -45,13 +45,13 @@ static int sun50i_cpufreq_get_efuse(u32 *versions)
 
 	np = dev_pm_opp_of_get_opp_desc_node(cpu_dev);
 	if (!np)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = of_device_is_compatible(np,
 				      "allwinner,sun50i-h6-operating-points");
 	if (!ret) {
 		of_node_put(np);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	speedbin_nvmem = of_nvmem_cell_get(np, NULL);
diff --git a/drivers/crypto/ccp/sev-dev.c b/drivers/crypto/ccp/sev-dev.c
index 476113e12..27eb7d0b0 100644
--- a/drivers/crypto/ccp/sev-dev.c
+++ b/drivers/crypto/ccp/sev-dev.c
@@ -506,7 +506,7 @@ static int sev_get_firmware(struct device *dev,
 	    (firmware_request_nowarn(firmware, SEV_FW_FILE, dev) >= 0))
 		return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Don't fail if SEV FW couldn't be updated. Continue with existing SEV FW */
diff --git a/drivers/crypto/hisilicon/sec2/sec_main.c b/drivers/crypto/hisilicon/sec2/sec_main.c
index a4cb58b54..c1ff79d41 100644
--- a/drivers/crypto/hisilicon/sec2/sec_main.c
+++ b/drivers/crypto/hisilicon/sec2/sec_main.c
@@ -590,7 +590,7 @@ static int sec_core_debug_init(struct sec_dev *sec)
 
 	regset = devm_kzalloc(dev, sizeof(*regset), GFP_KERNEL);
 	if (!regset)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	regset->regs = sec_dfx_regs;
 	regset->nregs = ARRAY_SIZE(sec_dfx_regs);
diff --git a/drivers/crypto/hisilicon/zip/zip_main.c b/drivers/crypto/hisilicon/zip/zip_main.c
index 2229a21ae..d9e31a886 100644
--- a/drivers/crypto/hisilicon/zip/zip_main.c
+++ b/drivers/crypto/hisilicon/zip/zip_main.c
@@ -522,7 +522,7 @@ static int hisi_zip_core_debug_init(struct hisi_zip_ctrl *ctrl)
 
 		regset = devm_kzalloc(dev, sizeof(*regset), GFP_KERNEL);
 		if (!regset)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		regset->regs = hzip_dfx_regs;
 		regset->nregs = ARRAY_SIZE(hzip_dfx_regs);
diff --git a/drivers/crypto/nx/nx-842-pseries.c b/drivers/crypto/nx/nx-842-pseries.c
index 2de5e3672..7424d250b 100644
--- a/drivers/crypto/nx/nx-842-pseries.c
+++ b/drivers/crypto/nx/nx-842-pseries.c
@@ -527,7 +527,7 @@ static int nx842_OF_set_defaults(struct nx842_devdata *devdata)
 		devdata->max_sg_len = 0;
 		return 0;
 	} else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/drivers/crypto/s5p-sss.c b/drivers/crypto/s5p-sss.c
index 341433fbc..bb6a359e0 100644
--- a/drivers/crypto/s5p-sss.c
+++ b/drivers/crypto/s5p-sss.c
@@ -2203,7 +2203,7 @@ static int s5p_aes_probe(struct platform_device *pdev)
 	if (IS_ERR(pdata->clk)) {
 		dev_err(dev, "failed to find secss clock %s\n",
 			variant->clk_names[0]);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = clk_prepare_enable(pdata->clk);
diff --git a/drivers/dma-buf/dma-fence.c b/drivers/dma-buf/dma-fence.c
index 90edf2b28..082f52a90 100644
--- a/drivers/dma-buf/dma-fence.c
+++ b/drivers/dma-buf/dma-fence.c
@@ -354,7 +354,7 @@ int dma_fence_add_callback(struct dma_fence *fence, struct dma_fence_cb *cb,
 
 	if (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->flags)) {
 		INIT_LIST_HEAD(&cb->node);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	spin_lock_irqsave(fence->lock, flags);
diff --git a/drivers/dma/ti/k3-psil.c b/drivers/dma/ti/k3-psil.c
index fb7c8150b..850c722f5 100644
--- a/drivers/dma/ti/k3-psil.c
+++ b/drivers/dma/ti/k3-psil.c
@@ -71,7 +71,7 @@ int psil_set_new_ep_config(struct device *dev, const char *name,
 
 	if (of_parse_phandle_with_args(dev->of_node, "dmas", "#dma-cells",
 				       index, &dma_spec))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	thread_id = dma_spec.args[0];
 
diff --git a/drivers/dma/ti/k3-udma-glue.c b/drivers/dma/ti/k3-udma-glue.c
index 64c8955e0..6d4047505 100644
--- a/drivers/dma/ti/k3-udma-glue.c
+++ b/drivers/dma/ti/k3-udma-glue.c
@@ -119,7 +119,7 @@ static int of_k3_udma_glue_parse_chn(struct device_node *chn_np,
 
 	if (of_parse_phandle_with_args(chn_np, "dmas", "#dma-cells", index,
 				       &dma_spec))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	thread_id = dma_spec.args[0];
 	if (dma_spec.args_count == 2) {
diff --git a/drivers/dma/ti/k3-udma.c b/drivers/dma/ti/k3-udma.c
index 6c879a734..e3667693d 100644
--- a/drivers/dma/ti/k3-udma.c
+++ b/drivers/dma/ti/k3-udma.c
@@ -640,7 +640,7 @@ static int udma_pop_from_ring(struct udma_chan *uc, dma_addr_t *addr)
 
 		/* Check for flush descriptor */
 		if (udma_desc_is_rx_flush(uc, *addr))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		d = udma_udma_desc_from_paddr(uc, *addr);
 
@@ -810,7 +810,7 @@ static int udma_start(struct udma_chan *uc)
 
 	if (!vd) {
 		uc->desc = NULL;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	list_del(&vd->node);
@@ -1329,7 +1329,7 @@ static int udma_get_chan_pair(struct udma_chan *uc)
 	}
 
 	if (chan_id == end)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	set_bit(chan_id, ud->tchan_map);
 	set_bit(chan_id, ud->rchan_map);
diff --git a/drivers/edac/mv64x60_edac.c b/drivers/edac/mv64x60_edac.c
index 3c68bb525..3bd63df17 100644
--- a/drivers/edac/mv64x60_edac.c
+++ b/drivers/edac/mv64x60_edac.c
@@ -86,7 +86,7 @@ static int __init mv64x60_pci_fixup(struct platform_device *pdev)
 	if (!r) {
 		printk(KERN_ERR "%s: Unable to get resource for "
 		       "PCI err regs\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pci_serr = ioremap(r->start, resource_size(r));
diff --git a/drivers/edac/thunderx_edac.c b/drivers/edac/thunderx_edac.c
index 4af9744cc..91527cb03 100644
--- a/drivers/edac/thunderx_edac.c
+++ b/drivers/edac/thunderx_edac.c
@@ -475,7 +475,7 @@ static int thunderx_create_debugfs_nodes(struct dentry *parent,
 		return 0;
 
 	if (!parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < num; i++) {
 		ent = edac_debugfs_create_file(attrs[i]->name, attrs[i]->mode,
diff --git a/drivers/firewire/core-card.c b/drivers/firewire/core-card.c
index 54be88167..ef6792225 100644
--- a/drivers/firewire/core-card.c
+++ b/drivers/firewire/core-card.c
@@ -601,7 +601,7 @@ static void dummy_send_response(struct fw_card *card, struct fw_packet *packet)
 
 static int dummy_cancel_packet(struct fw_card *card, struct fw_packet *packet)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int dummy_enable_phys_dma(struct fw_card *card,
diff --git a/drivers/firewire/core-device.c b/drivers/firewire/core-device.c
index b785e9362..8c3e5afbf 100644
--- a/drivers/firewire/core-device.c
+++ b/drivers/firewire/core-device.c
@@ -111,7 +111,7 @@ int fw_csr_string(const u32 *directory, int key, char *buf, size_t size)
 {
 	const u32 *leaf = search_leaf(directory, key);
 	if (!leaf)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return textual_leaf_to_string(leaf, buf, size);
 }
diff --git a/drivers/firewire/core-transaction.c b/drivers/firewire/core-transaction.c
index 439d918bb..155ac7358 100644
--- a/drivers/firewire/core-transaction.c
+++ b/drivers/firewire/core-transaction.c
@@ -96,7 +96,7 @@ static int close_transaction(struct fw_transaction *transaction,
 	}
 
  timed_out:
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 715e491df..c255d1a1f 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -563,7 +563,7 @@ static int fwnet_finish_incoming_packet(struct net_device *net,
 
 	dev_kfree_skb_any(skb);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
diff --git a/drivers/firmware/arm_sdei.c b/drivers/firmware/arm_sdei.c
index e7e36aab2..71551e671 100644
--- a/drivers/firmware/arm_sdei.c
+++ b/drivers/firmware/arm_sdei.c
@@ -409,7 +409,7 @@ int sdei_event_enable(u32 event_num)
 	event = sdei_event_find(event_num);
 	if (!event) {
 		mutex_unlock(&sdei_events_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 
@@ -455,7 +455,7 @@ int sdei_event_disable(u32 event_num)
 	event = sdei_event_find(event_num);
 	if (!event) {
 		mutex_unlock(&sdei_events_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	spin_lock(&sdei_list_lock);
diff --git a/drivers/firmware/broadcom/bcm47xx_nvram.c b/drivers/firmware/broadcom/bcm47xx_nvram.c
index 835ece9c0..0c8baba36 100644
--- a/drivers/firmware/broadcom/bcm47xx_nvram.c
+++ b/drivers/firmware/broadcom/bcm47xx_nvram.c
@@ -189,7 +189,7 @@ int bcm47xx_nvram_getenv(const char *name, char *val, size_t val_len)
 			return snprintf(val, val_len, "%s", value);
 		var = value + strlen(value) + 1;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(bcm47xx_nvram_getenv);
 
@@ -210,7 +210,7 @@ int bcm47xx_nvram_gpio_pin(const char *name)
 		if (!strcmp(name, buf))
 			return i;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(bcm47xx_nvram_gpio_pin);
 
diff --git a/drivers/firmware/broadcom/bcm47xx_sprom.c b/drivers/firmware/broadcom/bcm47xx_sprom.c
index 4787f86c8..e7692d202 100644
--- a/drivers/firmware/broadcom/bcm47xx_sprom.c
+++ b/drivers/firmware/broadcom/bcm47xx_sprom.c
@@ -499,7 +499,7 @@ static int bcm47xx_increase_mac_addr(u8 *mac, u8 num)
 
 	if (p == oui) {
 		pr_err("unable to fetch mac address\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return 0;
 }
diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index fdd1db025..88caaaba4 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -460,7 +460,7 @@ int efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/drivers/firmware/efi/embedded-firmware.c b/drivers/firmware/efi/embedded-firmware.c
index a1b199de9..d27fda4a6 100644
--- a/drivers/firmware/efi/embedded-firmware.c
+++ b/drivers/firmware/efi/embedded-firmware.c
@@ -62,7 +62,7 @@ static int __init efi_check_md_for_embedded_firmware(
 	}
 	if ((i + desc->length) > size) {
 		memunmap(map);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pr_info("Found EFI embedded fw '%s'\n", desc->name);
@@ -129,7 +129,7 @@ int efi_get_embedded_fw(const char *name, const u8 **data, size_t *size)
 	if (!checked_for_fw) {
 		pr_warn("Warning %s called while we did not check for embedded fw\n",
 			__func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	list_for_each_entry(iter, &efi_embedded_fw_list, list) {
@@ -140,7 +140,7 @@ int efi_get_embedded_fw(const char *name, const u8 **data, size_t *size)
 	}
 
 	if (!fw)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*data = fw->data;
 	*size = fw->length;
diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index 7127a04bc..dd9a97351 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -452,14 +452,14 @@ static int __init ibft_check_device(void)
 		printk(KERN_ERR "iBFT module supports only revision 1, " \
 				"while this is %d.\n",
 				ibft_addr->header.revision);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	for (pos = (u8 *)ibft_addr; pos < (u8 *)ibft_addr + len; pos++)
 		csum += *pos;
 
 	if (csum) {
 		printk(KERN_ERR "iBFT has incorrect checksum (0x%x)!\n", csum);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/drivers/firmware/meson/meson_sm.c b/drivers/firmware/meson/meson_sm.c
index 2854b56f6..b499db17b 100644
--- a/drivers/firmware/meson/meson_sm.c
+++ b/drivers/firmware/meson/meson_sm.c
@@ -107,7 +107,7 @@ int meson_sm_call(struct meson_sm_firmware *fw, unsigned int cmd_index,
 	u32 cmd, lret;
 
 	if (!fw->chip)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cmd = meson_sm_get_cmd(fw->chip, cmd_index);
 	if (!cmd)
@@ -147,7 +147,7 @@ int meson_sm_call_read(struct meson_sm_firmware *fw, void *buffer,
 	int ret;
 
 	if (!fw->chip)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!fw->chip->cmd_shmem_out_base)
 		return -EINVAL;
@@ -195,7 +195,7 @@ int meson_sm_call_write(struct meson_sm_firmware *fw, void *buffer,
 	u32 written;
 
 	if (!fw->chip)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (size > fw->chip->shmem_size)
 		return -EINVAL;
diff --git a/drivers/firmware/tegra/bpmp-debugfs.c b/drivers/firmware/tegra/bpmp-debugfs.c
index 636b40d43..52dc9c254 100644
--- a/drivers/firmware/tegra/bpmp-debugfs.c
+++ b/drivers/firmware/tegra/bpmp-debugfs.c
@@ -206,7 +206,7 @@ static int debugfs_show(struct seq_file *m, void *p)
 
 	filename = get_filename(bpmp, file, buf, sizeof(buf));
 	if (!filename)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	namevirt = dma_alloc_coherent(bpmp->dev, namesize, &namephys,
 				      GFP_KERNEL | GFP_DMA32);
@@ -257,7 +257,7 @@ static ssize_t debugfs_store(struct file *file, const char __user *buf,
 
 	filename = get_filename(bpmp, file, fnamebuf, sizeof(fnamebuf));
 	if (!filename)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	namevirt = dma_alloc_coherent(bpmp->dev, namesize, &namephys,
 				      GFP_KERNEL | GFP_DMA32);
diff --git a/drivers/fpga/dfl-fme-br.c b/drivers/fpga/dfl-fme-br.c
index 3ff9f3a68..0e4548fe9 100644
--- a/drivers/fpga/dfl-fme-br.c
+++ b/drivers/fpga/dfl-fme-br.c
@@ -44,7 +44,7 @@ static int fme_bridge_enable_set(struct fpga_bridge *bridge, bool enable)
 	if (priv->port_pdev && !priv->port_ops) {
 		ops = dfl_fpga_port_ops_get(priv->port_pdev);
 		if (!ops || !ops->enable_set)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		priv->port_ops = ops;
 	}
diff --git a/drivers/fpga/dfl-fme-perf.c b/drivers/fpga/dfl-fme-perf.c
index 6ce1ed222..8c9b18bbb 100644
--- a/drivers/fpga/dfl-fme-perf.c
+++ b/drivers/fpga/dfl-fme-perf.c
@@ -801,7 +801,7 @@ static int fme_perf_event_init(struct perf_event *event)
 
 	/* test the event attr type check for PMU enumeration */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * fme counters are shared across all cores.
diff --git a/drivers/fpga/fpga-mgr.c b/drivers/fpga/fpga-mgr.c
index e05104f5e..23e027a1c 100644
--- a/drivers/fpga/fpga-mgr.c
+++ b/drivers/fpga/fpga-mgr.c
@@ -414,7 +414,7 @@ static ssize_t status_show(struct device *dev,
 	int len = 0;
 
 	if (!mgr->mops->status)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	status = mgr->mops->status(mgr);
 
diff --git a/drivers/fpga/fpga-region.c b/drivers/fpga/fpga-region.c
index bde5a9d46..93fc2b7b9 100644
--- a/drivers/fpga/fpga-region.c
+++ b/drivers/fpga/fpga-region.c
@@ -164,7 +164,7 @@ static ssize_t compat_id_show(struct device *dev,
 	struct fpga_region *region = to_fpga_region(dev);
 
 	if (!region->compat_id)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return sprintf(buf, "%016llx%016llx\n",
 		       (unsigned long long)region->compat_id->id_h,
diff --git a/drivers/gpio/gpio-aggregator.c b/drivers/gpio/gpio-aggregator.c
index 9b0adbddd..42dd0982f 100644
--- a/drivers/gpio/gpio-aggregator.c
+++ b/drivers/gpio/gpio-aggregator.c
@@ -268,7 +268,7 @@ static ssize_t delete_device_store(struct device_driver *driver,
 	aggr = idr_remove(&gpio_aggregator_idr, id);
 	mutex_unlock(&gpio_aggregator_lock);
 	if (!aggr)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	gpio_aggregator_free(aggr);
 	return count;
diff --git a/drivers/gpio/gpio-amd-fch.c b/drivers/gpio/gpio-amd-fch.c
index 4e44ba4d7..34f3a5d04 100644
--- a/drivers/gpio/gpio-amd-fch.c
+++ b/drivers/gpio/gpio-amd-fch.c
@@ -144,7 +144,7 @@ static int amd_fch_gpio_probe(struct platform_device *pdev)
 	pdata = dev_get_platdata(&pdev->dev);
 	if (!pdata) {
 		dev_err(&pdev->dev, "no platform_data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
diff --git a/drivers/gpio/gpio-bcm-kona.c b/drivers/gpio/gpio-bcm-kona.c
index cf3687a79..83da130b4 100644
--- a/drivers/gpio/gpio-bcm-kona.c
+++ b/drivers/gpio/gpio-bcm-kona.c
@@ -588,7 +588,7 @@ static int bcm_kona_gpio_probe(struct platform_device *pdev)
 	ret = platform_irq_count(pdev);
 	if (!ret) {
 		dev_err(dev, "Couldn't determine # GPIO banks\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (ret < 0) {
 		if (ret != -EPROBE_DEFER)
 			dev_err(dev, "Couldn't determine GPIO banks: (%pe)\n",
diff --git a/drivers/gpio/gpio-brcmstb.c b/drivers/gpio/gpio-brcmstb.c
index fcfc1a1f1..35413f0e8 100644
--- a/drivers/gpio/gpio-brcmstb.c
+++ b/drivers/gpio/gpio-brcmstb.c
@@ -680,7 +680,7 @@ static int brcmstb_gpio_probe(struct platform_device *pdev)
 	if (of_property_read_bool(np, "interrupt-controller")) {
 		priv->parent_irq = platform_get_irq(pdev, 0);
 		if (priv->parent_irq <= 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else {
 		priv->parent_irq = -ENOENT;
 	}
diff --git a/drivers/gpio/gpio-em.c b/drivers/gpio/gpio-em.c
index 17a243c52..2a796ef92 100644
--- a/drivers/gpio/gpio-em.c
+++ b/drivers/gpio/gpio-em.c
@@ -343,12 +343,12 @@ static int em_gio_probe(struct platform_device *pdev)
 
 	if (devm_request_irq(dev, irq[0], em_gio_irq_handler, 0, name, p)) {
 		dev_err(dev, "failed to request low IRQ\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (devm_request_irq(dev, irq[1], em_gio_irq_handler, 0, name, p)) {
 		dev_err(dev, "failed to request high IRQ\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = devm_gpiochip_add_data(dev, gpio_chip, p);
diff --git a/drivers/gpio/gpio-raspberrypi-exp.c b/drivers/gpio/gpio-raspberrypi-exp.c
index bb100e012..77649ac40 100644
--- a/drivers/gpio/gpio-raspberrypi-exp.c
+++ b/drivers/gpio/gpio-raspberrypi-exp.c
@@ -205,7 +205,7 @@ static int rpi_exp_gpio_probe(struct platform_device *pdev)
 	fw_node = of_get_parent(np);
 	if (!fw_node) {
 		dev_err(dev, "Missing firmware node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fw = rpi_firmware_get(fw_node);
diff --git a/drivers/gpio/gpio-uniphier.c b/drivers/gpio/gpio-uniphier.c
index f99f3c10b..0bc4f1f1b 100644
--- a/drivers/gpio/gpio-uniphier.c
+++ b/drivers/gpio/gpio-uniphier.c
@@ -238,7 +238,7 @@ static int uniphier_gpio_irq_get_parent_hwirq(struct uniphier_gpio_priv *priv,
 			return hwirq - base + parent_base;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int uniphier_gpio_irq_domain_translate(struct irq_domain *domain,
diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c
index 927605166..738ff0f57 100644
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@ -704,7 +704,7 @@ static int acpi_gpio_resource_lookup(struct acpi_gpio_lookup *lookup,
 	acpi_dev_free_resource_list(&res_list);
 
 	if (!lookup->desc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (info)
 		*info = lookup->info;
@@ -969,7 +969,7 @@ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
 		}
 
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_get);
 
diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c
index 23e3d335c..e25f351b9 100644
--- a/drivers/gpio/gpiolib-sysfs.c
+++ b/drivers/gpio/gpiolib-sysfs.c
@@ -577,7 +577,7 @@ int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 	/* can't export until sysfs is available ... */
 	if (!gpio_class.p) {
 		pr_debug("%s: called too early!\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!desc) {
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 4fa075d49..9070b3072 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -4770,7 +4770,7 @@ static int platform_gpio_count(struct device *dev, const char *con_id)
 
 	table = gpiod_find_lookup_table(dev);
 	if (!table)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (p = &table->table[0]; p->key; p++) {
 		if ((con_id && p->con_id && !strcmp(con_id, p->con_id)) ||
@@ -4778,7 +4778,7 @@ static int platform_gpio_count(struct device *dev, const char *con_id)
 			count++;
 	}
 	if (!count)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return count;
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c
index 85b0515c0..aa71f4808 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c
@@ -178,7 +178,7 @@ int amdgpu_bo_list_get(struct amdgpu_fpriv *fpriv, int id,
 	}
 
 	rcu_read_unlock();
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void amdgpu_bo_list_get_list(struct amdgpu_bo_list *list,
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c
index d2a105e3b..43e44dc74 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c
@@ -1023,7 +1023,7 @@ int amdgpu_dpm_baco_enter(struct amdgpu_device *adev)
 		ret = smu_baco_enter(smu);
 	} else {
 		if (!pp_funcs || !pp_funcs->set_asic_baco_state)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/* enter BACO state */
 		ret = pp_funcs->set_asic_baco_state(pp_handle, 1);
@@ -1043,7 +1043,7 @@ int amdgpu_dpm_baco_exit(struct amdgpu_device *adev)
 		ret = smu_baco_exit(smu);
 	} else {
 		if (!pp_funcs || !pp_funcs->set_asic_baco_state)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/* exit BACO state */
 		ret = pp_funcs->set_asic_baco_state(pp_handle, 0);
@@ -1099,7 +1099,7 @@ int amdgpu_dpm_mode2_reset(struct amdgpu_device *adev)
 		return smu_mode2_reset(smu);
 	} else {
 		if (!pp_funcs || !pp_funcs->asic_reset_mode_2)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		return pp_funcs->asic_reset_mode_2(pp_handle);
 	}
@@ -1125,7 +1125,7 @@ int amdgpu_dpm_baco_reset(struct amdgpu_device *adev)
 	} else {
 		if (!pp_funcs
 		    || !pp_funcs->set_asic_baco_state)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/* enter BACO state */
 		ret = pp_funcs->set_asic_baco_state(pp_handle, 1);
@@ -1197,4 +1197,4 @@ int amdgpu_dpm_allow_xgmi_power_down(struct amdgpu_device *adev, bool en)
 		return smu_allow_xgmi_power_down(smu, en);
 
 	return 0;
-}
\ No newline at end of file
+}
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
index 4ed9958af..dbd760293 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c
@@ -383,7 +383,7 @@ int amdgpu_mode_dumb_mmap(struct drm_file *filp,
 
 	gobj = drm_gem_object_lookup(filp, handle);
 	if (gobj == NULL) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_amdgpu_bo(gobj);
 	if (amdgpu_ttm_tt_get_usermm(robj->tbo.ttm) ||
@@ -446,7 +446,7 @@ int amdgpu_gem_wait_idle_ioctl(struct drm_device *dev, void *data,
 
 	gobj = drm_gem_object_lookup(filp, handle);
 	if (gobj == NULL) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_amdgpu_bo(gobj);
 	ret = dma_resv_wait_timeout_rcu(robj->tbo.base.resv, true, true,
@@ -477,7 +477,7 @@ int amdgpu_gem_metadata_ioctl(struct drm_device *dev, void *data,
 	DRM_DEBUG("%d \n", args->handle);
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	robj = gem_to_amdgpu_bo(gobj);
 
 	r = amdgpu_bo_reserve(robj, false);
@@ -640,7 +640,7 @@ int amdgpu_gem_va_ioctl(struct drm_device *dev, void *data,
 	    !(args->flags & AMDGPU_VM_PAGE_PRT)) {
 		gobj = drm_gem_object_lookup(filp, args->handle);
 		if (gobj == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		abo = gem_to_amdgpu_bo(gobj);
 		tv.bo = &abo->tbo;
 		if (abo->flags & AMDGPU_GEM_CREATE_VM_ALWAYS_VALID)
@@ -720,7 +720,7 @@ int amdgpu_gem_op_ioctl(struct drm_device *dev, void *data,
 
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_amdgpu_bo(gobj);
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c
index 0cc4c67f9..a71761f61 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c
@@ -523,7 +523,7 @@ int amdgpu_irq_get(struct amdgpu_device *adev, struct amdgpu_irq_src *src,
 		   unsigned type)
 {
 	if (!adev->ddev->irq_enabled)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (type >= src->num_types)
 		return -EINVAL;
@@ -553,7 +553,7 @@ int amdgpu_irq_put(struct amdgpu_device *adev, struct amdgpu_irq_src *src,
 		   unsigned type)
 {
 	if (!adev->ddev->irq_enabled)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (type >= src->num_types)
 		return -EINVAL;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
index d7e17e34f..f0b452f0d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c
@@ -837,7 +837,7 @@ static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file
 	}
 	case AMDGPU_INFO_SENSOR: {
 		if (!adev->pm.dpm_enabled)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		switch (info->sensor_info.type) {
 		case AMDGPU_INFO_SENSOR_GFX_SCLK:
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_pmu.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_pmu.c
index 1311d6aec..b2ed1a058 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_pmu.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_pmu.c
@@ -49,7 +49,7 @@ static int amdgpu_perf_event_init(struct perf_event *event)
 
 	/* test the event attr type check for PMU enumeration */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* update the hw_perf_event struct with config data */
 	hwc->config = event->attr.config;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c
index ef3269c43..c4af17421 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c
@@ -687,7 +687,7 @@ int psp_xgmi_initialize(struct psp_context *psp)
 	if (!psp->adev->psp.ta_fw ||
 	    !psp->adev->psp.ta_xgmi_ucode_size ||
 	    !psp->adev->psp.ta_xgmi_start_addr)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!psp->xgmi_context.initialized) {
 		ret = psp_xgmi_init_shared_buf(psp);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c
index c0096097b..a956278ff 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c
@@ -253,7 +253,7 @@ int amdgpu_ras_eeprom_init(struct amdgpu_ras_eeprom_control *control)
 
 	/* Verify i2c adapter is initialized */
 	if (!adev->pm.smu_i2c.algo)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!__get_eeprom_i2c_addr(adev, &control->i2c_address))
 		return -EINVAL;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c
index 5100ebe88..ddf171189 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_uvd.c
@@ -791,7 +791,7 @@ static int amdgpu_uvd_cs_msg(struct amdgpu_uvd_cs_ctx *ctx,
 		}
 
 		DRM_ERROR("Invalid UVD handle 0x%x!\n", handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	case 2:
 		/* it's a destroy msg, free the handle */
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index 7417754e9..e3e426db5 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@ -1467,7 +1467,7 @@ static int amdgpu_vm_update_ptes(struct amdgpu_vm_update_params *params,
 			/* No huge page support before GMC v9 */
 			if (cursor.level != AMDGPU_VM_PTB) {
 				if (!amdgpu_vm_pt_descendant(adev, &cursor))
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 				continue;
 			}
 		} else if (frag < shift) {
@@ -1490,7 +1490,7 @@ static int amdgpu_vm_update_ptes(struct amdgpu_vm_update_params *params,
 		if (!pt) {
 			/* We need all PDs and PTs for mapping something, */
 			if (flags & AMDGPU_PTE_VALID)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 
 			/* but unmapping something can happen at a higher
 			 * level.
@@ -2338,7 +2338,7 @@ int amdgpu_vm_bo_unmap(struct amdgpu_device *adev,
 		}
 
 		if (&mapping->list == &bo_va->invalids)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	list_del(&mapping->list);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
index e38744d06..5ab175c12 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
@@ -2398,7 +2398,7 @@ static int dce_v10_0_crtc_cursor_set2(struct drm_crtc *crtc,
 	obj = drm_gem_object_lookup(file_priv, handle);
 	if (!obj) {
 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, amdgpu_crtc->crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	aobj = gem_to_amdgpu_bo(obj);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
index 2584ff744..0dd5aefcf 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
@@ -2477,7 +2477,7 @@ static int dce_v11_0_crtc_cursor_set2(struct drm_crtc *crtc,
 	obj = drm_gem_object_lookup(file_priv, handle);
 	if (!obj) {
 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, amdgpu_crtc->crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	aobj = gem_to_amdgpu_bo(obj);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
index d05c39f9a..f12de2c22 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c
@@ -2293,7 +2293,7 @@ static int dce_v6_0_crtc_cursor_set2(struct drm_crtc *crtc,
 	obj = drm_gem_object_lookup(file_priv, handle);
 	if (!obj) {
 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, amdgpu_crtc->crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	aobj = gem_to_amdgpu_bo(obj);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index ad0f8adb6..f7490f6b9 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
@@ -2299,7 +2299,7 @@ static int dce_v8_0_crtc_cursor_set2(struct drm_crtc *crtc,
 	obj = drm_gem_object_lookup(file_priv, handle);
 	if (!obj) {
 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, amdgpu_crtc->crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	aobj = gem_to_amdgpu_bo(obj);
diff --git a/drivers/gpu/drm/amd/amdgpu/jpeg_v2_5.c b/drivers/gpu/drm/amd/amdgpu/jpeg_v2_5.c
index 713c32560..f19fc4896 100644
--- a/drivers/gpu/drm/amd/amdgpu/jpeg_v2_5.c
+++ b/drivers/gpu/drm/amd/amdgpu/jpeg_v2_5.c
@@ -68,7 +68,7 @@ static int jpeg_v2_5_early_init(void *handle)
 
 		if (adev->jpeg.harvest_config == (AMDGPU_JPEG_HARVEST_JPEG0 |
 						 AMDGPU_JPEG_HARVEST_JPEG1))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else
 		adev->jpeg.num_jpeg_inst = 1;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
index 5fd67e1cc..593d0e432 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_ai.c
@@ -66,7 +66,7 @@ static int xgpu_ai_mailbox_rcv_msg(struct amdgpu_device *adev,
 	reg = RREG32_NO_KIQ(SOC15_REG_OFFSET(NBIO, 0,
 					     mmBIF_BX_PF0_MAILBOX_MSGBUF_RCV_DW0));
 	if (reg != event)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	xgpu_ai_mailbox_send_ack(adev);
 
diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
index ce2bf1fb7..8d6c0a45f 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_nv.c
@@ -63,7 +63,7 @@ static int xgpu_nv_mailbox_rcv_msg(struct amdgpu_device *adev,
 
 	reg = RREG32_NO_KIQ(mmMAILBOX_MSGBUF_RCV_DW0);
 	if (reg != event)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	xgpu_nv_mailbox_send_ack(adev);
 
diff --git a/drivers/gpu/drm/amd/amdgpu/mxgpu_vi.c b/drivers/gpu/drm/amd/amdgpu/mxgpu_vi.c
index aef9d059a..149236b70 100644
--- a/drivers/gpu/drm/amd/amdgpu/mxgpu_vi.c
+++ b/drivers/gpu/drm/amd/amdgpu/mxgpu_vi.c
@@ -371,12 +371,12 @@ static int xgpu_vi_mailbox_rcv_msg(struct amdgpu_device *adev,
 	if (event != IDH_FLR_NOTIFICATION_CMPL) {
 		reg = RREG32_NO_KIQ(mmMAILBOX_CONTROL);
 		if (!(reg & mask))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	reg = RREG32_NO_KIQ(mmMAILBOX_MSGBUF_RCV_DW0);
 	if (reg != event)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* send ack to PF */
 	xgpu_vi_mailbox_send_ack(adev);
diff --git a/drivers/gpu/drm/amd/amdgpu/si_dpm.c b/drivers/gpu/drm/amd/amdgpu/si_dpm.c
index c00ba4b23..fb8ebcbaa 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_dpm.c
@@ -6547,7 +6547,7 @@ static int si_dpm_get_fan_speed_percent(void *handle,
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
 	if (adev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	duty100 = (RREG32(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;
 	duty = (RREG32(CG_THERMAL_STATUS) & FDO_PWM_DUTY_MASK) >> FDO_PWM_DUTY_SHIFT;
@@ -6575,7 +6575,7 @@ static int si_dpm_set_fan_speed_percent(void *handle,
 	u64 tmp64;
 
 	if (adev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (si_pi->fan_is_controlled_by_smc)
 		return -EINVAL;
@@ -6638,14 +6638,14 @@ static int si_fan_ctrl_get_fan_speed_rpm(struct amdgpu_device *adev,
 	u32 xclk = amdgpu_asic_get_xclk(adev);
 
 	if (adev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (adev->pm.fan_pulses_per_revolution == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tach_period = (RREG32(CG_TACH_STATUS) & TACH_PERIOD_MASK) >> TACH_PERIOD_SHIFT;
 	if (tach_period == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*speed = 60 * xclk * 10000 / tach_period;
 
@@ -6659,10 +6659,10 @@ static int si_fan_ctrl_set_fan_speed_rpm(struct amdgpu_device *adev,
 	u32 xclk = amdgpu_asic_get_xclk(adev);
 
 	if (adev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (adev->pm.fan_pulses_per_revolution == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((speed < adev->pm.fan_min_rpm) ||
 	    (speed > adev->pm.fan_max_rpm))
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c b/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c
index 0a880bc10..568a8bc17 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v6_0.c
@@ -368,7 +368,7 @@ static int uvd_v6_0_early_init(void *handle)
 
 	if (!(adev->flags & AMD_IS_APU) &&
 	    (RREG32_SMC(ixCC_HARVEST_FUSES) & CC_HARVEST_FUSES__UVD_DISABLE_MASK))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	uvd_v6_0_set_ring_funcs(adev);
 
diff --git a/drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c b/drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c
index 7a55457e6..1c5b64479 100644
--- a/drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/uvd_v7_0.c
@@ -386,7 +386,7 @@ static int uvd_v7_0_early_init(void *handle)
 		if (adev->uvd.harvest_config == (AMDGPU_UVD_HARVEST_UVD0 |
 						 AMDGPU_UVD_HARVEST_UVD1))
 			/* both instances are harvested, disable the block */
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else {
 		adev->uvd.num_uvd_inst = 1;
 	}
diff --git a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
index 6d9108fa2..fff812080 100644
--- a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
@@ -405,7 +405,7 @@ static int vce_v3_0_early_init(void *handle)
 	if ((adev->vce.harvest_config &
 	     (AMDGPU_VCE_HARVEST_VCE0 | AMDGPU_VCE_HARVEST_VCE1)) ==
 	    (AMDGPU_VCE_HARVEST_VCE0 | AMDGPU_VCE_HARVEST_VCE1))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	adev->vce.num_rings = 3;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c b/drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c
index 3c6eafb62..c2f385dc4 100644
--- a/drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c
+++ b/drivers/gpu/drm/amd/amdgpu/vcn_v2_5.c
@@ -94,7 +94,7 @@ static int vcn_v2_5_early_init(void *handle)
 			if (adev->vcn.harvest_config == (AMDGPU_VCN_HARVEST_VCN0 |
 						AMDGPU_VCN_HARVEST_VCN1))
 				/* both instances are harvested, disable the block */
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 		} else
 			adev->vcn.num_vcn_inst = 1;
 
diff --git a/drivers/gpu/drm/amd/powerplay/navi10_ppt.c b/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
index 0c9be864d..39afbb4f3 100644
--- a/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
@@ -1931,7 +1931,7 @@ static int navi10_setup_od_limits(struct smu_context *smu) {
 
 	if (!smu->smu_table.power_play_table) {
 		pr_err("powerplay table uninitialized!\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	powerplay_table = (struct smu_11_0_powerplay_table *)smu->smu_table.power_play_table;
 	overdrive_table = &powerplay_table->overdrive_table;
@@ -2031,7 +2031,7 @@ static int navi10_od_edit_dpm_table(struct smu_context *smu, enum PP_OD_DPM_TABL
 
 	if (!smu->od_settings) {
 		pr_err("OD board limits are not set!\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	od_settings = smu->od_settings;
diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_framebuffer.c b/drivers/gpu/drm/arm/display/komeda/komeda_framebuffer.c
index 1b01a625f..1014620d5 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_framebuffer.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_framebuffer.c
@@ -49,7 +49,7 @@ komeda_fb_afbc_size_check(struct komeda_fb *kfb, struct drm_file *file,
 	obj = drm_gem_object_lookup(file, mode_cmd->handles[0]);
 	if (!obj) {
 		DRM_DEBUG_KMS("Failed to lookup GEM object\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	switch (fb->modifier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK) {
@@ -125,7 +125,7 @@ komeda_fb_none_afbc_size_check(struct komeda_dev *mdev, struct komeda_fb *kfb,
 		obj = drm_gem_object_lookup(file, mode_cmd->handles[i]);
 		if (!obj) {
 			DRM_DEBUG_KMS("Failed to lookup GEM object\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		fb->obj[i] = obj;
 
diff --git a/drivers/gpu/drm/armada/armada_crtc.c b/drivers/gpu/drm/armada/armada_crtc.c
index c2b92acd1..3a6558f95 100644
--- a/drivers/gpu/drm/armada/armada_crtc.c
+++ b/drivers/gpu/drm/armada/armada_crtc.c
@@ -706,7 +706,7 @@ static int armada_drm_crtc_cursor_set(struct drm_crtc *crtc,
 
 		obj = armada_gem_object_lookup(file, handle);
 		if (!obj)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/* Must be a kernel-mapped object */
 		if (!obj->addr) {
diff --git a/drivers/gpu/drm/armada/armada_gem.c b/drivers/gpu/drm/armada/armada_gem.c
index 976685f29..939dd0269 100644
--- a/drivers/gpu/drm/armada/armada_gem.c
+++ b/drivers/gpu/drm/armada/armada_gem.c
@@ -302,7 +302,7 @@ int armada_gem_mmap_ioctl(struct drm_device *dev, void *data,
 
 	dobj = armada_gem_object_lookup(file, args->handle);
 	if (dobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!dobj->obj.filp) {
 		drm_gem_object_put_unlocked(&dobj->obj);
@@ -345,7 +345,7 @@ int armada_gem_pwrite_ioctl(struct drm_device *dev, void *data,
 
 	dobj = armada_gem_object_lookup(file, args->handle);
 	if (dobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Must be a kernel-mapped object */
 	if (!dobj->addr)
diff --git a/drivers/gpu/drm/drm_client.c b/drivers/gpu/drm/drm_client.c
index 8cb93f520..b60c1a82e 100644
--- a/drivers/gpu/drm/drm_client.c
+++ b/drivers/gpu/drm/drm_client.c
@@ -379,7 +379,7 @@ static int drm_client_buffer_addfb(struct drm_client_buffer *buffer,
 
 	buffer->fb = drm_framebuffer_lookup(client->dev, buffer->client->file, fb_req.fb_id);
 	if (WARN_ON(!buffer->fb))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* drop the reference we picked up in framebuffer lookup */
 	drm_framebuffer_put(buffer->fb);
diff --git a/drivers/gpu/drm/drm_color_mgmt.c b/drivers/gpu/drm/drm_color_mgmt.c
index c93123ff7..fe1815ab9 100644
--- a/drivers/gpu/drm/drm_color_mgmt.c
+++ b/drivers/gpu/drm/drm_color_mgmt.c
@@ -260,7 +260,7 @@ int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 
 	crtc = drm_crtc_find(dev, file_priv, crtc_lut->crtc_id);
 	if (!crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (crtc->funcs->gamma_set == NULL)
 		return -ENOSYS;
@@ -328,7 +328,7 @@ int drm_mode_gamma_get_ioctl(struct drm_device *dev,
 
 	crtc = drm_crtc_find(dev, file_priv, crtc_lut->crtc_id);
 	if (!crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* memcpy into gamma store */
 	if (crtc_lut->gamma_size != crtc->gamma_size)
diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
index d877ddc6d..8a4f87a77 100644
--- a/drivers/gpu/drm/drm_connector.c
+++ b/drivers/gpu/drm/drm_connector.c
@@ -2256,7 +2256,7 @@ int drm_mode_getconnector(struct drm_device *dev, void *data,
 
 	connector = drm_connector_lookup(dev, file_priv, out_resp->connector_id);
 	if (!connector)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	encoders_count = hweight32(connector->possible_encoders);
 
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 4936e1080..85103dcb0 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -368,7 +368,7 @@ int drm_mode_getcrtc(struct drm_device *dev,
 
 	crtc = drm_crtc_find(dev, file_priv, crtc_resp->crtc_id);
 	if (!crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	plane = crtc->primary;
 
@@ -551,7 +551,7 @@ int drm_mode_setcrtc(struct drm_device *dev, void *data,
 	crtc = drm_crtc_find(dev, file_priv, crtc_req->crtc_id);
 	if (!crtc) {
 		DRM_DEBUG_KMS("Unknown CRTC ID %d\n", crtc_req->crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	DRM_DEBUG_KMS("[CRTC:%d:%s]\n", crtc->base.id, crtc->name);
 
diff --git a/drivers/gpu/drm/drm_encoder.c b/drivers/gpu/drm/drm_encoder.c
index e555281f4..f51151714 100644
--- a/drivers/gpu/drm/drm_encoder.c
+++ b/drivers/gpu/drm/drm_encoder.c
@@ -224,7 +224,7 @@ int drm_mode_getencoder(struct drm_device *dev, void *data,
 
 	encoder = drm_encoder_find(dev, file_priv, enc_resp->encoder_id);
 	if (!encoder)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
 	crtc = drm_encoder_get_crtc(encoder);
diff --git a/drivers/gpu/drm/drm_framebuffer.c b/drivers/gpu/drm/drm_framebuffer.c
index 0375b3d7f..0ad7f6b68 100644
--- a/drivers/gpu/drm/drm_framebuffer.c
+++ b/drivers/gpu/drm/drm_framebuffer.c
@@ -438,7 +438,7 @@ int drm_mode_rmfb(struct drm_device *dev, u32 fb_id,
 
 	fb = drm_framebuffer_lookup(dev, file_priv, fb_id);
 	if (!fb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&file_priv->fbs_lock);
 	list_for_each_entry(fbl, &file_priv->fbs, filp_head)
@@ -479,7 +479,7 @@ int drm_mode_rmfb(struct drm_device *dev, u32 fb_id,
 
 fail_unref:
 	drm_framebuffer_put(fb);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int drm_mode_rmfb_ioctl(struct drm_device *dev,
@@ -515,7 +515,7 @@ int drm_mode_getfb(struct drm_device *dev,
 
 	fb = drm_framebuffer_lookup(dev, file_priv, r->fb_id);
 	if (!fb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Multi-planar framebuffers need getfb2. */
 	if (fb->format->num_planes > 1) {
@@ -578,7 +578,7 @@ int drm_mode_getfb2_ioctl(struct drm_device *dev,
 
 	fb = drm_framebuffer_lookup(dev, file_priv, r->fb_id);
 	if (!fb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* For multi-plane framebuffers, we require the driver to place the
 	 * GEM objects directly in the drm_framebuffer. For single-plane
@@ -709,7 +709,7 @@ int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
 
 	fb = drm_framebuffer_lookup(dev, file_priv, r->fb_id);
 	if (!fb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	num_clips = r->num_clips;
 	clips_ptr = (struct drm_clip_rect __user *)(unsigned long)r->clips_ptr;
diff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c
index 7bf628e13..868c8be47 100644
--- a/drivers/gpu/drm/drm_gem.c
+++ b/drivers/gpu/drm/drm_gem.c
@@ -317,7 +317,7 @@ int drm_gem_dumb_map_offset(struct drm_file *file, struct drm_device *dev,
 
 	obj = drm_gem_object_lookup(file, handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Don't allow imported objects to be mapped */
 	if (obj->import_attach) {
@@ -838,7 +838,7 @@ drm_gem_flink_ioctl(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (obj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&dev->object_name_lock);
 	/* prevent races with concurrent gem_close. */
@@ -893,7 +893,7 @@ drm_gem_open_ioctl(struct drm_device *dev, void *data,
 		drm_gem_object_get(obj);
 	} else {
 		mutex_unlock(&dev->object_name_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* drm_gem_handle_create_tail unlocks dev->object_name_lock. */
diff --git a/drivers/gpu/drm/drm_gem_vram_helper.c b/drivers/gpu/drm/drm_gem_vram_helper.c
index 8b2d5c945..67887b23c 100644
--- a/drivers/gpu/drm/drm_gem_vram_helper.c
+++ b/drivers/gpu/drm/drm_gem_vram_helper.c
@@ -732,7 +732,7 @@ int drm_gem_vram_driver_dumb_mmap_offset(struct drm_file *file,
 
 	gem = drm_gem_object_lookup(file, handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	gbo = drm_gem_vram_of_gem(gem);
 	*offset = drm_gem_vram_mmap_offset(gbo);
diff --git a/drivers/gpu/drm/drm_mode_object.c b/drivers/gpu/drm/drm_mode_object.c
index 901b078ab..7b8b8db95 100644
--- a/drivers/gpu/drm/drm_mode_object.c
+++ b/drivers/gpu/drm/drm_mode_object.c
@@ -536,7 +536,7 @@ int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
 
 	arg_obj = drm_mode_object_find(dev, file_priv, arg->obj_id, arg->obj_type);
 	if (!arg_obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!arg_obj->properties)
 		goto out_unref;
diff --git a/drivers/gpu/drm/drm_plane.c b/drivers/gpu/drm/drm_plane.c
index 4af173ced..f8152b4b9 100644
--- a/drivers/gpu/drm/drm_plane.c
+++ b/drivers/gpu/drm/drm_plane.c
@@ -530,7 +530,7 @@ int drm_mode_getplane(struct drm_device *dev, void *data,
 
 	plane = drm_plane_find(dev, file_priv, plane_resp->plane_id);
 	if (!plane)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	drm_modeset_lock(&plane->mutex, NULL);
 	if (plane->state && plane->state->crtc && drm_lease_held(file_priv, plane->state->crtc->base.id))
@@ -816,7 +816,7 @@ int drm_mode_setplane(struct drm_device *dev, void *data,
 	if (!plane) {
 		DRM_DEBUG_KMS("Unknown plane ID %d\n",
 			      plane_req->plane_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (plane_req->fb_id) {
@@ -824,7 +824,7 @@ int drm_mode_setplane(struct drm_device *dev, void *data,
 		if (!fb) {
 			DRM_DEBUG_KMS("Unknown framebuffer ID %d\n",
 				      plane_req->fb_id);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		crtc = drm_crtc_find(dev, file_priv, plane_req->crtc_id);
@@ -832,7 +832,7 @@ int drm_mode_setplane(struct drm_device *dev, void *data,
 			drm_framebuffer_put(fb);
 			DRM_DEBUG_KMS("Unknown crtc ID %d\n",
 				      plane_req->crtc_id);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -952,7 +952,7 @@ static int drm_mode_cursor_common(struct drm_device *dev,
 	crtc = drm_crtc_find(dev, file_priv, req->crtc_id);
 	if (!crtc) {
 		DRM_DEBUG_KMS("Unknown CRTC ID %d\n", req->crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	drm_modeset_acquire_init(&ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE);
@@ -1072,7 +1072,7 @@ int drm_mode_page_flip_ioctl(struct drm_device *dev,
 
 	crtc = drm_crtc_find(dev, file_priv, page_flip->crtc_id);
 	if (!crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	plane = crtc->primary;
 
diff --git a/drivers/gpu/drm/drm_prime.c b/drivers/gpu/drm/drm_prime.c
index 282774e46..0d1f0f4fd 100644
--- a/drivers/gpu/drm/drm_prime.c
+++ b/drivers/gpu/drm/drm_prime.c
@@ -184,7 +184,7 @@ static int drm_prime_lookup_buf_handle(struct drm_prime_file_private *prime_fpri
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void drm_prime_remove_buf_handle_locked(struct drm_prime_file_private *prime_fpriv,
diff --git a/drivers/gpu/drm/drm_property.c b/drivers/gpu/drm/drm_property.c
index 6ee04803c..d2d02f758 100644
--- a/drivers/gpu/drm/drm_property.c
+++ b/drivers/gpu/drm/drm_property.c
@@ -473,7 +473,7 @@ int drm_mode_getproperty_ioctl(struct drm_device *dev,
 
 	property = drm_property_find(dev, file_priv, out_resp->prop_id);
 	if (!property)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	strncpy(out_resp->name, property->name, DRM_PROP_NAME_LEN);
 	out_resp->name[DRM_PROP_NAME_LEN-1] = 0;
@@ -766,7 +766,7 @@ int drm_mode_getblob_ioctl(struct drm_device *dev,
 
 	blob = drm_property_lookup_blob(dev, out_resp->blob_id);
 	if (!blob)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (out_resp->length == blob->length) {
 		if (copy_to_user(u64_to_user_ptr(out_resp->data),
@@ -832,7 +832,7 @@ int drm_mode_destroyblob_ioctl(struct drm_device *dev,
 
 	blob = drm_property_lookup_blob(dev, out_resp->blob_id);
 	if (!blob)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&dev->mode_config.blob_lock);
 	/* Ensure the property was actually created by this user. */
diff --git a/drivers/gpu/drm/drm_syncobj.c b/drivers/gpu/drm/drm_syncobj.c
index 42d46414f..202809ade 100644
--- a/drivers/gpu/drm/drm_syncobj.c
+++ b/drivers/gpu/drm/drm_syncobj.c
@@ -385,7 +385,7 @@ int drm_syncobj_find_fence(struct drm_file *file_private,
 	int ret;
 
 	if (!syncobj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*fence = drm_syncobj_fence_get(syncobj);
 	drm_syncobj_put(syncobj);
@@ -662,7 +662,7 @@ static int drm_syncobj_import_sync_file_fence(struct drm_file *file_private,
 	syncobj = drm_syncobj_find(file_private, handle);
 	if (!syncobj) {
 		dma_fence_put(fence);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	drm_syncobj_replace_fence(syncobj, fence);
@@ -833,7 +833,7 @@ static int drm_syncobj_transfer_to_timeline(struct drm_file *file_private,
 
 	timeline_syncobj = drm_syncobj_find(file_private, args->dst_handle);
 	if (!timeline_syncobj) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	ret = drm_syncobj_find_fence(file_private, args->src_handle,
 				     args->src_point, args->flags,
@@ -864,7 +864,7 @@ drm_syncobj_transfer_to_binary(struct drm_file *file_private,
 
 	binary_syncobj = drm_syncobj_find(file_private, args->dst_handle);
 	if (!binary_syncobj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ret = drm_syncobj_find_fence(file_private, args->src_handle,
 				     args->src_point, args->flags, &fence);
 	if (ret)
diff --git a/drivers/gpu/drm/drm_sysfs.c b/drivers/gpu/drm/drm_sysfs.c
index f0336c804..1f8a6aab0 100644
--- a/drivers/gpu/drm/drm_sysfs.c
+++ b/drivers/gpu/drm/drm_sysfs.c
@@ -425,7 +425,7 @@ struct device *drm_sysfs_minor_alloc(struct drm_minor *minor)
 int drm_class_device_register(struct device *dev)
 {
 	if (!drm_class || IS_ERR(drm_class))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dev->class = drm_class;
 	return device_register(dev);
diff --git a/drivers/gpu/drm/drm_vblank.c b/drivers/gpu/drm/drm_vblank.c
index 2d5ce690d..d2932ba60 100644
--- a/drivers/gpu/drm/drm_vblank.c
+++ b/drivers/gpu/drm/drm_vblank.c
@@ -1997,7 +1997,7 @@ int drm_crtc_get_sequence_ioctl(struct drm_device *dev, void *data,
 
 	crtc = drm_crtc_find(dev, file_priv, get_seq->crtc_id);
 	if (!crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pipe = drm_crtc_index(crtc);
 
@@ -2055,7 +2055,7 @@ int drm_crtc_queue_sequence_ioctl(struct drm_device *dev, void *data,
 
 	crtc = drm_crtc_find(dev, file_priv, queue_seq->crtc_id);
 	if (!crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	flags = queue_seq->flags;
 	/* Check valid flag bits */
diff --git a/drivers/gpu/drm/etnaviv/etnaviv_drv.c b/drivers/gpu/drm/etnaviv/etnaviv_drv.c
index f9afe11c5..79e66353d 100644
--- a/drivers/gpu/drm/etnaviv/etnaviv_drv.c
+++ b/drivers/gpu/drm/etnaviv/etnaviv_drv.c
@@ -285,7 +285,7 @@ static int etnaviv_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = etnaviv_gem_cpu_prep(obj, args->op, &args->timeout);
 
@@ -306,7 +306,7 @@ static int etnaviv_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = etnaviv_gem_cpu_fini(obj);
 
@@ -327,7 +327,7 @@ static int etnaviv_ioctl_gem_info(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = etnaviv_gem_mmap_offset(obj, &args->offset);
 	drm_gem_object_put_unlocked(obj);
@@ -406,7 +406,7 @@ static int etnaviv_ioctl_gem_wait(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (args->flags & ETNA_WAIT_NONBLOCK)
 		timeout = NULL;
diff --git a/drivers/gpu/drm/exynos/exynos_drm_fimc.c b/drivers/gpu/drm/exynos/exynos_drm_fimc.c
index 29ab8be86..cad7b395a 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_fimc.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_fimc.c
@@ -1330,7 +1330,7 @@ static int fimc_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res) {
 		dev_err(dev, "failed to request irq resource.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = devm_request_irq(dev, res->start, fimc_irq_handler,
diff --git a/drivers/gpu/drm/exynos/exynos_drm_gsc.c b/drivers/gpu/drm/exynos/exynos_drm_gsc.c
index 45e9aee83..1a2123425 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_gsc.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_gsc.c
@@ -1276,7 +1276,7 @@ static int gsc_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res) {
 		dev_err(dev, "failed to request irq resource.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ctx->irq = res->start;
diff --git a/drivers/gpu/drm/exynos/exynos_drm_ipp.c b/drivers/gpu/drm/exynos/exynos_drm_ipp.c
index 4f2b7551b..ece3ec380 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_ipp.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_ipp.c
@@ -158,7 +158,7 @@ int exynos_drm_ipp_get_caps_ioctl(struct drm_device *dev, void *data,
 
 	ipp = __ipp_get(resp->ipp_id);
 	if (!ipp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	resp->ipp_id = ipp->id;
 	resp->capabilities = ipp->capabilities;
@@ -228,7 +228,7 @@ int exynos_drm_ipp_get_limits_ioctl(struct drm_device *dev, void *data,
 
 	ipp = __ipp_get(resp->ipp_id);
 	if (!ipp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	format = __ipp_format_get(ipp, resp->fourcc, resp->modifier,
 				  resp->type);
@@ -577,7 +577,7 @@ static int exynos_drm_ipp_check_format(struct exynos_drm_ipp_task *task,
 		if (buf->buf.pitch[i] < width * buf->format->cpp[i])
 			return -EINVAL;
 		if (!buf->buf.gem_id[i])
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* pitch for additional planes must match */
@@ -885,7 +885,7 @@ int exynos_drm_ipp_commit_ioctl(struct drm_device *dev, void *data,
 
 	ipp = __ipp_get(arg->ipp_id);
 	if (!ipp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	task = exynos_drm_ipp_task_alloc(ipp);
 	if (!task)
diff --git a/drivers/gpu/drm/gma500/psb_device.c b/drivers/gpu/drm/gma500/psb_device.c
index ece994c4c..e03a37292 100644
--- a/drivers/gpu/drm/gma500/psb_device.c
+++ b/drivers/gpu/drm/gma500/psb_device.c
@@ -66,7 +66,7 @@ static int psb_backlight_setup(struct drm_device *dev)
 	/* get bl_max_freq and pol from dev_priv*/
 	if (!dev_priv->lvds_bl) {
 		dev_err(dev->dev, "Has no valid LVDS backlight info\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	bl_max_freq = dev_priv->lvds_bl->freq;
 	blc_pwm_precision_factor = PSB_BLC_PWM_PRECISION_FACTOR;
diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 26996e183..093585dc1 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -16639,7 +16639,7 @@ int intel_get_pipe_from_crtc_id_ioctl(struct drm_device *dev, void *data,
 
 	drmmode_crtc = drm_crtc_find(dev, file, pipe_from_crtc_id->crtc_id);
 	if (!drmmode_crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	crtc = to_intel_crtc(drmmode_crtc);
 	pipe_from_crtc_id->pipe = crtc->pipe;
diff --git a/drivers/gpu/drm/i915/display/intel_hdcp.c b/drivers/gpu/drm/i915/display/intel_hdcp.c
index 2cbc4619b..6a746213e 100644
--- a/drivers/gpu/drm/i915/display/intel_hdcp.c
+++ b/drivers/gpu/drm/i915/display/intel_hdcp.c
@@ -2007,7 +2007,7 @@ int intel_hdcp_enable(struct intel_connector *connector,
 	int ret = -EINVAL;
 
 	if (!hdcp->shim)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&hdcp->mutex);
 	drm_WARN_ON(&dev_priv->drm,
@@ -2054,7 +2054,7 @@ int intel_hdcp_disable(struct intel_connector *connector)
 	int ret = 0;
 
 	if (!hdcp->shim)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&hdcp->mutex);
 
diff --git a/drivers/gpu/drm/i915/display/intel_opregion.c b/drivers/gpu/drm/i915/display/intel_opregion.c
index cc6b00959..ad42620c4 100644
--- a/drivers/gpu/drm/i915/display/intel_opregion.c
+++ b/drivers/gpu/drm/i915/display/intel_opregion.c
@@ -805,7 +805,7 @@ static int intel_load_vbt_firmware(struct drm_i915_private *dev_priv)
 	int ret;
 
 	if (!name || !*name)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = request_firmware(&fw, name, &dev_priv->drm.pdev->dev);
 	if (ret) {
diff --git a/drivers/gpu/drm/i915/display/intel_overlay.c b/drivers/gpu/drm/i915/display/intel_overlay.c
index 66711e62f..36fabe2f3 100644
--- a/drivers/gpu/drm/i915/display/intel_overlay.c
+++ b/drivers/gpu/drm/i915/display/intel_overlay.c
@@ -1082,12 +1082,12 @@ int intel_overlay_put_image_ioctl(struct drm_device *dev, void *data,
 
 	drmmode_crtc = drm_crtc_find(dev, file_priv, params->crtc_id);
 	if (!drmmode_crtc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	crtc = to_intel_crtc(drmmode_crtc);
 
 	new_bo = i915_gem_object_lookup(file_priv, params->bo_handle);
 	if (!new_bo)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	drm_modeset_lock_all(dev);
 
diff --git a/drivers/gpu/drm/i915/display/intel_sprite.c b/drivers/gpu/drm/i915/display/intel_sprite.c
index 0000ec705..a80301761 100644
--- a/drivers/gpu/drm/i915/display/intel_sprite.c
+++ b/drivers/gpu/drm/i915/display/intel_sprite.c
@@ -2369,7 +2369,7 @@ int intel_sprite_set_colorkey_ioctl(struct drm_device *dev, void *data,
 
 	plane = drm_plane_find(dev, file_priv, set->plane_id);
 	if (!plane || plane->type != DRM_PLANE_TYPE_OVERLAY)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * SKL+ only plane 2 can do destination keying against plane 1.
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_context.c b/drivers/gpu/drm/i915/gem/i915_gem_context.c
index 30c229fcb..b43c71c9e 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_context.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_context.c
@@ -1066,7 +1066,7 @@ int i915_gem_vm_destroy_ioctl(struct drm_device *dev, void *data,
 
 	vm = xa_erase(&file_priv->vm_xa, args->vm_id);
 	if (!vm)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	i915_vm_put(vm);
 	return 0;
@@ -1120,7 +1120,7 @@ static int context_barrier_task(struct i915_gem_context *ctx,
 	e = __context_engines_await(ctx);
 	if (!e) {
 		i915_active_release(&cb->base);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for_each_gem_engine(ce, e, it) {
@@ -1292,7 +1292,7 @@ static int set_ppgtt(struct drm_i915_file_private *file_priv,
 		return -ENODEV;
 
 	if (upper_32_bits(args->value))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rcu_read_lock();
 	vm = xa_load(&file_priv->vm_xa, args->value);
@@ -1300,7 +1300,7 @@ static int set_ppgtt(struct drm_i915_file_private *file_priv,
 		vm = NULL;
 	rcu_read_unlock();
 	if (!vm)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = mutex_lock_interruptible(&ctx->mutex);
 	if (err)
@@ -1809,7 +1809,7 @@ set_engines(struct i915_gem_context *ctx,
 				"Invalid engine[%d]: { class:%d, instance:%d }\n",
 				n, ci.engine_class, ci.engine_instance);
 			__free_engines(set.engines, n);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		ce = intel_context_create(engine);
@@ -1840,7 +1840,7 @@ set_engines(struct i915_gem_context *ctx,
 	if (i915_gem_context_is_closed(ctx)) {
 		mutex_unlock(&ctx->engines_mutex);
 		free_engines(set.engines);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (args->size)
 		i915_gem_context_set_user_engines(ctx);
@@ -2296,7 +2296,7 @@ static int create_clone(struct i915_user_extension __user *ext, void *data)
 	src = __i915_gem_context_lookup_rcu(arg->fpriv, local.clone_id);
 	rcu_read_unlock();
 	if (!src)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	GEM_BUG_ON(src == dst);
 
@@ -2387,11 +2387,11 @@ int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,
 		return -EINVAL;
 
 	if (!args->ctx_id)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ctx = xa_erase(&file_priv->context_xa, args->ctx_id);
 	if (!ctx)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	context_close(ctx);
 	return 0;
@@ -2462,7 +2462,7 @@ int i915_gem_context_getparam_ioctl(struct drm_device *dev, void *data,
 
 	ctx = i915_gem_context_lookup(file_priv, args->ctx_id);
 	if (!ctx)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (args->param) {
 	case I915_CONTEXT_PARAM_NO_ZEROMAP:
@@ -2541,7 +2541,7 @@ int i915_gem_context_setparam_ioctl(struct drm_device *dev, void *data,
 
 	ctx = i915_gem_context_lookup(file_priv, args->ctx_id);
 	if (!ctx)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = ctx_setparam(file_priv, ctx, args);
 
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_domain.c b/drivers/gpu/drm/i915/gem/i915_gem_domain.c
index 7f76fc68f..dd3b73ff3 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_domain.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_domain.c
@@ -282,7 +282,7 @@ int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * The caching mode of proxy object is handled by its generator, and
@@ -482,7 +482,7 @@ i915_gem_set_domain_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Already in the desired write domain? Nothing for us to do!
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
index db8eb1c6a..f5f382a96 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c
@@ -776,7 +776,7 @@ static int eb_select_context(struct i915_execbuffer *eb)
 
 	ctx = i915_gem_context_lookup(eb->file->driver_priv, eb->args->rsvd1);
 	if (unlikely(!ctx))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	eb->gem_context = ctx;
 	if (rcu_access_pointer(ctx->vm))
@@ -1587,7 +1587,7 @@ eb_relocate_entry(struct i915_execbuffer *eb,
 	/* we've already hold a reference to all valid objects */
 	target = eb_get_vma(eb, reloc->target_handle);
 	if (unlikely(!target))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Validate that the target is in a valid r/w GPU domain */
 	if (unlikely(reloc->write_domain & (reloc->write_domain - 1))) {
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_mman.c b/drivers/gpu/drm/i915/gem/i915_gem_mman.c
index fe45bd4d6..bcce7f39d 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_mman.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_mman.c
@@ -68,7 +68,7 @@ i915_gem_mmap_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* prime objects have no backing filp to GEM mmap
 	 * pages from.
@@ -643,7 +643,7 @@ __assign_mmap_offset(struct drm_file *file,
 
 	obj = i915_gem_object_lookup(file, handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (i915_gem_object_never_mmap(obj)) {
 		err = -ENODEV;
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_tiling.c b/drivers/gpu/drm/i915/gem/i915_gem_tiling.c
index 0158e49bf..52dfa47cf 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_tiling.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_tiling.c
@@ -343,7 +343,7 @@ i915_gem_set_tiling_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * The tiling mode of proxy objects is handled by its generator, and
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_wait.c b/drivers/gpu/drm/i915/gem/i915_gem_wait.c
index 8af55cd3e..384304478 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_wait.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_wait.c
@@ -239,7 +239,7 @@ i915_gem_wait_ioctl(struct drm_device *dev, void *data, struct drm_file *file)
 
 	obj = i915_gem_object_lookup(file, args->bo_handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	start = ktime_get();
 
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h b/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h
index 23d3a423a..56ee2a79b 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h
+++ b/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.h
@@ -141,7 +141,7 @@ static inline int intel_uc_fw_status_to_error(enum intel_uc_fw_status status)
 	case INTEL_UC_FIRMWARE_DISABLED:
 		return -EPERM;
 	case INTEL_UC_FIRMWARE_MISSING:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case INTEL_UC_FIRMWARE_ERROR:
 		return -ENOEXEC;
 	case INTEL_UC_FIRMWARE_FAIL:
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 0cbcb9f54..41fb8e2c3 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -509,7 +509,7 @@ i915_gem_pread_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Bounds check source.  */
 	if (range_overflows_t(u64, args->offset, args->size, obj->base.size)) {
@@ -799,7 +799,7 @@ i915_gem_pwrite_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Bounds check destination. */
 	if (range_overflows_t(u64, args->offset, args->size, obj->base.size)) {
@@ -875,7 +875,7 @@ i915_gem_sw_finish_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Proxy objects are barred from CPU access, so there is no
@@ -1036,7 +1036,7 @@ i915_gem_madvise_ioctl(struct drm_device *dev, void *data,
 
 	obj = i915_gem_object_lookup(file_priv, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = mutex_lock_interruptible(&obj->mm.lock);
 	if (err)
diff --git a/drivers/gpu/drm/i915/i915_pmu.c b/drivers/gpu/drm/i915/i915_pmu.c
index 962ded9ce..93878e4c7 100644
--- a/drivers/gpu/drm/i915/i915_pmu.c
+++ b/drivers/gpu/drm/i915/i915_pmu.c
@@ -458,7 +458,7 @@ engine_event_status(struct intel_engine_cs *engine,
 			return -ENODEV;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -484,7 +484,7 @@ config_status(struct drm_i915_private *i915, u64 config)
 			return -ENODEV;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -511,7 +511,7 @@ static int i915_pmu_event_init(struct perf_event *event)
 	int ret;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* unsupported modes and filters */
 	if (event->attr.sample_period) /* no sampling */
diff --git a/drivers/gpu/drm/i915/i915_query.c b/drivers/gpu/drm/i915/i915_query.c
index e75c528eb..cd74b4ac3 100644
--- a/drivers/gpu/drm/i915/i915_query.c
+++ b/drivers/gpu/drm/i915/i915_query.c
@@ -253,7 +253,7 @@ static int query_perf_config_data(struct drm_i915_private *i915,
 		oa_config = i915_perf_get_oa_config(perf, config_id);
 	}
 	if (!oa_config)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (copy_from_user(&user_config, user_config_ptr, sizeof(user_config))) {
 		ret = -EFAULT;
diff --git a/drivers/gpu/drm/imx/imx-ldb.c b/drivers/gpu/drm/imx/imx-ldb.c
index 66ea68e8d..362910f5f 100644
--- a/drivers/gpu/drm/imx/imx-ldb.c
+++ b/drivers/gpu/drm/imx/imx-ldb.c
@@ -510,7 +510,7 @@ static u32 of_get_bus_format(struct device *dev, struct device_node *np)
 
 	dev_err(dev, "invalid data mapping: %d-bit \"%s\"\n", datawidth, bm);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct bus_mux imx6q_lvds_mux[2] = {
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index 5404e0d66..212a0339d 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -235,7 +235,7 @@ int lima_gem_get_info(struct drm_file *file, u32 handle, u32 *va, u64 *offset)
 
 	obj = drm_gem_object_lookup(file, handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bo = to_lima_bo(obj);
 
@@ -303,7 +303,7 @@ int lima_gem_submit(struct drm_file *file, struct lima_submit *submit)
 	if (submit->out_sync) {
 		out_sync = drm_syncobj_find(file, submit->out_sync);
 		if (!out_sync)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 0; i < submit->nr_bos; i++) {
diff --git a/drivers/gpu/drm/lima/lima_vm.c b/drivers/gpu/drm/lima/lima_vm.c
index 5b92fb826..1618b878b 100644
--- a/drivers/gpu/drm/lima/lima_vm.c
+++ b/drivers/gpu/drm/lima/lima_vm.c
@@ -106,7 +106,7 @@ int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo, bool create)
 	/* should not create new bo_va if not asked by caller */
 	if (!create) {
 		mutex_unlock(&bo->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bo_va = kzalloc(sizeof(*bo_va), GFP_KERNEL);
diff --git a/drivers/gpu/drm/mgag200/mgag200_cursor.c b/drivers/gpu/drm/mgag200/mgag200_cursor.c
index aebc9ce43..cdbf96c73 100644
--- a/drivers/gpu/drm/mgag200/mgag200_cursor.c
+++ b/drivers/gpu/drm/mgag200/mgag200_cursor.c
@@ -279,7 +279,7 @@ int mgag200_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,
 
 	obj = drm_gem_object_lookup(file_priv, handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	gbo = drm_gem_vram_of_gem(obj);
 	src = drm_gem_vram_vmap(gbo);
 	if (IS_ERR(src)) {
diff --git a/drivers/gpu/drm/msm/adreno/a6xx_gmu.c b/drivers/gpu/drm/msm/adreno/a6xx_gmu.c
index 21e77d671..217a19f16 100644
--- a/drivers/gpu/drm/msm/adreno/a6xx_gmu.c
+++ b/drivers/gpu/drm/msm/adreno/a6xx_gmu.c
@@ -721,7 +721,7 @@ static int a6xx_gmu_fw_start(struct a6xx_gmu *gmu, unsigned int state)
 	} else {
 		if (WARN(!adreno_gpu->fw[ADRENO_FW_GMU],
 			"GMU firmware is not loaded\n"))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/* Turn on register retention */
 		gmu_write(gmu, REG_A6XX_GMU_GENERAL_7, 1);
diff --git a/drivers/gpu/drm/msm/adreno/a6xx_hfi.c b/drivers/gpu/drm/msm/adreno/a6xx_hfi.c
index 9921e632f..9c69abbc9 100644
--- a/drivers/gpu/drm/msm/adreno/a6xx_hfi.c
+++ b/drivers/gpu/drm/msm/adreno/a6xx_hfi.c
@@ -127,7 +127,7 @@ static int a6xx_hfi_wait_for_ack(struct a6xx_gmu *gmu, u32 id, u32 seqnum,
 			DRM_DEV_ERROR(gmu->dev,
 				"The HFI response queue is unexpectedly empty\n");
 
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (HFI_HEADER_ID(resp.header) == HFI_F2H_MSG_ERROR) {
diff --git a/drivers/gpu/drm/msm/disp/mdp4/mdp4_crtc.c b/drivers/gpu/drm/msm/disp/mdp4/mdp4_crtc.c
index c9239b07f..6e811aa3a 100644
--- a/drivers/gpu/drm/msm/disp/mdp4/mdp4_crtc.c
+++ b/drivers/gpu/drm/msm/disp/mdp4/mdp4_crtc.c
@@ -420,7 +420,7 @@ static int mdp4_crtc_cursor_set(struct drm_crtc *crtc,
 	if (handle) {
 		cursor_bo = drm_gem_object_lookup(file_priv, handle);
 		if (!cursor_bo)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else {
 		cursor_bo = NULL;
 	}
diff --git a/drivers/gpu/drm/msm/disp/mdp5/mdp5_crtc.c b/drivers/gpu/drm/msm/disp/mdp5/mdp5_crtc.c
index b5fed67c4..f7fe1494a 100644
--- a/drivers/gpu/drm/msm/disp/mdp5/mdp5_crtc.c
+++ b/drivers/gpu/drm/msm/disp/mdp5/mdp5_crtc.c
@@ -973,7 +973,7 @@ static int mdp5_crtc_cursor_set(struct drm_crtc *crtc,
 
 	cursor_bo = drm_gem_object_lookup(file, handle);
 	if (!cursor_bo)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = msm_gem_get_and_pin_iova(cursor_bo, kms->aspace,
 			&mdp5_crtc->cursor.iova);
diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index f6ce40bf3..a85d2515f 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -754,7 +754,7 @@ static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = msm_gem_cpu_prep(obj, args->op, &timeout);
 
@@ -772,7 +772,7 @@ static int msm_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = msm_gem_cpu_fini(obj);
 
@@ -823,7 +823,7 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	msm_obj = to_msm_bo(obj);
 
@@ -893,7 +893,7 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 
 	queue = msm_submitqueue_get(file->driver_priv, args->queueid);
 	if (!queue)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = msm_wait_fence(gpu->rb[queue->prio]->fctx, args->fence, &timeout,
 		true);
@@ -1065,7 +1065,7 @@ static int msm_pm_resume(struct device *dev)
 	int ret;
 
 	if (WARN_ON(!priv->pm_state))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = drm_atomic_helper_resume(ddev, priv->pm_state);
 	if (!ret)
diff --git a/drivers/gpu/drm/msm/msm_gem_submit.c b/drivers/gpu/drm/msm/msm_gem_submit.c
index 6630aa817..f5c60926c 100644
--- a/drivers/gpu/drm/msm/msm_gem_submit.c
+++ b/drivers/gpu/drm/msm/msm_gem_submit.c
@@ -615,7 +615,7 @@ int msm_ioctl_gem_submit(struct drm_device *dev, void *data,
 
 	queue = msm_submitqueue_get(ctx, args->queueid);
 	if (!queue)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Get a unique identifier for the submission for logging purposes */
 	submitid = atomic_inc_return(&ident) - 1;
diff --git a/drivers/gpu/drm/msm/msm_submitqueue.c b/drivers/gpu/drm/msm/msm_submitqueue.c
index a1d94be78..da78c924e 100644
--- a/drivers/gpu/drm/msm/msm_submitqueue.c
+++ b/drivers/gpu/drm/msm/msm_submitqueue.c
@@ -146,7 +146,7 @@ int msm_submitqueue_query(struct drm_device *drm, struct msm_file_private *ctx,
 
 	queue = msm_submitqueue_get(ctx, args->id);
 	if (!queue)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (args->param == MSM_SUBMITQUEUE_PARAM_FAULTS)
 		ret = msm_submitqueue_query_faults(queue, args);
@@ -168,7 +168,7 @@ int msm_submitqueue_remove(struct msm_file_private *ctx, u32 id)
 	 * by the user
 	 */
 	if (!id)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	write_lock(&ctx->queuelock);
 
@@ -183,6 +183,6 @@ int msm_submitqueue_remove(struct msm_file_private *ctx, u32 id)
 	}
 
 	write_unlock(&ctx->queuelock);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
diff --git a/drivers/gpu/drm/nouveau/dispnv04/crtc.c b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
index 2de589caf..456ec73f5 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/crtc.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
@@ -1000,7 +1000,7 @@ nv04_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,
 
 	gem = drm_gem_object_lookup(file_priv, buffer_handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	cursor = nouveau_gem_object(gem);
 
 	ret = nouveau_bo_map(cursor);
diff --git a/drivers/gpu/drm/nouveau/dispnv04/hw.c b/drivers/gpu/drm/nouveau/dispnv04/hw.c
index b674d68ef..0e76221ff 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/hw.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/hw.c
@@ -173,7 +173,7 @@ nouveau_hw_get_pllvals(struct drm_device *dev, enum nvbios_pll_type plltype,
 
 	ret = nvbios_pll_parse(bios, plltype, &pll_lim);
 	if (ret || !(reg1 = pll_lim.reg))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pll1 = nvif_rd32(device, reg1);
 	if (reg1 <= 0x405c)
diff --git a/drivers/gpu/drm/nouveau/nouveau_bios.c b/drivers/gpu/drm/nouveau/nouveau_bios.c
index d204ea8a5..3ae568c03 100644
--- a/drivers/gpu/drm/nouveau/nouveau_bios.c
+++ b/drivers/gpu/drm/nouveau/nouveau_bios.c
@@ -190,14 +190,14 @@ static int run_lvds_table(struct drm_device *dev, struct dcb_output *dcbent, int
 		clktable = ROM16(bios->data[clktable]);
 		if (!clktable) {
 			NV_ERROR(drm, "Pixel clock comparison table not found\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		scriptptr = clkcmptable(bios, clktable, pxclk);
 	}
 
 	if (!scriptptr) {
 		NV_ERROR(drm, "LVDS output init script not found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	run_digital_op_script(dev, scriptptr, dcbent, head, bios->fp.dual_link);
 
@@ -418,7 +418,7 @@ static int parse_fp_mode_table(struct drm_device *dev, struct nvbios *bios)
 
 	if (fpindex > fpentries) {
 		NV_ERROR(drm, "Bad flat panel table index\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* nv4x cards need both a strap value and fpindex of 0xf to use DDC */
@@ -663,7 +663,7 @@ int run_tmds_table(struct drm_device *dev, struct dcb_output *dcbent, int head,
 
 	if (!scriptptr) {
 		NV_ERROR(drm, "TMDS output init script not found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* don't let script change pll->head binding */
@@ -991,7 +991,7 @@ bit_table(struct drm_device *dev, u8 id, struct bit_entry *bit)
 		entry += bios->data[bios->offset + 9];
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int
@@ -1926,7 +1926,7 @@ static int load_nv17_hwsq_ucode_entry(struct drm_device *dev, struct nvbios *bio
 	if (bios->data[hwsq_offset] <= entry) {
 		NV_ERROR(drm, "Too few entries in HW sequencer table for "
 				"requested entry\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bytes_to_write = bios->data[hwsq_offset + 1];
diff --git a/drivers/gpu/drm/nouveau/nouveau_display.c b/drivers/gpu/drm/nouveau/nouveau_display.c
index 496c4621c..4376ea7cf 100644
--- a/drivers/gpu/drm/nouveau/nouveau_display.c
+++ b/drivers/gpu/drm/nouveau/nouveau_display.c
@@ -827,5 +827,5 @@ nouveau_display_dumb_map_offset(struct drm_file *file_priv,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
diff --git a/drivers/gpu/drm/nouveau/nouveau_gem.c b/drivers/gpu/drm/nouveau/nouveau_gem.c
index 4c3f131ad..e2e77ce79 100644
--- a/drivers/gpu/drm/nouveau/nouveau_gem.c
+++ b/drivers/gpu/drm/nouveau/nouveau_gem.c
@@ -918,7 +918,7 @@ nouveau_gem_ioctl_cpu_prep(struct drm_device *dev, void *data,
 
 	gem = drm_gem_object_lookup(file_priv, req->handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	nvbo = nouveau_gem_object(gem);
 
 	lret = dma_resv_wait_timeout_rcu(nvbo->bo.base.resv, write, true,
@@ -946,7 +946,7 @@ nouveau_gem_ioctl_cpu_fini(struct drm_device *dev, void *data,
 
 	gem = drm_gem_object_lookup(file_priv, req->handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	nvbo = nouveau_gem_object(gem);
 
 	nouveau_bo_sync_for_device(nvbo);
@@ -964,7 +964,7 @@ nouveau_gem_ioctl_info(struct drm_device *dev, void *data,
 
 	gem = drm_gem_object_lookup(file_priv, req->handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = nouveau_gem_info(file_priv, gem, req);
 	drm_gem_object_put_unlocked(gem);
diff --git a/drivers/gpu/drm/nouveau/nouveau_usif.c b/drivers/gpu/drm/nouveau/nouveau_usif.c
index 9dc10b17a..adce11c39 100644
--- a/drivers/gpu/drm/nouveau/nouveau_usif.c
+++ b/drivers/gpu/drm/nouveau/nouveau_usif.c
@@ -176,7 +176,7 @@ usif_notify_del(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)
 
 	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		if (!(ntfy = usif_notify_find(f, args->v0.index)))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else
 		return ret;
 
@@ -199,7 +199,7 @@ usif_notify_get(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)
 
 	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		if (!(ntfy = usif_notify_find(f, args->v0.index)))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else
 		return ret;
 
@@ -236,7 +236,7 @@ usif_notify_put(struct drm_file *f, void *data, u32 size, void *argv, u32 argc)
 
 	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		if (!(ntfy = usif_notify_find(f, args->v0.index)))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else
 		return ret;
 
diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index ac6712029..4dddb3683 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -95,7 +95,7 @@ nvkm_client_notify_put(struct nvkm_client *client, int index)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int
@@ -107,7 +107,7 @@ nvkm_client_notify_get(struct nvkm_client *client, int index)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int
@@ -121,7 +121,7 @@ nvkm_client_notify_del(struct nvkm_client *client, int index)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int
diff --git a/drivers/gpu/drm/nouveau/nvkm/core/firmware.c b/drivers/gpu/drm/nouveau/nvkm/core/firmware.c
index 8b2536791..9b0e8a286 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/firmware.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/firmware.c
@@ -95,7 +95,7 @@ nvkm_firmware_get(const struct nvkm_subdev *subdev, const char *fwname, int ver,
 	}
 
 	nvkm_debug(subdev, "firmware \"%s\" unavailable\n", f);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
index f2f5636ef..de2ee43bd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
@@ -2469,7 +2469,7 @@ gf100_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)
 	    gf100_gr_load_fw(gr, "fuc409d", &gr->fecs.data) ||
 	    gf100_gr_load_fw(gr, "fuc41ac", &gr->gpccs.inst) ||
 	    gf100_gr_load_fw(gr, "fuc41ad", &gr->gpccs.data))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	gr->firmware = true;
 	return 0;
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gk20a.c
index e56880f3e..f6845f9b5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gk20a.c
@@ -314,7 +314,7 @@ gk20a_gr_load_sw(struct gf100_gr *gr, const char *path, int ver)
 	    gk20a_gr_aiv_to_init(gr, path, "sw_ctx", ver, &gr->sw_ctx) ||
 	    gk20a_gr_av_to_init(gr, path, "sw_bundle_init", ver, &gr->bundle) ||
 	    gk20a_gr_av_to_method(gr, path, "sw_method_init", ver, &gr->method))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -343,7 +343,7 @@ gk20a_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)
 				    &gr->gpccs.inst) ||
 	    nvkm_firmware_load_blob(subdev, "", "gpccs_data", ver,
 				    &gr->gpccs.data))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	gr->firmware = true;
 
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 09d8c5d5b..dc06649d8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -153,7 +153,7 @@ gm20b_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)
 				    &gr->gpccs.inst) ||
 	    nvkm_firmware_load_blob(subdev, "gr/", "gpccs_data", ver,
 				    &gr->gpccs.data))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	gr->firmware = true;
 
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/bit.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/bit.c
index 070ff33f8..6d5ca88a4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/bit.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/bit.c
@@ -42,7 +42,7 @@ bit_entry(struct nvkm_bios *bios, u8 id, struct bit_entry *bit)
 			entry += nvbios_rd08(bios, bios->bit_offset + 9);
 		}
 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return -EINVAL;
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/i2c.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/i2c.c
index 0fc60be32..c7226db3d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/i2c.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/i2c.c
@@ -160,5 +160,5 @@ dcb_i2c_parse(struct nvkm_bios *bios, u8 idx, struct dcb_i2c_entry *info)
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/pll.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/pll.c
index bda6cc9a7..637af729a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/pll.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/pll.c
@@ -244,7 +244,7 @@ nvbios_pll_parse(struct nvkm_bios *bios, u32 type, struct nvbios_pll *info)
 	}
 
 	if (ver && !data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memset(info, 0, sizeof(*info));
 	info->type = type;
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 40e564524..8258e7f6a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -232,7 +232,7 @@ nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 
 	data = nvbios_cstepXp(bios, idx, &ver, &hdr, &cstepX);
 	if (!data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (volt && nvkm_volt_map_min(volt, cstepX.voltage) > volt->max_uv)
 		return -EINVAL;
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
index d350d9285..73310413e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c
@@ -1282,7 +1282,7 @@ gk104_ram_train_type(struct nvkm_ram *ram, int i, u8 ramcfg,
 
 	/* determine type of data for this index */
 	if (!(data = nvbios_M0205Ep(bios, i, &ver, &hdr, &cnt, &len, &M0205E)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (M0205E.type) {
 	case 0x00: value = &train->type00; break;
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c
index bbfde1cb3..0772a0a53 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c
@@ -181,7 +181,7 @@ gt215_link_train(struct gt215_ram *ram)
 	nvbios_M0205Tp(bios, &ver, &hdr, &cnt, &len, &snr, &ssz, &M0205T);
 	if (M0205T.freq == 0) {
 		kfree(result);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	clk_current = nvkm_clk_read(clk, nv_clk_src_mem);
@@ -291,7 +291,7 @@ gt215_link_train_init(struct gt215_ram *ram)
 	/* We support type "5"
 	 * XXX: training pattern table appears to be unused for this routine */
 	if (!nvbios_M0205Ep(bios, i, &ver, &hdr, &cnt, &len, &M0205E))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (M0205E.type != 5)
 		return 0;
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c
index 914276410..75e21df00 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c
@@ -74,7 +74,7 @@ nvkm_gpio_find(struct nvkm_gpio *gpio, int idx, u8 tag, u8 line,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c
index c43b8248c..747ef82b1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c
@@ -60,7 +60,7 @@ nvkm_uvmm_mthd_pfnclr(struct nvkm_uvmm *uvmm, void *argv, u32 argc)
 		return ret;
 
 	if (!client->super)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (size) {
 		mutex_lock(&vmm->mutex);
@@ -94,7 +94,7 @@ nvkm_uvmm_mthd_pfnmap(struct nvkm_uvmm *uvmm, void *argv, u32 argc)
 		return ret;
 
 	if (!client->super)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (size) {
 		mutex_lock(&vmm->mutex);
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c
index 199f94e15..2309cff58 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c
@@ -1233,7 +1233,7 @@ nvkm_vmm_pfn_map(struct nvkm_vmm *vmm, u8 shift, u64 addr, u64 size, u64 *pfn)
 	}
 
 	if (!(vma = nvkm_vmm_node_search(vmm, addr)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	do {
 		bool map = !!(pfn[pi] & NVKM_VMM_PFN_V);
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mxm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mxm/base.c
index f44682d62..5adce60d8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mxm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mxm/base.c
@@ -222,7 +222,7 @@ mxm_shadow(struct nvkm_mxm *mxm, u8 version)
 			mxm->mxms = NULL;
 		}
 	} while ((++shadow)->name);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct nvkm_subdev_func
diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
index cce6e4e90..b4cca3e3c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
@@ -122,7 +122,7 @@ nvkm_top_fault_id(struct nvkm_device *device, enum nvkm_devidx devidx)
 			return info->fault;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 enum nvkm_devidx
diff --git a/drivers/gpu/drm/omapdrm/omap_drv.c b/drivers/gpu/drm/omapdrm/omap_drv.c
index cdafd7ef1..abdc777aa 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.c
+++ b/drivers/gpu/drm/omapdrm/omap_drv.c
@@ -498,7 +498,7 @@ static int ioctl_gem_info(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	args->size = omap_gem_mmap_size(obj);
 	args->offset = omap_gem_mmap_offset(obj);
diff --git a/drivers/gpu/drm/panfrost/panfrost_drv.c b/drivers/gpu/drm/panfrost/panfrost_drv.c
index 882fecc33..fc033f8ad 100644
--- a/drivers/gpu/drm/panfrost/panfrost_drv.c
+++ b/drivers/gpu/drm/panfrost/panfrost_drv.c
@@ -310,7 +310,7 @@ panfrost_ioctl_wait_bo(struct drm_device *dev, void *data,
 
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = dma_resv_wait_timeout_rcu(gem_obj->resv, true,
 						  true, timeout);
@@ -337,7 +337,7 @@ static int panfrost_ioctl_mmap_bo(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Don't allow mmapping of heap objects as pages are not pinned. */
@@ -367,7 +367,7 @@ static int panfrost_ioctl_get_bo_offset(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	bo = to_panfrost_bo(gem_obj);
 
@@ -395,7 +395,7 @@ static int panfrost_ioctl_madvise(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bo = to_panfrost_bo(gem_obj);
diff --git a/drivers/gpu/drm/panfrost/panfrost_mmu.c b/drivers/gpu/drm/panfrost/panfrost_mmu.c
index ed28aeba6..e3e902d7a 100644
--- a/drivers/gpu/drm/panfrost/panfrost_mmu.c
+++ b/drivers/gpu/drm/panfrost/panfrost_mmu.c
@@ -456,7 +456,7 @@ static int panfrost_mmu_map_fault_addr(struct panfrost_device *pfdev, int as,
 
 	bomapping = addr_to_mapping(pfdev, as, addr);
 	if (!bomapping)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bo = bomapping->obj;
 	if (!bo->is_heap) {
diff --git a/drivers/gpu/drm/qxl/qxl_dumb.c b/drivers/gpu/drm/qxl/qxl_dumb.c
index 24e903383..399844340 100644
--- a/drivers/gpu/drm/qxl/qxl_dumb.c
+++ b/drivers/gpu/drm/qxl/qxl_dumb.c
@@ -80,7 +80,7 @@ int qxl_mode_dumb_mmap(struct drm_file *file_priv,
 	BUG_ON(!offset_p);
 	gobj = drm_gem_object_lookup(file_priv, handle);
 	if (gobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	qobj = gem_to_qxl_bo(gobj);
 	*offset_p = qxl_bo_mmap_offset(qobj);
 	drm_gem_object_put_unlocked(gobj);
diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c
index 13bd1d11c..6a84ffc6c 100644
--- a/drivers/gpu/drm/qxl/qxl_ioctl.c
+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c
@@ -318,7 +318,7 @@ static int qxl_update_area_ioctl(struct drm_device *dev, void *data,
 
 	gobj = drm_gem_object_lookup(file, update_area->handle);
 	if (gobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	qobj = gem_to_qxl_bo(gobj);
 
diff --git a/drivers/gpu/drm/radeon/ci_dpm.c b/drivers/gpu/drm/radeon/ci_dpm.c
index f434efdec..02d1b18bc 100644
--- a/drivers/gpu/drm/radeon/ci_dpm.c
+++ b/drivers/gpu/drm/radeon/ci_dpm.c
@@ -1064,7 +1064,7 @@ int ci_fan_ctrl_get_fan_speed_percent(struct radeon_device *rdev,
 	u64 tmp64;
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	duty100 = (RREG32_SMC(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;
 	duty = (RREG32_SMC(CG_THERMAL_STATUS) & FDO_PWM_DUTY_MASK) >> FDO_PWM_DUTY_SHIFT;
@@ -1091,7 +1091,7 @@ int ci_fan_ctrl_set_fan_speed_percent(struct radeon_device *rdev,
 	struct ci_power_info *pi = ci_get_pi(rdev);
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (pi->fan_is_controlled_by_smc)
 		return -EINVAL;
@@ -1151,14 +1151,14 @@ static int ci_fan_ctrl_get_fan_speed_rpm(struct radeon_device *rdev,
 	u32 xclk = radeon_get_xclk(rdev);
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (rdev->pm.fan_pulses_per_revolution == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tach_period = (RREG32_SMC(CG_TACH_STATUS) & TACH_PERIOD_MASK) >> TACH_PERIOD_SHIFT;
 	if (tach_period == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*speed = 60 * xclk * 10000 / tach_period;
 
@@ -1172,10 +1172,10 @@ static int ci_fan_ctrl_set_fan_speed_rpm(struct radeon_device *rdev,
 	u32 xclk = radeon_get_xclk(rdev);
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (rdev->pm.fan_pulses_per_revolution == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((speed < rdev->pm.fan_min_rpm) ||
 	    (speed > rdev->pm.fan_max_rpm))
diff --git a/drivers/gpu/drm/radeon/r100.c b/drivers/gpu/drm/radeon/r100.c
index 24c8db673..f9a2565b9 100644
--- a/drivers/gpu/drm/radeon/r100.c
+++ b/drivers/gpu/drm/radeon/r100.c
@@ -1465,7 +1465,7 @@ int r100_cs_packet_parse_vline(struct radeon_cs_parser *p)
 	crtc = drm_crtc_find(p->rdev->ddev, p->filp, crtc_id);
 	if (!crtc) {
 		DRM_ERROR("cannot find crtc %d\n", crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	radeon_crtc = to_radeon_crtc(crtc);
 	crtc_id = radeon_crtc->crtc_id;
diff --git a/drivers/gpu/drm/radeon/r600_cs.c b/drivers/gpu/drm/radeon/r600_cs.c
index 49e826646..b8f01faf8 100644
--- a/drivers/gpu/drm/radeon/r600_cs.c
+++ b/drivers/gpu/drm/radeon/r600_cs.c
@@ -888,7 +888,7 @@ int r600_cs_common_vline_parse(struct radeon_cs_parser *p,
 	crtc = drm_crtc_find(p->rdev->ddev, p->filp, crtc_id);
 	if (!crtc) {
 		DRM_ERROR("cannot find crtc %d\n", crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	radeon_crtc = to_radeon_crtc(crtc);
 	crtc_id = radeon_crtc->crtc_id;
diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c
index cc31d1870..19d96d517 100644
--- a/drivers/gpu/drm/radeon/radeon_cs.c
+++ b/drivers/gpu/drm/radeon/radeon_cs.c
@@ -111,7 +111,7 @@ static int radeon_cs_parser_relocs(struct radeon_cs_parser *p)
 		if (gobj == NULL) {
 			DRM_ERROR("gem object lookup failed 0x%x\n",
 				  r->handle);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		p->relocs[i].robj = gem_to_radeon_bo(gobj);
 
diff --git a/drivers/gpu/drm/radeon/radeon_cursor.c b/drivers/gpu/drm/radeon/radeon_cursor.c
index 9180bb51b..9f2af05dc 100644
--- a/drivers/gpu/drm/radeon/radeon_cursor.c
+++ b/drivers/gpu/drm/radeon/radeon_cursor.c
@@ -303,7 +303,7 @@ int radeon_crtc_cursor_set2(struct drm_crtc *crtc,
 	obj = drm_gem_object_lookup(file_priv, handle);
 	if (!obj) {
 		DRM_ERROR("Cannot find cursor object %x for crtc %d\n", handle, radeon_crtc->crtc_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	robj = gem_to_radeon_bo(obj);
diff --git a/drivers/gpu/drm/radeon/radeon_fence.c b/drivers/gpu/drm/radeon/radeon_fence.c
index 43f2f9307..1a624964a 100644
--- a/drivers/gpu/drm/radeon/radeon_fence.c
+++ b/drivers/gpu/drm/radeon/radeon_fence.c
@@ -629,7 +629,7 @@ int radeon_fence_wait_any(struct radeon_device *rdev,
 
 	/* nothing to wait for ? */
 	if (num_rings == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	r = radeon_fence_wait_seq_timeout(rdev, seq, intr, MAX_SCHEDULE_TIMEOUT);
 	if (r < 0) {
@@ -657,7 +657,7 @@ int radeon_fence_wait_next(struct radeon_device *rdev, int ring)
 	if (seq[ring] >= rdev->fence_drv[ring].sync_seq[ring]) {
 		/* nothing to wait for, last_seq is
 		   already the last emited fence */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	r = radeon_fence_wait_seq_timeout(rdev, seq, false, MAX_SCHEDULE_TIMEOUT);
 	if (r < 0)
diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c
index 3c8f570a2..a6e3a3ebe 100644
--- a/drivers/gpu/drm/radeon/radeon_gem.c
+++ b/drivers/gpu/drm/radeon/radeon_gem.c
@@ -396,7 +396,7 @@ int radeon_gem_set_domain_ioctl(struct drm_device *dev, void *data,
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL) {
 		up_read(&rdev->exclusive_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_radeon_bo(gobj);
 
@@ -417,7 +417,7 @@ int radeon_mode_dumb_mmap(struct drm_file *filp,
 
 	gobj = drm_gem_object_lookup(filp, handle);
 	if (gobj == NULL) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_radeon_bo(gobj);
 	if (radeon_ttm_tt_has_userptr(robj->tbo.ttm)) {
@@ -448,7 +448,7 @@ int radeon_gem_busy_ioctl(struct drm_device *dev, void *data,
 
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_radeon_bo(gobj);
 
@@ -477,7 +477,7 @@ int radeon_gem_wait_idle_ioctl(struct drm_device *dev, void *data,
 
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_radeon_bo(gobj);
 
@@ -508,7 +508,7 @@ int radeon_gem_set_tiling_ioctl(struct drm_device *dev, void *data,
 	DRM_DEBUG("%d \n", args->handle);
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	robj = gem_to_radeon_bo(gobj);
 	r = radeon_bo_set_tiling_flags(robj, args->tiling_flags, args->pitch);
 	drm_gem_object_put_unlocked(gobj);
@@ -526,7 +526,7 @@ int radeon_gem_get_tiling_ioctl(struct drm_device *dev, void *data,
 	DRM_DEBUG("\n");
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	rbo = gem_to_radeon_bo(gobj);
 	r = radeon_bo_reserve(rbo, false);
 	if (unlikely(r != 0))
@@ -662,7 +662,7 @@ int radeon_gem_va_ioctl(struct drm_device *dev, void *data,
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL) {
 		args->operation = RADEON_VA_RESULT_ERROR;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	rbo = gem_to_radeon_bo(gobj);
 	r = radeon_bo_reserve(rbo, false);
@@ -676,7 +676,7 @@ int radeon_gem_va_ioctl(struct drm_device *dev, void *data,
 		args->operation = RADEON_VA_RESULT_ERROR;
 		radeon_bo_unreserve(rbo);
 		drm_gem_object_put_unlocked(gobj);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	switch (args->operation) {
@@ -716,7 +716,7 @@ int radeon_gem_op_ioctl(struct drm_device *dev, void *data,
 
 	gobj = drm_gem_object_lookup(filp, args->handle);
 	if (gobj == NULL) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	robj = gem_to_radeon_bo(gobj);
 
diff --git a/drivers/gpu/drm/radeon/radeon_uvd.c b/drivers/gpu/drm/radeon/radeon_uvd.c
index 1ad5c3b86..8eb164e05 100644
--- a/drivers/gpu/drm/radeon/radeon_uvd.c
+++ b/drivers/gpu/drm/radeon/radeon_uvd.c
@@ -550,7 +550,7 @@ static int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,
 		}
 
 		DRM_ERROR("Invalid UVD handle 0x%x!\n", handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	case 2:
 		/* it's a destroy msg, free the handle */
diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c
index a167e1c36..e3c7c0dd2 100644
--- a/drivers/gpu/drm/radeon/si_dpm.c
+++ b/drivers/gpu/drm/radeon/si_dpm.c
@@ -6119,7 +6119,7 @@ int si_fan_ctrl_get_fan_speed_percent(struct radeon_device *rdev,
 	u64 tmp64;
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	duty100 = (RREG32(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;
 	duty = (RREG32(CG_THERMAL_STATUS) & FDO_PWM_DUTY_MASK) >> FDO_PWM_DUTY_SHIFT;
@@ -6146,7 +6146,7 @@ int si_fan_ctrl_set_fan_speed_percent(struct radeon_device *rdev,
 	u64 tmp64;
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (si_pi->fan_is_controlled_by_smc)
 		return -EINVAL;
@@ -6206,14 +6206,14 @@ static int si_fan_ctrl_get_fan_speed_rpm(struct radeon_device *rdev,
 	u32 xclk = radeon_get_xclk(rdev);
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (rdev->pm.fan_pulses_per_revolution == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tach_period = (RREG32(CG_TACH_STATUS) & TACH_PERIOD_MASK) >> TACH_PERIOD_SHIFT;
 	if (tach_period == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*speed = 60 * xclk * 10000 / tach_period;
 
@@ -6227,10 +6227,10 @@ static int si_fan_ctrl_set_fan_speed_rpm(struct radeon_device *rdev,
 	u32 xclk = radeon_get_xclk(rdev);
 
 	if (rdev->pm.no_fan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (rdev->pm.fan_pulses_per_revolution == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((speed < rdev->pm.fan_min_rpm) ||
 	    (speed > rdev->pm.fan_max_rpm))
diff --git a/drivers/gpu/drm/scheduler/sched_main.c b/drivers/gpu/drm/scheduler/sched_main.c
index 2f319102a..d4ee39364 100644
--- a/drivers/gpu/drm/scheduler/sched_main.c
+++ b/drivers/gpu/drm/scheduler/sched_main.c
@@ -551,7 +551,7 @@ int drm_sched_job_init(struct drm_sched_job *job,
 
 	drm_sched_entity_select_rq(entity);
 	if (!entity->rq)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	sched = entity->rq->sched;
 
diff --git a/drivers/gpu/drm/stm/drv.c b/drivers/gpu/drm/stm/drv.c
index 0f85dd86c..a10533a11 100644
--- a/drivers/gpu/drm/stm/drv.c
+++ b/drivers/gpu/drm/stm/drv.c
@@ -148,7 +148,7 @@ static __maybe_unused int drv_resume(struct device *dev)
 	int ret;
 
 	if (WARN_ON(!ldev->suspend_state))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pm_runtime_force_resume(dev);
 	ret = drm_atomic_helper_resume(ddev, ldev->suspend_state);
diff --git a/drivers/gpu/drm/tegra/drm.c b/drivers/gpu/drm/tegra/drm.c
index 211906347..6de15a0c8 100644
--- a/drivers/gpu/drm/tegra/drm.c
+++ b/drivers/gpu/drm/tegra/drm.c
@@ -149,11 +149,11 @@ static int host1x_reloc_copy_from_user(struct host1x_reloc *dest,
 
 	dest->cmdbuf.bo = host1x_bo_lookup(file, cmdbuf);
 	if (!dest->cmdbuf.bo)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dest->target.bo = host1x_bo_lookup(file, target);
 	if (!dest->target.bo)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -629,7 +629,7 @@ static int tegra_gem_set_tiling(struct drm_device *drm, void *data,
 
 	gem = drm_gem_object_lookup(file, args->handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bo = to_tegra_bo(gem);
 
@@ -651,7 +651,7 @@ static int tegra_gem_get_tiling(struct drm_device *drm, void *data,
 
 	gem = drm_gem_object_lookup(file, args->handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bo = to_tegra_bo(gem);
 
@@ -693,7 +693,7 @@ static int tegra_gem_set_flags(struct drm_device *drm, void *data,
 
 	gem = drm_gem_object_lookup(file, args->handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bo = to_tegra_bo(gem);
 	bo->flags = 0;
@@ -715,7 +715,7 @@ static int tegra_gem_get_flags(struct drm_device *drm, void *data,
 
 	gem = drm_gem_object_lookup(file, args->handle);
 	if (!gem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bo = to_tegra_bo(gem);
 	args->flags = 0;
diff --git a/drivers/gpu/drm/v3d/v3d_bo.c b/drivers/gpu/drm/v3d/v3d_bo.c
index edd299ab5..84abddaf0 100644
--- a/drivers/gpu/drm/v3d/v3d_bo.c
+++ b/drivers/gpu/drm/v3d/v3d_bo.c
@@ -204,7 +204,7 @@ int v3d_mmap_bo_ioctl(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	args->offset = drm_vma_node_offset_addr(&gem_obj->vma_node);
@@ -223,7 +223,7 @@ int v3d_get_bo_offset_ioctl(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	bo = to_v3d_bo(gem_obj);
 
diff --git a/drivers/gpu/drm/vc4/vc4_bo.c b/drivers/gpu/drm/vc4/vc4_bo.c
index 72d30d90b..07b5aee1f 100644
--- a/drivers/gpu/drm/vc4/vc4_bo.c
+++ b/drivers/gpu/drm/vc4/vc4_bo.c
@@ -960,7 +960,7 @@ int vc4_set_tiling_ioctl(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	bo = to_vc4_bo(gem_obj);
 	bo->t_format = t_format;
@@ -991,7 +991,7 @@ int vc4_get_tiling_ioctl(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	bo = to_vc4_bo(gem_obj);
 
@@ -1080,7 +1080,7 @@ int vc4_label_bo_ioctl(struct drm_device *dev, void *data,
 	if (!gem_obj) {
 		DRM_ERROR("Failed to look up GEM BO %d\n", args->handle);
 		kfree(name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mutex_lock(&vc4->bo_lock);
diff --git a/drivers/gpu/drm/vc4/vc4_gem.c b/drivers/gpu/drm/vc4/vc4_gem.c
index e1cfc3ccd..8406a1d40 100644
--- a/drivers/gpu/drm/vc4/vc4_gem.c
+++ b/drivers/gpu/drm/vc4/vc4_gem.c
@@ -85,7 +85,7 @@ vc4_get_hang_state_ioctl(struct drm_device *dev, void *data,
 	kernel_state = vc4->hang_state;
 	if (!kernel_state) {
 		spin_unlock_irqrestore(&vc4->job_lock, irqflags);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	state = &kernel_state->user_state;
 
@@ -1331,7 +1331,7 @@ int vc4_gem_madvise_ioctl(struct drm_device *dev, void *data,
 	gem_obj = drm_gem_object_lookup(file_priv, args->handle);
 	if (!gem_obj) {
 		DRM_DEBUG("Failed to look up GEM BO %d\n", args->handle);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bo = to_vc4_bo(gem_obj);
diff --git a/drivers/gpu/drm/vgem/vgem_drv.c b/drivers/gpu/drm/vgem/vgem_drv.c
index ec1a8ebb6..7bed3a8aa 100644
--- a/drivers/gpu/drm/vgem/vgem_drv.c
+++ b/drivers/gpu/drm/vgem/vgem_drv.c
@@ -238,7 +238,7 @@ static int vgem_gem_dumb_map(struct drm_file *file, struct drm_device *dev,
 
 	obj = drm_gem_object_lookup(file, handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!obj->filp) {
 		ret = -EINVAL;
diff --git a/drivers/gpu/drm/vgem/vgem_fence.c b/drivers/gpu/drm/vgem/vgem_fence.c
index 9268f6fc3..ddaf4f682 100644
--- a/drivers/gpu/drm/vgem/vgem_fence.c
+++ b/drivers/gpu/drm/vgem/vgem_fence.c
@@ -141,7 +141,7 @@ int vgem_fence_attach_ioctl(struct drm_device *dev,
 
 	obj = drm_gem_object_lookup(file, arg->handle);
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	fence = vgem_fence_create(vfile, arg->flags);
 	if (!fence) {
@@ -218,7 +218,7 @@ int vgem_fence_signal_ioctl(struct drm_device *dev,
 	fence = idr_replace(&vfile->fence_idr, NULL, arg->fence);
 	mutex_unlock(&vfile->fence_mutex);
 	if (!fence)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (IS_ERR(fence))
 		return PTR_ERR(fence);
 
diff --git a/drivers/gpu/drm/virtio/virtgpu_gem.c b/drivers/gpu/drm/virtio/virtgpu_gem.c
index d6cb350ae..5669c6743 100644
--- a/drivers/gpu/drm/virtio/virtgpu_gem.c
+++ b/drivers/gpu/drm/virtio/virtgpu_gem.c
@@ -103,7 +103,7 @@ int virtio_gpu_mode_dumb_mmap(struct drm_file *file_priv,
 	BUG_ON(!offset_p);
 	gobj = drm_gem_object_lookup(file_priv, handle);
 	if (gobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*offset_p = drm_vma_node_offset_addr(&gobj->vma_node);
 	drm_gem_object_put_unlocked(gobj);
 	return 0;
diff --git a/drivers/gpu/drm/virtio/virtgpu_ioctl.c b/drivers/gpu/drm/virtio/virtgpu_ioctl.c
index 5df722072..9332e7c34 100644
--- a/drivers/gpu/drm/virtio/virtgpu_ioctl.c
+++ b/drivers/gpu/drm/virtio/virtgpu_ioctl.c
@@ -294,7 +294,7 @@ static int virtio_gpu_resource_info_ioctl(struct drm_device *dev, void *data,
 
 	gobj = drm_gem_object_lookup(file, ri->bo_handle);
 	if (gobj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	qobj = gem_to_virtio_gpu_obj(gobj);
 
@@ -322,7 +322,7 @@ static int virtio_gpu_transfer_from_host_ioctl(struct drm_device *dev,
 	virtio_gpu_create_context(dev, file);
 	objs = virtio_gpu_array_from_handles(file, &args->bo_handle, 1);
 	if (objs == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = virtio_gpu_array_lock_resv(objs);
 	if (ret != 0)
@@ -360,7 +360,7 @@ static int virtio_gpu_transfer_to_host_ioctl(struct drm_device *dev, void *data,
 
 	objs = virtio_gpu_array_from_handles(file, &args->bo_handle, 1);
 	if (objs == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!vgdev->has_virgl_3d) {
 		virtio_gpu_cmd_transfer_to_host_2d
@@ -404,7 +404,7 @@ static int virtio_gpu_wait_ioctl(struct drm_device *dev, void *data,
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (obj == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (args->flags & VIRTGPU_WAIT_NOWAIT) {
 		ret = dma_resv_test_signaled_rcu(obj->resv, true);
diff --git a/drivers/hid/hid-logitech-hidpp.c b/drivers/hid/hid-logitech-hidpp.c
index b8b53dc95..d79ced172 100644
--- a/drivers/hid/hid-logitech-hidpp.c
+++ b/drivers/hid/hid-logitech-hidpp.c
@@ -866,7 +866,7 @@ static int hidpp_root_get_feature(struct hidpp_device *hidpp, u16 feature,
 		return ret;
 
 	if (response.fap.params[0] == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*feature_index = response.fap.params[0];
 	*feature_type = response.fap.params[1];
@@ -3431,7 +3431,7 @@ static int hidpp_initialize_battery(struct hidpp_device *hidpp)
 		if (ret) {
 			ret = hidpp10_query_battery_mileage(hidpp);
 			if (ret)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			hidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_MILEAGE;
 		} else {
 			hidpp->capabilities |= HIDPP_CAPABILITY_BATTERY_LEVEL_STATUS;
diff --git a/drivers/hid/hid-prodikeys.c b/drivers/hid/hid-prodikeys.c
index 2666af02d..c8ea869a6 100644
--- a/drivers/hid/hid-prodikeys.c
+++ b/drivers/hid/hid-prodikeys.c
@@ -617,7 +617,7 @@ static int pcmidi_snd_initialise(struct pcmidi_snd *pm)
 
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Setup sound card */
diff --git a/drivers/hid/intel-ish-hid/ishtp-hid-client.c b/drivers/hid/intel-ish-hid/ishtp-hid-client.c
index 6ba944b40..b5f955222 100644
--- a/drivers/hid/intel-ish-hid/ishtp-hid-client.c
+++ b/drivers/hid/intel-ish-hid/ishtp-hid-client.c
@@ -661,7 +661,7 @@ static int hid_ishtp_cl_init(struct ishtp_cl *hid_ishtp_cl, int reset)
 	if (!fw_client) {
 		dev_err(cl_data_to_dev(client_data),
 			"ish client uuid not found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	ishtp_cl_set_fw_client_id(hid_ishtp_cl,
 				  ishtp_get_fw_client_id(fw_client));
diff --git a/drivers/hid/intel-ish-hid/ishtp/bus.c b/drivers/hid/intel-ish-hid/ishtp/bus.c
index c47c3328a..ff5de550b 100644
--- a/drivers/hid/intel-ish-hid/ishtp/bus.c
+++ b/drivers/hid/intel-ish-hid/ishtp/bus.c
@@ -133,7 +133,7 @@ int ishtp_fw_cl_by_uuid(struct ishtp_device *dev, const guid_t *uuid)
 		if (guid_equal(uuid, &dev->fw_clients[i].props.protocol_name))
 			return i;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(ishtp_fw_cl_by_uuid);
 
diff --git a/drivers/hid/intel-ish-hid/ishtp/client.c b/drivers/hid/intel-ish-hid/ishtp/client.c
index 1cc157126..6142697fe 100644
--- a/drivers/hid/intel-ish-hid/ishtp/client.c
+++ b/drivers/hid/intel-ish-hid/ishtp/client.c
@@ -190,7 +190,7 @@ int ishtp_cl_link(struct ishtp_cl *cl)
 	if (id >= ISHTP_CLIENTS_MAX) {
 		spin_unlock_irqrestore(&dev->device_lock, flags);
 		dev_err(&cl->device->dev, "id exceeded %d", ISHTP_CLIENTS_MAX);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	dev->open_handle_count++;
@@ -552,7 +552,7 @@ int ishtp_cl_send(struct ishtp_cl *cl, uint8_t *buf, size_t length)
 	id = ishtp_fw_cl_by_id(dev, cl->fw_client_id);
 	if (id < 0) {
 		++cl->err_send_msg;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (length > dev->fw_clients[id].props.max_msg_length) {
diff --git a/drivers/hsi/hsi_core.c b/drivers/hsi/hsi_core.c
index 47f0208aa..b191202bc 100644
--- a/drivers/hsi/hsi_core.c
+++ b/drivers/hsi/hsi_core.c
@@ -740,7 +740,7 @@ int hsi_get_channel_id_by_name(struct hsi_client *cl, char *name)
 	int i;
 
 	if (!cl->rx_cfg.channels)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < cl->rx_cfg.num_channels; i++)
 		if (!strcmp(cl->rx_cfg.channels[i].name, name))
diff --git a/drivers/hwmon/ibmaem.c b/drivers/hwmon/ibmaem.c
index a4ec85207..d99b2813e 100644
--- a/drivers/hwmon/ibmaem.c
+++ b/drivers/hwmon/ibmaem.c
@@ -514,7 +514,7 @@ static int aem_find_aem1_count(struct aem_ipmi_data *data)
 
 	if (data->rx_result || data->rx_msg_len != sizeof(ff_resp) ||
 	    memcmp(&ff_resp.id, &system_x_id, sizeof(system_x_id)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ff_resp.num_instances;
 }
@@ -653,7 +653,7 @@ static int aem_find_aem2(struct aem_ipmi_data *data,
 	if (data->rx_result || data->rx_msg_len != sizeof(*fi_resp) ||
 	    memcmp(&fi_resp->id, &system_x_id, sizeof(system_x_id)) ||
 	    fi_resp->num_instances <= instance_num)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/hwmon/ibmpex.c b/drivers/hwmon/ibmpex.c
index b2ab83c9f..e1a2c026c 100644
--- a/drivers/hwmon/ibmpex.c
+++ b/drivers/hwmon/ibmpex.c
@@ -140,7 +140,7 @@ static int ibmpex_ver_check(struct ibmpex_bmc_data *data)
 	wait_for_completion(&data->read_complete);
 
 	if (data->rx_result || data->rx_msg_len != 6)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	data->sensor_major = data->rx_msg_data[0];
 	data->sensor_minor = data->rx_msg_data[1];
@@ -166,7 +166,7 @@ static int ibmpex_query_sensor_count(struct ibmpex_bmc_data *data)
 	wait_for_completion(&data->read_complete);
 
 	if (data->rx_result || data->rx_msg_len != 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return data->rx_msg_data[0];
 }
@@ -181,7 +181,7 @@ static int ibmpex_query_sensor_name(struct ibmpex_bmc_data *data, int sensor)
 	wait_for_completion(&data->read_complete);
 
 	if (data->rx_result || data->rx_msg_len < 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -198,7 +198,7 @@ static int ibmpex_query_sensor_data(struct ibmpex_bmc_data *data, int sensor)
 	if (data->rx_result || data->rx_msg_len < 26) {
 		dev_err(data->bmc_device, "Error reading sensor %d.\n",
 			sensor);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -369,7 +369,7 @@ static int ibmpex_find_sensors(struct ibmpex_bmc_data *data)
 
 	err = ibmpex_query_sensor_count(data);
 	if (err <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	data->num_sensors = err;
 
 	data->sensors = kcalloc(data->num_sensors, sizeof(*data->sensors),
diff --git a/drivers/hwmon/ibmpowernv.c b/drivers/hwmon/ibmpowernv.c
index a750647e6..f5059e0f7 100644
--- a/drivers/hwmon/ibmpowernv.c
+++ b/drivers/hwmon/ibmpowernv.c
@@ -177,7 +177,7 @@ static int get_logical_cpu(int hwcpu)
 		if (get_hard_smp_processor_id(cpu) == hwcpu)
 			return cpu;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void make_sensor_label(struct device_node *np,
diff --git a/drivers/hwmon/pc87427.c b/drivers/hwmon/pc87427.c
index eaab83d87..1b301cd0f 100644
--- a/drivers/hwmon/pc87427.c
+++ b/drivers/hwmon/pc87427.c
@@ -942,7 +942,7 @@ static int pc87427_request_regions(struct platform_device *pdev,
 		res = platform_get_resource(pdev, IORESOURCE_IO, i);
 		if (!res) {
 			dev_err(&pdev->dev, "Missing resource #%d\n", i);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (!devm_request_region(&pdev->dev, res->start,
 					 resource_size(res), DRVNAME)) {
diff --git a/drivers/hwmon/pmbus/ucd9000.c b/drivers/hwmon/pmbus/ucd9000.c
index 81f4c4f16..342d889f2 100644
--- a/drivers/hwmon/pmbus/ucd9000.c
+++ b/drivers/hwmon/pmbus/ucd9000.c
@@ -439,11 +439,11 @@ static int ucd9000_init_debugfs(struct i2c_client *client,
 
 	debugfs = pmbus_get_debugfs_dir(client);
 	if (!debugfs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	data->debugfs = debugfs_create_dir(client->name, debugfs);
 	if (!data->debugfs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Of the chips this driver supports, only the UCD9090, UCD90160,
diff --git a/drivers/hwtracing/coresight/coresight-platform.c b/drivers/hwtracing/coresight/coresight-platform.c
index e4912abda..12b52b863 100644
--- a/drivers/hwtracing/coresight/coresight-platform.c
+++ b/drivers/hwtracing/coresight/coresight-platform.c
@@ -328,7 +328,7 @@ static inline int
 of_get_coresight_platform_data(struct device *dev,
 			       struct coresight_platform_data *pdata)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int of_coresight_get_cpu(struct device *dev)
@@ -687,7 +687,7 @@ static int acpi_coresight_parse_graph(struct acpi_device *adev,
 	pdata->nr_inport = pdata->nr_outport = 0;
 	graph = acpi_get_coresight_graph(adev);
 	if (!graph)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	nlinks = graph->package.elements[2].integer.value;
 	if (!nlinks)
@@ -812,7 +812,7 @@ static inline int
 acpi_get_coresight_platform_data(struct device *dev,
 				 struct coresight_platform_data *pdata)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int acpi_coresight_get_cpu(struct device *dev)
diff --git a/drivers/hwtracing/coresight/coresight-stm.c b/drivers/hwtracing/coresight/coresight-stm.c
index b908ca104..9ad85d081 100644
--- a/drivers/hwtracing/coresight/coresight-stm.c
+++ b/drivers/hwtracing/coresight/coresight-stm.c
@@ -713,7 +713,7 @@ static int of_stm_get_stimulus_area(struct device *dev, struct resource *res)
 static inline int of_stm_get_stimulus_area(struct device *dev,
 					   struct resource *res)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
@@ -759,7 +759,7 @@ static int acpi_stm_get_stimulus_area(struct device *dev, struct resource *res)
 static inline int acpi_stm_get_stimulus_area(struct device *dev,
 					     struct resource *res)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
@@ -771,7 +771,7 @@ static int stm_get_stimulus_area(struct device *dev, struct resource *res)
 		return of_stm_get_stimulus_area(dev, res);
 	else if (is_acpi_node(fwnode))
 		return acpi_stm_get_stimulus_area(dev, res);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static u32 stm_fundamental_data_size(struct stm_drvdata *drvdata)
diff --git a/drivers/hwtracing/coresight/coresight.c b/drivers/hwtracing/coresight/coresight.c
index f3efbb3b2..e6766629d 100644
--- a/drivers/hwtracing/coresight/coresight.c
+++ b/drivers/hwtracing/coresight/coresight.c
@@ -1378,7 +1378,7 @@ static inline int coresight_search_device_idx(struct coresight_dev_list *dict,
 	for (i = 0; i < dict->nr_idx; i++)
 		if (dict->fwnode_list[i] == fwnode)
 			return i;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 bool coresight_loses_context_with_cpu(struct device *dev)
diff --git a/drivers/hwtracing/intel_th/gth.c b/drivers/hwtracing/intel_th/gth.c
index f72803a02..61e4ad078 100644
--- a/drivers/hwtracing/intel_th/gth.c
+++ b/drivers/hwtracing/intel_th/gth.c
@@ -666,7 +666,7 @@ static int intel_th_gth_assign(struct intel_th_device *thdev,
 		id++;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 
 found:
 	spin_lock(&gth->gth_lock);
diff --git a/drivers/i2c/busses/i2c-exynos5.c b/drivers/i2c/busses/i2c-exynos5.c
index 6ce3ec03b..63d23d8dd 100644
--- a/drivers/i2c/busses/i2c-exynos5.c
+++ b/drivers/i2c/busses/i2c-exynos5.c
@@ -754,7 +754,7 @@ static int exynos5_i2c_probe(struct platform_device *pdev)
 	i2c->clk = devm_clk_get(&pdev->dev, "hsi2c");
 	if (IS_ERR(i2c->clk)) {
 		dev_err(&pdev->dev, "cannot get clock\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = clk_prepare_enable(i2c->clk);
diff --git a/drivers/i2c/busses/i2c-qcom-cci.c b/drivers/i2c/busses/i2c-qcom-cci.c
index f13735bec..c42212842 100644
--- a/drivers/i2c/busses/i2c-qcom-cci.c
+++ b/drivers/i2c/busses/i2c-qcom-cci.c
@@ -538,7 +538,7 @@ static int cci_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, cci);
 	cci->data = device_get_match_data(dev);
 	if (!cci->data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for_each_available_child_of_node(dev->of_node, child) {
 		u32 idx;
diff --git a/drivers/i2c/busses/i2c-s3c2410.c b/drivers/i2c/busses/i2c-s3c2410.c
index 3eafe0eb3..80bf57097 100644
--- a/drivers/i2c/busses/i2c-s3c2410.c
+++ b/drivers/i2c/busses/i2c-s3c2410.c
@@ -1090,7 +1090,7 @@ static int s3c24xx_i2c_probe(struct platform_device *pdev)
 	i2c->clk = devm_clk_get(&pdev->dev, "i2c");
 	if (IS_ERR(i2c->clk)) {
 		dev_err(&pdev->dev, "cannot get clock\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	dev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);
diff --git a/drivers/i3c/master.c b/drivers/i3c/master.c
index 97f2e2926..25c8451e2 100644
--- a/drivers/i3c/master.c
+++ b/drivers/i3c/master.c
@@ -2563,7 +2563,7 @@ int i3c_dev_do_priv_xfers_locked(struct i3c_dev_desc *dev,
 	struct i3c_master_controller *master;
 
 	if (!dev)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	master = i3c_dev_get_master(dev);
 	if (!master || !xfers)
diff --git a/drivers/ide/ide-legacy.c b/drivers/ide/ide-legacy.c
index be65b411a..6510b95d7 100644
--- a/drivers/ide/ide-legacy.c
+++ b/drivers/ide/ide-legacy.c
@@ -52,7 +52,7 @@ int ide_legacy_device_add(const struct ide_port_info *d, unsigned long config)
 
 	if (hws[0] == NULL && hws[1] == NULL &&
 	    (d->host_flags & IDE_HFLAG_SINGLE))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ide_host_add(d, hws, 2, NULL);
 }
diff --git a/drivers/iio/adc/stm32-adc-core.c b/drivers/iio/adc/stm32-adc-core.c
index 0e2068ec0..c564bf016 100644
--- a/drivers/iio/adc/stm32-adc-core.c
+++ b/drivers/iio/adc/stm32-adc-core.c
@@ -135,7 +135,7 @@ static int stm32f4_adc_clk_sel(struct platform_device *pdev,
 	/* stm32f4 has one clk input for analog (mandatory), enforce it here */
 	if (!priv->aclk) {
 		dev_err(&pdev->dev, "No 'adc' clock found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rate = clk_get_rate(priv->aclk);
@@ -207,7 +207,7 @@ static int stm32h7_adc_clk_sel(struct platform_device *pdev,
 	/* stm32h7 bus clock is common for all ADC instances (mandatory) */
 	if (!priv->bclk) {
 		dev_err(&pdev->dev, "No 'bus' clock found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/drivers/infiniband/core/counters.c b/drivers/infiniband/core/counters.c
index 738d1faf4..d053b4cb4 100644
--- a/drivers/infiniband/core/counters.c
+++ b/drivers/infiniband/core/counters.c
@@ -475,7 +475,7 @@ int rdma_counter_bind_qpn(struct ib_device *dev, u8 port,
 
 	qp = rdma_counter_get_qp(dev, qp_num);
 	if (!qp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	counter = rdma_get_counter_by_id(dev, counter_id);
 	if (!counter) {
@@ -526,7 +526,7 @@ int rdma_counter_bind_qpn_alloc(struct ib_device *dev, u8 port,
 
 	qp = rdma_counter_get_qp(dev, qp_num);
 	if (!qp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (rdma_is_port_valid(dev, qp->port) && (qp->port != port)) {
 		ret = -EINVAL;
@@ -573,7 +573,7 @@ int rdma_counter_unbind_qpn(struct ib_device *dev, u8 port,
 
 	qp = rdma_counter_get_qp(dev, qp_num);
 	if (!qp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (rdma_is_port_valid(dev, qp->port) && (qp->port != port)) {
 		ret = -EINVAL;
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index 905a2beaf..459749f02 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -2450,7 +2450,7 @@ int ib_find_gid(struct ib_device *device, union ib_gid *gid,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(ib_find_gid);
 
@@ -2490,7 +2490,7 @@ int ib_find_pkey(struct ib_device *device,
 		*index = partial_ix;
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(ib_find_pkey);
 
diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c
index 5b87eee8c..66f67f3af 100644
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@ -1659,7 +1659,7 @@ static ssize_t ucma_migrate_id(struct ucma_file *new_file,
 	/* Get current fd to protect against it being closed */
 	f = fdget(cmd.fd);
 	if (!f.file)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (f.file->f_op != &ucma_fops) {
 		ret = -EINVAL;
 		goto file_put;
diff --git a/drivers/infiniband/hw/hfi1/eprom.c b/drivers/infiniband/hw/hfi1/eprom.c
index 1613af1c5..1bfba24cf 100644
--- a/drivers/infiniband/hw/hfi1/eprom.c
+++ b/drivers/infiniband/hw/hfi1/eprom.c
@@ -269,7 +269,7 @@ static int read_partition_platform_config(struct hfi1_devdata *dd, void **data,
 	/* config partition is valid only if it starts with IMAGE_START_MAGIC */
 	if (memcmp(buffer, IMAGE_START_MAGIC, strlen(IMAGE_START_MAGIC))) {
 		kfree(buffer);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* scan for image magic that may trail the actual data */
diff --git a/drivers/infiniband/hw/hfi1/fault.c b/drivers/infiniband/hw/hfi1/fault.c
index 0dfbcfb04..a9d196aac 100644
--- a/drivers/infiniband/hw/hfi1/fault.c
+++ b/drivers/infiniband/hw/hfi1/fault.c
@@ -284,7 +284,7 @@ int hfi1_fault_init_debugfs(struct hfi1_ibdev *ibd)
 	if (IS_ERR(fault_dir)) {
 		kfree(ibd->fault);
 		ibd->fault = NULL;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	ibd->fault->dir = fault_dir;
 
diff --git a/drivers/infiniband/hw/hfi1/file_ops.c b/drivers/infiniband/hw/hfi1/file_ops.c
index 8ca51e43c..cd49bb447 100644
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@ -1614,7 +1614,7 @@ static int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, unsigned long arg)
 		if (pkey == ppd->pkeys[i])
 			return hfi1_set_ctxt_pkey(dd, uctxt, pkey);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/drivers/infiniband/hw/mlx4/cm.c b/drivers/infiniband/hw/mlx4/cm.c
index b59186193..b8ef951b6 100644
--- a/drivers/infiniband/hw/mlx4/cm.c
+++ b/drivers/infiniband/hw/mlx4/cm.c
@@ -345,7 +345,7 @@ int mlx4_ib_demux_cm_handler(struct ib_device *ibdev, int port, int *slave,
 		if (*slave < 0) {
 			mlx4_ib_warn(ibdev, "failed matching slave_id by gid (0x%llx)\n",
 				     be64_to_cpu(gid.global.interface_id));
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		return 0;
 	}
@@ -355,7 +355,7 @@ int mlx4_ib_demux_cm_handler(struct ib_device *ibdev, int port, int *slave,
 
 	if (!id) {
 		pr_debug("Couldn't find an entry for pv_cm_id 0x%x\n", pv_cm_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (slave)
diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c
index abe68708d..3c7d8ceeb 100644
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@ -702,12 +702,12 @@ static int mlx4_ib_demux_mad(struct ib_device *ibdev, u8 port,
 		}
 		if (err) {
 			mlx4_ib_warn(ibdev, "failed matching grh\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (slave >= dev->dev->caps.sqp_demux) {
 			mlx4_ib_warn(ibdev, "slave id: %d is bigger than allowed:%d\n",
 				     slave, dev->dev->caps.sqp_demux);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (mlx4_ib_demux_cm_handler(ibdev, port, NULL, mad))
@@ -743,7 +743,7 @@ static int mlx4_ib_demux_mad(struct ib_device *ibdev, u8 port,
 						      grh->dgid.global.interface_id);
 			if (slave < 0) {
 				mlx4_ib_warn(ibdev, "failed matching grh\n");
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		}
 	}
@@ -789,7 +789,7 @@ static int mlx4_ib_demux_mad(struct ib_device *ibdev, u8 port,
 	if (slave >= dev->dev->caps.sqp_demux) {
 		mlx4_ib_warn(ibdev, "slave id: %d is bigger than allowed:%d\n",
 			     slave, dev->dev->caps.sqp_demux);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = mlx4_ib_send_to_slave(dev, slave, port, wc->qp->qp_type, wc, grh, mad);
diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c
index cf51e3cbd..79882cd89 100644
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@ -1964,7 +1964,7 @@ static int handle_eth_ud_smac_index(struct mlx4_ib_dev *dev,
 			qp->pri.candidate_smac_port = qp->port;
 			context->pri_path.grh_mylmc = 0x80 | (u8) smac_index;
 		} else {
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	return 0;
@@ -3023,7 +3023,7 @@ static int fill_gid_by_hw_index(struct mlx4_ib_dev *ibdev, u8 port_num,
 	*gid_type = port_gid_table->gids[index].gid_type;
 	spin_unlock_irqrestore(&iboe->lock, flags);
 	if (rdma_is_zero_gid(gid))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/infiniband/sw/siw/siw_qp.c b/drivers/infiniband/sw/siw/siw_qp.c
index 875d36d4b..38b2d74d4 100644
--- a/drivers/infiniband/sw/siw/siw_qp.c
+++ b/drivers/infiniband/sw/siw/siw_qp.c
@@ -230,7 +230,7 @@ static int siw_qp_enable_crc(struct siw_qp *qp)
 	int size;
 
 	if (siw_crypto_shash == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	size = crypto_shash_descsize(siw_crypto_shash) +
 		sizeof(struct shash_desc);
diff --git a/drivers/infiniband/sw/siw/siw_qp_rx.c b/drivers/infiniband/sw/siw/siw_qp_rx.c
index 7271d705f..5bc18d8b5 100644
--- a/drivers/infiniband/sw/siw/siw_qp_rx.c
+++ b/drivers/infiniband/sw/siw/siw_qp_rx.c
@@ -433,7 +433,7 @@ int siw_proc_send(struct siw_qp *qp)
 			siw_init_terminate(qp, TERM_ERROR_LAYER_DDP,
 					   DDP_ETYPE_UNTAGGED_BUF,
 					   DDP_ECODE_UT_INVALID_MSN_NOBUF, 0);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} else {
 		wqe = rx_wqe(frx);
diff --git a/drivers/infiniband/ulp/rtrs/rtrs-srv.c b/drivers/infiniband/ulp/rtrs/rtrs-srv.c
index 0d9241f5d..f062fc71c 100644
--- a/drivers/infiniband/ulp/rtrs/rtrs-srv.c
+++ b/drivers/infiniband/ulp/rtrs/rtrs-srv.c
@@ -1460,7 +1460,7 @@ static int sockaddr_cmp(const struct sockaddr *a, const struct sockaddr *b)
 			      sizeof(struct in6_addr)) &&
 			(b->sa_family == AF_INET6);
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c
index d8fcd21ab..8af0a54c9 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@ -2913,7 +2913,7 @@ static ssize_t show_service_id(struct device *dev,
 	struct srp_target_port *target = host_to_target(class_to_shost(dev));
 
 	if (target->using_rdma_cm)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return sprintf(buf, "0x%016llx\n",
 		       be64_to_cpu(target->ib_cm.service_id));
 }
@@ -2924,7 +2924,7 @@ static ssize_t show_pkey(struct device *dev, struct device_attribute *attr,
 	struct srp_target_port *target = host_to_target(class_to_shost(dev));
 
 	if (target->using_rdma_cm)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return sprintf(buf, "0x%04x\n", be16_to_cpu(target->ib_cm.pkey));
 }
 
@@ -2943,7 +2943,7 @@ static ssize_t show_dgid(struct device *dev, struct device_attribute *attr,
 	struct srp_rdma_ch *ch = &target->ch[0];
 
 	if (target->using_rdma_cm)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return sprintf(buf, "%pI6\n", ch->ib_cm.path.dgid.raw);
 }
 
@@ -2953,7 +2953,7 @@ static ssize_t show_orig_dgid(struct device *dev,
 	struct srp_target_port *target = host_to_target(class_to_shost(dev));
 
 	if (target->using_rdma_cm)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return sprintf(buf, "%pI6\n", target->ib_cm.orig_dgid.raw);
 }
 
diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index e494295d1..f934f5a7b 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -766,7 +766,7 @@ static int str_to_user(const char *str, unsigned int maxlen, void __user *p)
 	int len;
 
 	if (!str)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	len = strlen(str) + 1;
 	if (len > maxlen)
diff --git a/drivers/input/keyboard/tegra-kbc.c b/drivers/input/keyboard/tegra-kbc.c
index d34d69479..526acda03 100644
--- a/drivers/input/keyboard/tegra-kbc.c
+++ b/drivers/input/keyboard/tegra-kbc.c
@@ -513,13 +513,13 @@ static int tegra_kbc_parse_dt(struct tegra_kbc *kbc)
 
 	if (!of_get_property(np, "nvidia,kbc-row-pins", &proplen)) {
 		dev_err(kbc->dev, "property nvidia,kbc-row-pins not found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	num_rows = proplen / sizeof(u32);
 
 	if (!of_get_property(np, "nvidia,kbc-col-pins", &proplen)) {
 		dev_err(kbc->dev, "property nvidia,kbc-col-pins not found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	num_cols = proplen / sizeof(u32);
 
@@ -537,7 +537,7 @@ static int tegra_kbc_parse_dt(struct tegra_kbc *kbc)
 
 	if (!of_get_property(np, "linux,keymap", &proplen)) {
 		dev_err(kbc->dev, "property linux,keymap not found\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!num_rows || !num_cols || ((num_rows + num_cols) > KBC_MAX_GPIO)) {
diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c
index f2593133e..f1827140c 100644
--- a/drivers/input/misc/uinput.c
+++ b/drivers/input/misc/uinput.c
@@ -818,7 +818,7 @@ static int uinput_str_to_user(void __user *dest, const char *str,
 	int len, ret;
 
 	if (!str)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (maxlen == 0)
 		return -EINVAL;
diff --git a/drivers/input/mouse/psmouse-base.c b/drivers/input/mouse/psmouse-base.c
index 527ae0b9a..6b1cc1c24 100644
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@ -1812,7 +1812,7 @@ ssize_t psmouse_attr_show_helper(struct device *dev, struct device_attribute *de
 
 	if (psmouse->protocol->smbus_companion &&
 			devattr != &psmouse_attr_protocol.dattr)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return attr->show(psmouse, attr->data, buf);
 }
diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index b2cd9472e..6fbe96913 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -208,7 +208,7 @@ static int lpc32xx_ts_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "Can't get memory resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	irq = platform_get_irq(pdev, 0);
diff --git a/drivers/input/touchscreen/raspberrypi-ts.c b/drivers/input/touchscreen/raspberrypi-ts.c
index ef6aaed21..2875f9445 100644
--- a/drivers/input/touchscreen/raspberrypi-ts.c
+++ b/drivers/input/touchscreen/raspberrypi-ts.c
@@ -131,7 +131,7 @@ static int rpi_ts_probe(struct platform_device *pdev)
 	fw_node = of_get_parent(np);
 	if (!fw_node) {
 		dev_err(dev, "Missing firmware node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fw = rpi_firmware_get(fw_node);
diff --git a/drivers/input/touchscreen/s3c2410_ts.c b/drivers/input/touchscreen/s3c2410_ts.c
index 82920ff46..5986fa2a4 100644
--- a/drivers/input/touchscreen/s3c2410_ts.c
+++ b/drivers/input/touchscreen/s3c2410_ts.c
@@ -247,7 +247,7 @@ static int s3c2410ts_probe(struct platform_device *pdev)
 	ts.clock = clk_get(dev, "adc");
 	if (IS_ERR(ts.clock)) {
 		dev_err(dev, "cannot get adc clock source\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = clk_prepare_enable(ts.clock);
diff --git a/drivers/input/touchscreen/sis_i2c.c b/drivers/input/touchscreen/sis_i2c.c
index 6274555f1..14b5433ff 100644
--- a/drivers/input/touchscreen/sis_i2c.c
+++ b/drivers/input/touchscreen/sis_i2c.c
@@ -186,7 +186,7 @@ static int sis_ts_report_contact(struct sis_ts_data *ts, const u8 *data, u8 id)
 
 	slot = input_mt_get_slot_by_key(input, data[SIS_CONTACT_ID_OFFSET]);
 	if (slot < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	input_mt_slot(input, slot);
 	input_mt_report_slot_state(input, MT_TOOL_FINGER,
diff --git a/drivers/iommu/arm-smmu-v3.c b/drivers/iommu/arm-smmu-v3.c
index f578677a5..1cf22eee8 100644
--- a/drivers/iommu/arm-smmu-v3.c
+++ b/drivers/iommu/arm-smmu-v3.c
@@ -974,7 +974,7 @@ static int arm_smmu_cmdq_build_cmd(u64 *cmd, struct arm_smmu_cmdq_ent *ent)
 		cmd[0] |= FIELD_PREP(CMDQ_SYNC_0_MSIATTR, ARM_SMMU_MEMATTR_OIWB);
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -2792,7 +2792,7 @@ static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)
 	struct arm_smmu_master *master;
 
 	if (!fwspec)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	master = dev_iommu_priv_get(dev);
 	smmu = master->smmu;
diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c
index cde281b97..a7d29de14 100644
--- a/drivers/iommu/fsl_pamu.c
+++ b/drivers/iommu/fsl_pamu.c
@@ -106,7 +106,7 @@ int pamu_enable_liodn(int liodn)
 	ppaace = pamu_get_ppaace(liodn);
 	if (!ppaace) {
 		pr_debug("Invalid primary paace entry\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!get_bf(ppaace->addr_bitfields, PPAACE_AF_WSE)) {
@@ -136,7 +136,7 @@ int pamu_disable_liodn(int liodn)
 	ppaace = pamu_get_ppaace(liodn);
 	if (!ppaace) {
 		pr_debug("Invalid primary paace entry\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	set_bf(ppaace->addr_bitfields, PAACE_AF_V, PAACE_V_INVALID);
@@ -263,12 +263,12 @@ int  pamu_update_paace_stash(int liodn, u32 subwin, u32 value)
 	paace = pamu_get_ppaace(liodn);
 	if (!paace) {
 		pr_debug("Invalid liodn entry\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (subwin) {
 		paace = pamu_get_spaace(paace, subwin - 1);
 		if (!paace)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 	set_bf(paace->impl_attr, PAACE_IA_CID, value);
 
@@ -285,12 +285,12 @@ int pamu_disable_spaace(int liodn, u32 subwin)
 	paace = pamu_get_ppaace(liodn);
 	if (!paace) {
 		pr_debug("Invalid liodn entry\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (subwin) {
 		paace = pamu_get_spaace(paace, subwin - 1);
 		if (!paace)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		set_bf(paace->addr_bitfields, PAACE_AF_V, PAACE_V_INVALID);
 	} else {
 		set_bf(paace->addr_bitfields, PAACE_AF_AP,
@@ -339,7 +339,7 @@ int pamu_config_ppaace(int liodn, phys_addr_t win_addr, phys_addr_t win_size,
 
 	ppaace = pamu_get_ppaace(liodn);
 	if (!ppaace)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* window size is 2^(WSE+1) bytes */
 	set_bf(ppaace->addr_bitfields, PPAACE_AF_WSE,
@@ -435,7 +435,7 @@ int pamu_config_spaace(int liodn, u32 subwin_cnt, u32 subwin,
 
 	if (!paace) {
 		pr_debug("Invalid liodn entry\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if ((subwin_size & (subwin_size - 1)) || subwin_size < PAMU_PAGE_SIZE) {
diff --git a/drivers/iommu/intel/dmar.c b/drivers/iommu/intel/dmar.c
index 683b812c5..f4b7fded0 100644
--- a/drivers/iommu/intel/dmar.c
+++ b/drivers/iommu/intel/dmar.c
@@ -1557,7 +1557,7 @@ int dmar_enable_qi(struct intel_iommu *iommu)
 	struct page *desc_page;
 
 	if (!ecap_qis(iommu->ecap))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * queued invalidation is already setup and enabled.
@@ -1940,10 +1940,10 @@ int __init enable_drhd_fault_handling(void)
 int dmar_reenable_qi(struct intel_iommu *iommu)
 {
 	if (!ecap_qis(iommu->ecap))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!iommu->qi)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * First disable queued invalidation.
diff --git a/drivers/iommu/virtio-iommu.c b/drivers/iommu/virtio-iommu.c
index f6f07489a..ef0e14f89 100644
--- a/drivers/iommu/virtio-iommu.c
+++ b/drivers/iommu/virtio-iommu.c
@@ -114,7 +114,7 @@ static int viommu_get_req_errno(void *buf, size_t len)
 	case VIRTIO_IOMMU_S_RANGE:
 		return -ERANGE;
 	case VIRTIO_IOMMU_S_NOENT:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case VIRTIO_IOMMU_S_FAULT:
 		return -EFAULT;
 	case VIRTIO_IOMMU_S_NOMEM:
diff --git a/drivers/irqchip/irq-imgpdc.c b/drivers/irqchip/irq-imgpdc.c
index 698d07f48..7762f1380 100644
--- a/drivers/irqchip/irq-imgpdc.c
+++ b/drivers/irqchip/irq-imgpdc.c
@@ -305,13 +305,13 @@ static int pdc_intc_probe(struct platform_device *pdev)
 	u32 val;
 
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Get registers */
 	res_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res_regs == NULL) {
 		dev_err(&pdev->dev, "cannot find registers resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Allocate driver data */
diff --git a/drivers/irqchip/irq-ls-extirq.c b/drivers/irqchip/irq-ls-extirq.c
index 4d1179fed..f206171c8 100644
--- a/drivers/irqchip/irq-ls-extirq.c
+++ b/drivers/irqchip/irq-ls-extirq.c
@@ -103,7 +103,7 @@ ls_extirq_parse_map(struct ls_extirq_data *priv, struct device_node *node)
 
 	map = of_get_property(node, "interrupt-map", &mapsize);
 	if (!map)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (mapsize % sizeof(*map))
 		return -EINVAL;
 	mapsize /= sizeof(*map);
diff --git a/drivers/mailbox/pcc.c b/drivers/mailbox/pcc.c
index 8c7fac38b..93a510081 100644
--- a/drivers/mailbox/pcc.c
+++ b/drivers/mailbox/pcc.c
@@ -333,7 +333,7 @@ static int pcc_send_data(struct mbox_chan *chan, void *data)
 
 	if (id >= pcc_mbox_ctrl.num_chans) {
 		pr_debug("pcc_send_data: Invalid mbox_chan passed\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	doorbell = &pcct_ss->doorbell_register;
diff --git a/drivers/mailbox/tegra-hsp.c b/drivers/mailbox/tegra-hsp.c
index 834b35dc3..1c88f85fc 100644
--- a/drivers/mailbox/tegra-hsp.c
+++ b/drivers/mailbox/tegra-hsp.c
@@ -622,7 +622,7 @@ static int tegra_hsp_request_shared_irq(struct tegra_hsp *hsp)
 
 	if (i == hsp->num_si) {
 		dev_err(hsp->dev, "failed to find available interrupt\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c
index 2014016f9..efc3f7b48 100644
--- a/drivers/md/bcache/super.c
+++ b/drivers/md/bcache/super.c
@@ -1131,7 +1131,7 @@ int bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c,
 
 	if ((set_uuid && memcmp(set_uuid, c->sb.set_uuid, 16)) ||
 	    (!set_uuid && memcmp(dc->sb.set_uuid, c->sb.set_uuid, 16)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (dc->disk.c) {
 		pr_err("Can't attach %s: already attached\n",
@@ -1176,7 +1176,7 @@ int bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c,
 		if (BDEV_STATE(&dc->sb) == BDEV_STATE_DIRTY) {
 			pr_err("Couldn't find uuid for %s in set\n",
 			       dc->backing_dev_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		u = uuid_find_empty(c);
diff --git a/drivers/md/dm-cache-policy-smq.c b/drivers/md/dm-cache-policy-smq.c
index b61aac00f..9ead78fd1 100644
--- a/drivers/md/dm-cache-policy-smq.c
+++ b/drivers/md/dm-cache-policy-smq.c
@@ -1393,7 +1393,7 @@ static int __lookup(struct smq_policy *mq, dm_oblock_t oblock, dm_cblock_t *cblo
 			*background_work = true;
 		}
 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/drivers/md/dm-log-userspace-transfer.c b/drivers/md/dm-log-userspace-transfer.c
index fdf8ec304..82e13cd4d 100644
--- a/drivers/md/dm-log-userspace-transfer.c
+++ b/drivers/md/dm-log-userspace-transfer.c
@@ -123,7 +123,7 @@ static int fill_pkg(struct cn_msg *msg, struct dm_ulog_request *tfr)
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c
index 35d368c41..92b34cc18 100644
--- a/drivers/md/dm-stats.c
+++ b/drivers/md/dm-stats.c
@@ -414,7 +414,7 @@ static int dm_stats_delete(struct dm_stats *stats, int id)
 	s = __dm_stats_find(stats, id);
 	if (!s) {
 		mutex_unlock(&stats->mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	list_del_rcu(&s->list_entry);
@@ -762,7 +762,7 @@ static int dm_stats_clear(struct dm_stats *stats, int id)
 	s = __dm_stats_find(stats, id);
 	if (!s) {
 		mutex_unlock(&stats->mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	__dm_stat_clear(s, 0, s->n_entries, true);
@@ -817,7 +817,7 @@ static int dm_stats_print(struct dm_stats *stats, int id,
 	s = __dm_stats_find(stats, id);
 	if (!s) {
 		mutex_unlock(&stats->mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	idx_end = idx_start + idx_len;
@@ -886,7 +886,7 @@ static int dm_stats_set_aux(struct dm_stats *stats, int id, const char *aux_data
 	s = __dm_stats_find(stats, id);
 	if (!s) {
 		mutex_unlock(&stats->mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	new_aux_data = kstrdup(aux_data, GFP_KERNEL);
diff --git a/drivers/md/md-bitmap.c b/drivers/md/md-bitmap.c
index 95a5f3757..f25f783f7 100644
--- a/drivers/md/md-bitmap.c
+++ b/drivers/md/md-bitmap.c
@@ -69,7 +69,7 @@ __acquires(bitmap->lock)
 		return 0;
 
 	if (!create)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* this page has not been allocated yet */
 
@@ -2559,7 +2559,7 @@ static ssize_t can_clear_show(struct mddev *mddev, char *page)
 static ssize_t can_clear_store(struct mddev *mddev, const char *buf, size_t len)
 {
 	if (mddev->bitmap == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (strncmp(buf, "false", 5) == 0)
 		mddev->bitmap->need_sync = 1;
 	else if (strncmp(buf, "true", 4) == 0) {
diff --git a/drivers/md/md.c b/drivers/md/md.c
index f567f536b..0405e592c 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -7021,7 +7021,7 @@ static int set_bitmap_file(struct mddev *mddev, int fd)
 		mddev->bitmap_info.file = f;
 		mddev->bitmap_info.offset = 0; /* file overrides offset */
 	} else if (mddev->bitmap == NULL)
-		return -ENOENT; /* cannot remove what isn't there */
+		ENOENT_DUMPER(stackdump_tuneable); /* cannot remove what isn't there */
 	err = 0;
 	if (mddev->pers) {
 		if (fd >= 0) {
@@ -8362,7 +8362,7 @@ int md_setup_cluster(struct mddev *mddev, int nodes)
 	if (!md_cluster_ops || !try_module_get(md_cluster_mod)) {
 		pr_warn("can't find md-cluster module or get it's reference.\n");
 		spin_unlock(&pers_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	spin_unlock(&pers_lock);
 
diff --git a/drivers/media/cec/platform/tegra/tegra_cec.c b/drivers/media/cec/platform/tegra/tegra_cec.c
index 1ac0c70a5..f2dc80c82 100644
--- a/drivers/media/cec/platform/tegra/tegra_cec.c
+++ b/drivers/media/cec/platform/tegra/tegra_cec.c
@@ -363,7 +363,7 @@ static int tegra_cec_probe(struct platform_device *pdev)
 
 	if (IS_ERR_OR_NULL(cec->clk)) {
 		dev_err(&pdev->dev, "Can't get clock for CEC\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	clk_prepare_enable(cec->clk);
diff --git a/drivers/media/common/siano/smscoreapi.c b/drivers/media/common/siano/smscoreapi.c
index c1511094f..e46430161 100644
--- a/drivers/media/common/siano/smscoreapi.c
+++ b/drivers/media/common/siano/smscoreapi.c
@@ -1147,7 +1147,7 @@ static int smscore_load_firmware_from_file(struct smscore_device_t *coredev,
 	char *fw_filename = smscore_get_fw_filename(coredev, mode);
 	if (!fw_filename) {
 		pr_err("mode %d not supported on this device\n", mode);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	pr_debug("Firmware name: %s\n", fw_filename);
 
diff --git a/drivers/media/common/videobuf2/videobuf2-v4l2.c b/drivers/media/common/videobuf2/videobuf2-v4l2.c
index eb5d5db96..1e7492b91 100644
--- a/drivers/media/common/videobuf2/videobuf2-v4l2.c
+++ b/drivers/media/common/videobuf2/videobuf2-v4l2.c
@@ -1179,7 +1179,7 @@ int vb2_request_validate(struct media_request *req)
 	int ret = 0;
 
 	if (!vb2_request_buffer_cnt(req))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_for_each_entry(obj, &req->objects, list) {
 		if (!obj->ops->prepare)
diff --git a/drivers/media/i2c/adv7604.c b/drivers/media/i2c/adv7604.c
index 09004d928..035c36626 100644
--- a/drivers/media/i2c/adv7604.c
+++ b/drivers/media/i2c/adv7604.c
@@ -2435,7 +2435,7 @@ static int adv76xx_read_infoframe(struct v4l2_subdev *sd, int index,
 	if (!(io_read(sd, 0x60) & adv76xx_cri[index].present_mask)) {
 		v4l2_info(sd, "%s infoframe not received\n",
 			  adv76xx_cri[index].desc);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 0; i < 3; i++)
@@ -2447,7 +2447,7 @@ static int adv76xx_read_infoframe(struct v4l2_subdev *sd, int index,
 	if (len + 3 > sizeof(buffer)) {
 		v4l2_err(sd, "%s: invalid %s infoframe length %d\n", __func__,
 			 adv76xx_cri[index].desc, len);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 0; i < len; i++)
@@ -2457,7 +2457,7 @@ static int adv76xx_read_infoframe(struct v4l2_subdev *sd, int index,
 	if (hdmi_infoframe_unpack(frame, buffer, sizeof(buffer)) < 0) {
 		v4l2_err(sd, "%s: unpack of %s infoframe failed\n", __func__,
 			 adv76xx_cri[index].desc);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return 0;
 }
diff --git a/drivers/media/pci/cx25821/cx25821-alsa.c b/drivers/media/pci/cx25821/cx25821-alsa.c
index 301616426..a2caa77cf 100644
--- a/drivers/media/pci/cx25821/cx25821-alsa.c
+++ b/drivers/media/pci/cx25821/cx25821-alsa.c
@@ -703,7 +703,7 @@ static int cx25821_audio_initdev(struct cx25821_dev *dev)
 	if (!enable[devno]) {
 		++devno;
 		pr_info("DEBUG ERROR: !enable[devno] %s\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&dev->pci->dev, index[devno], id[devno],
diff --git a/drivers/media/platform/coda/coda-bit.c b/drivers/media/platform/coda/coda-bit.c
index b021604ec..9b30ef5ea 100644
--- a/drivers/media/platform/coda/coda-bit.c
+++ b/drivers/media/platform/coda/coda-bit.c
@@ -117,7 +117,7 @@ int coda_hw_reset(struct coda_ctx *ctx)
 	lockdep_assert_held(&dev->coda_mutex);
 
 	if (!dev->rstc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	idx = coda_read(dev, CODA_REG_BIT_RUN_INDEX);
 
diff --git a/drivers/media/platform/davinci/vpss.c b/drivers/media/platform/davinci/vpss.c
index d38d2bbb6..8d7baecd3 100644
--- a/drivers/media/platform/davinci/vpss.c
+++ b/drivers/media/platform/davinci/vpss.c
@@ -397,7 +397,7 @@ static int vpss_probe(struct platform_device *pdev)
 
 	if (!pdev->dev.platform_data) {
 		dev_err(&pdev->dev, "no platform data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	platform_name = pdev->dev.platform_data;
diff --git a/drivers/media/platform/exynos4-is/media-dev.c b/drivers/media/platform/exynos4-is/media-dev.c
index 9aaf3b806..2025636ea 100644
--- a/drivers/media/platform/exynos4-is/media-dev.c
+++ b/drivers/media/platform/exynos4-is/media-dev.c
@@ -620,7 +620,7 @@ static int register_csis_entity(struct fimc_md *fmd,
 	id = node ? __of_get_csis_id(node) : max(0, pdev->id);
 
 	if (WARN_ON(id < 0 || id >= CSIS_MAX_ENTITIES))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (WARN_ON(fmd->csis[id].sd))
 		return -EBUSY;
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c
index eba2b9f04..84c17f0c3 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c
@@ -1297,7 +1297,7 @@ static int s5p_mfc_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "failed to get irq resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	dev->irq = res->start;
 	ret = devm_request_irq(&pdev->dev, dev->irq, s5p_mfc_irq,
diff --git a/drivers/media/test-drivers/vicodec/vicodec-core.c b/drivers/media/test-drivers/vicodec/vicodec-core.c
index e87929072..16454e1f3 100644
--- a/drivers/media/test-drivers/vicodec/vicodec-core.c
+++ b/drivers/media/test-drivers/vicodec/vicodec-core.c
@@ -1971,14 +1971,14 @@ static int vicodec_request_validate(struct media_request *req)
 
 	if (!ctx) {
 		pr_err("No buffer was provided with the request\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	count = vb2_request_buffer_cnt(req);
 	if (!count) {
 		v4l2_info(&ctx->dev->v4l2_dev,
 			  "No buffer was provided with the request\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (count > 1) {
 		v4l2_info(&ctx->dev->v4l2_dev,
 			  "More than one buffer was provided with the request\n");
@@ -1990,14 +1990,14 @@ static int vicodec_request_validate(struct media_request *req)
 	hdl = v4l2_ctrl_request_hdl_find(req, parent_hdl);
 	if (!hdl) {
 		v4l2_info(&ctx->dev->v4l2_dev, "Missing codec control\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	ctrl = v4l2_ctrl_request_hdl_ctrl_find(hdl,
 					       vicodec_ctrl_stateless_state.id);
 	if (!ctrl) {
 		v4l2_info(&ctx->dev->v4l2_dev,
 			  "Missing required codec control\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return vb2_request_validate(req);
diff --git a/drivers/media/tuners/tuner-xc2028.c b/drivers/media/tuners/tuner-xc2028.c
index 574c3bb13..d3b71463e 100644
--- a/drivers/media/tuners/tuner-xc2028.c
+++ b/drivers/media/tuners/tuner-xc2028.c
@@ -670,7 +670,7 @@ static int load_scode(struct dvb_frontend *fe, unsigned int type,
 				break;
 		}
 		if (pos == priv->firm_size)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	p = priv->firm[pos].ptr;
diff --git a/drivers/media/tuners/xc4000.c b/drivers/media/tuners/xc4000.c
index d9606738c..8fe8180d3 100644
--- a/drivers/media/tuners/xc4000.c
+++ b/drivers/media/tuners/xc4000.c
@@ -877,7 +877,7 @@ static int load_scode(struct dvb_frontend *fe, unsigned int type,
 				break;
 		}
 		if (pos == priv->firm_size)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	p = priv->firm[pos].ptr;
diff --git a/drivers/media/usb/go7007/snd-go7007.c b/drivers/media/usb/go7007/snd-go7007.c
index 2ce85ab38..fa1f44afd 100644
--- a/drivers/media/usb/go7007/snd-go7007.c
+++ b/drivers/media/usb/go7007/snd-go7007.c
@@ -205,7 +205,7 @@ int go7007_snd_init(struct go7007 *go)
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	gosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);
 	if (gosnd == NULL)
diff --git a/drivers/media/usb/pwc/pwc-ctrl.c b/drivers/media/usb/pwc/pwc-ctrl.c
index cff64d872..3827807be 100644
--- a/drivers/media/usb/pwc/pwc-ctrl.c
+++ b/drivers/media/usb/pwc/pwc-ctrl.c
@@ -238,7 +238,7 @@ static int set_video_mode_Timon(struct pwc_device *pdev, int size, int pixfmt,
 	} while (*compression <= 3);
 
 	if (pChoose->alternate == 0)
-		return -ENOENT; /* Not supported. */
+		ENOENT_DUMPER(stackdump_tuneable); /* Not supported. */
 
 	if (send_to_cam)
 		ret = send_video_command(pdev, pdev->vendpoint,
@@ -289,7 +289,7 @@ static int set_video_mode_Kiara(struct pwc_device *pdev, int size, int pixfmt,
 	} while (*compression <= 3);
 
 	if (pChoose->alternate == 0)
-		return -ENOENT; /* Not supported. */
+		ENOENT_DUMPER(stackdump_tuneable); /* Not supported. */
 
 	/* Firmware bug: video endpoint is 5, but commands are sent to endpoint 4 */
 	if (send_to_cam)
diff --git a/drivers/media/usb/siano/smsusb.c b/drivers/media/usb/siano/smsusb.c
index 9ba3a2ae3..f5563e840 100644
--- a/drivers/media/usb/siano/smsusb.c
+++ b/drivers/media/usb/siano/smsusb.c
@@ -211,7 +211,7 @@ static int smsusb_sendrequest(void *context, void *buffer, size_t size)
 
 	if (dev->state != SMSUSB_ACTIVE) {
 		pr_debug("Device not active yet\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	phdr = kmemdup(buffer, size, GFP_KERNEL);
diff --git a/drivers/media/usb/tm6000/tm6000-alsa.c b/drivers/media/usb/tm6000/tm6000-alsa.c
index c26a0ff60..a0499372d 100644
--- a/drivers/media/usb/tm6000/tm6000-alsa.c
+++ b/drivers/media/usb/tm6000/tm6000-alsa.c
@@ -340,7 +340,7 @@ static int tm6000_audio_init(struct tm6000_core *dev)
 		return -ENODEV;
 
 	if (!enable[devnr])
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = snd_card_new(&dev->udev->dev, index[devnr], "tm6000",
 			  THIS_MODULE, 0, &card);
diff --git a/drivers/media/usb/ttusb-dec/ttusb_dec.c b/drivers/media/usb/ttusb-dec/ttusb_dec.c
index b8d39b2f7..7fdd0a115 100644
--- a/drivers/media/usb/ttusb-dec/ttusb_dec.c
+++ b/drivers/media/usb/ttusb-dec/ttusb_dec.c
@@ -410,7 +410,7 @@ static int ttusb_dec_get_stb_state (struct ttusb_dec *dec, unsigned int *mode,
 		}
 		return 0;
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
@@ -1338,7 +1338,7 @@ static int ttusb_dec_boot_dsp(struct ttusb_dec *dec)
 		printk("%s: firmware size too small for DSP code (%zu < 60).\n",
 			__func__, firmware_size);
 		release_firmware(fw_entry);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* a 32 bit checksum over the first 56 bytes of the DSP Code is stored
@@ -1351,7 +1351,7 @@ static int ttusb_dec_boot_dsp(struct ttusb_dec *dec)
 		printk("%s: crc32 check of DSP code failed (calculated 0x%08x != 0x%08x in file), file invalid.\n",
 			__func__, crc32_csum, crc32_check);
 		release_firmware(fw_entry);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	memcpy(idstring, &firmware[36], 20);
 	idstring[20] = '\0';
@@ -1453,7 +1453,7 @@ static int ttusb_dec_init_stb(struct ttusb_dec *dec)
 		default:
 			printk(KERN_ERR "%s: unknown model returned by firmware (%08x) - please report\n",
 			       __func__, model);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (version >= 0x01770000)
 			dec->can_playback = 1;
diff --git a/drivers/media/usb/uvc/uvc_ctrl.c b/drivers/media/usb/uvc/uvc_ctrl.c
index e399b9fad..0089a0fb1 100644
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@ -1860,7 +1860,7 @@ int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 	if (entity->id != xqry->unit) {
 		uvc_trace(UVC_TRACE_CONTROL, "Extension unit %u not found.\n",
 			xqry->unit);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Find the control and perform delayed initialization if needed. */
@@ -1875,7 +1875,7 @@ int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 	if (!found) {
 		uvc_trace(UVC_TRACE_CONTROL, "Control %pUl/%u not found.\n",
 			entity->extension.guidExtensionCode, xqry->selector);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (mutex_lock_interruptible(&chain->ctrl_mutex))
@@ -2119,7 +2119,7 @@ int uvc_ctrl_add_mapping(struct uvc_video_chain *chain,
 			break;
 	}
 	if (!found)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (mutex_lock_interruptible(&chain->ctrl_mutex))
 		return -ERESTARTSYS;
diff --git a/drivers/media/v4l2-core/v4l2-event.c b/drivers/media/v4l2-core/v4l2-event.c
index 290c6b213..48d0a6f71 100644
--- a/drivers/media/v4l2-core/v4l2-event.c
+++ b/drivers/media/v4l2-core/v4l2-event.c
@@ -34,7 +34,7 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 
 	if (list_empty(&fh->available)) {
 		spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	WARN_ON(fh->navailable == 0);
diff --git a/drivers/media/v4l2-core/v4l2-fwnode.c b/drivers/media/v4l2-core/v4l2-fwnode.c
index a4c3c77c1..214e33fe4 100644
--- a/drivers/media/v4l2-core/v4l2-fwnode.c
+++ b/drivers/media/v4l2-core/v4l2-fwnode.c
@@ -960,7 +960,7 @@ static int v4l2_fwnode_reference_parse(struct device *dev,
 		fwnode_handle_put(args.fwnode);
 
 	if (!index)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Note that right now both -ENODATA and -ENOENT may signal
diff --git a/drivers/memory/brcmstb_dpfe.c b/drivers/memory/brcmstb_dpfe.c
index 82b415be1..f5a25e3f7 100644
--- a/drivers/memory/brcmstb_dpfe.c
+++ b/drivers/memory/brcmstb_dpfe.c
@@ -868,14 +868,14 @@ static int brcmstb_dpfe_probe(struct platform_device *pdev)
 	priv->dmem = devm_ioremap_resource(dev, res);
 	if (IS_ERR(priv->dmem)) {
 		dev_err(dev, "Couldn't map DCPU data memory\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dpfe-imem");
 	priv->imem = devm_ioremap_resource(dev, res);
 	if (IS_ERR(priv->imem)) {
 		dev_err(dev, "Couldn't map DCPU instruction memory\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	priv->dpfe_api = of_device_get_match_data(dev);
@@ -885,7 +885,7 @@ static int brcmstb_dpfe_probe(struct platform_device *pdev)
 		 * check anyway.
 		 */
 		dev_err(dev, "Couldn't determine API\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = brcmstb_dpfe_download_firmware(priv);
diff --git a/drivers/memory/fsl_ifc.c b/drivers/memory/fsl_ifc.c
index a2c971743..d395db9fe 100644
--- a/drivers/memory/fsl_ifc.c
+++ b/drivers/memory/fsl_ifc.c
@@ -58,7 +58,7 @@ int fsl_ifc_find(phys_addr_t addr_base)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(fsl_ifc_find);
 
diff --git a/drivers/memory/omap-gpmc.c b/drivers/memory/omap-gpmc.c
index eff26c1b1..404f441ee 100644
--- a/drivers/memory/omap-gpmc.c
+++ b/drivers/memory/omap-gpmc.c
@@ -2357,7 +2357,7 @@ static int gpmc_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	phys_base = res->start;
 	mem_size = resource_size(res);
@@ -2369,7 +2369,7 @@ static int gpmc_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "Failed to get resource: irq\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	gpmc->irq = res->start;
diff --git a/drivers/memory/tegra/tegra124-emc.c b/drivers/memory/tegra/tegra124-emc.c
index 33b8216ba..b719cbd39 100644
--- a/drivers/memory/tegra/tegra124-emc.c
+++ b/drivers/memory/tegra/tegra124-emc.c
@@ -574,7 +574,7 @@ int tegra_emc_prepare_timing_change(struct tegra_emc *emc,
 	unsigned int i;
 
 	if (!timing)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((last->emc_mode_1 & 0x1) == (timing->emc_mode_1 & 0x1))
 		dll_change = DLL_CHANGE_NONE;
@@ -1209,13 +1209,13 @@ static int tegra_emc_probe(struct platform_device *pdev)
 	np = of_parse_phandle(pdev->dev.of_node, "nvidia,memory-controller", 0);
 	if (!np) {
 		dev_err(&pdev->dev, "could not get memory controller\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mc = of_find_device_by_node(np);
 	of_node_put(np);
 	if (!mc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	emc->mc = platform_get_drvdata(mc);
 	if (!emc->mc)
@@ -1228,7 +1228,7 @@ static int tegra_emc_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev,
 			"no memory timings for RAM code %u found in DT\n",
 			ram_code);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = tegra_emc_load_timings_from_dt(emc, np);
@@ -1240,7 +1240,7 @@ static int tegra_emc_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev,
 			"no memory timings for RAM code %u registered\n",
 			ram_code);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = emc_init(emc);
diff --git a/drivers/memory/tegra/tegra30-emc.c b/drivers/memory/tegra/tegra30-emc.c
index b42bdb667..d698c6c54 100644
--- a/drivers/memory/tegra/tegra30-emc.c
+++ b/drivers/memory/tegra/tegra30-emc.c
@@ -1299,13 +1299,13 @@ static int tegra_emc_probe(struct platform_device *pdev)
 	np = of_parse_phandle(pdev->dev.of_node, "nvidia,memory-controller", 0);
 	if (!np) {
 		dev_err(&pdev->dev, "could not get memory controller node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mc = of_find_device_by_node(np);
 	of_node_put(np);
 	if (!mc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	np = emc_find_node_by_ram_code(&pdev->dev);
 	if (!np)
diff --git a/drivers/mfd/altera-sysmgr.c b/drivers/mfd/altera-sysmgr.c
index d2a13a547..1f3ed54ff 100644
--- a/drivers/mfd/altera-sysmgr.c
+++ b/drivers/mfd/altera-sysmgr.c
@@ -134,7 +134,7 @@ static int sysmgr_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	sysmgr_config.max_register = resource_size(res) -
 				     sysmgr_config.reg_stride;
diff --git a/drivers/mfd/pcf50633-core.c b/drivers/mfd/pcf50633-core.c
index 148bcd612..4e3908fb3 100644
--- a/drivers/mfd/pcf50633-core.c
+++ b/drivers/mfd/pcf50633-core.c
@@ -194,7 +194,7 @@ static int pcf50633_probe(struct i2c_client *client,
 
 	if (!client->irq) {
 		dev_err(&client->dev, "Missing IRQ\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pcf = devm_kzalloc(&client->dev, sizeof(*pcf), GFP_KERNEL);
diff --git a/drivers/mfd/rn5t618.c b/drivers/mfd/rn5t618.c
index 232de5056..200a48391 100644
--- a/drivers/mfd/rn5t618.c
+++ b/drivers/mfd/rn5t618.c
@@ -95,7 +95,7 @@ static int rn5t618_irq_init(struct rn5t618 *rn5t618)
 	default:
 		dev_err(rn5t618->dev, "Currently no IRQ support for variant %d\n",
 			(int)rn5t618->variant);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = devm_regmap_add_irq_chip(rn5t618->dev, rn5t618->regmap,
diff --git a/drivers/mfd/sun6i-prcm.c b/drivers/mfd/sun6i-prcm.c
index c31927d4b..7b94bebd4 100644
--- a/drivers/mfd/sun6i-prcm.c
+++ b/drivers/mfd/sun6i-prcm.c
@@ -161,7 +161,7 @@ static int sun6i_prcm_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "no prcm memory region provided\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = mfd_add_devices(&pdev->dev, 0, data->subdevs, data->nsubdevs,
diff --git a/drivers/mfd/syscon.c b/drivers/mfd/syscon.c
index 3a97816d0..d09c07487 100644
--- a/drivers/mfd/syscon.c
+++ b/drivers/mfd/syscon.c
@@ -268,7 +268,7 @@ static int syscon_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	base = devm_ioremap(dev, res->start, resource_size(res));
 	if (!base)
diff --git a/drivers/misc/cxl/api.c b/drivers/misc/cxl/api.c
index b493de962..e04dd256f 100644
--- a/drivers/misc/cxl/api.c
+++ b/drivers/misc/cxl/api.c
@@ -237,7 +237,7 @@ int cxl_map_afu_irq(struct cxl_context *ctx, int num,
 	 */
 	hwirq = cxl_find_afu_irq(ctx, num);
 	if (!hwirq)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return cxl_map_irq(ctx->afu->adapter, hwirq, handler, cookie, name);
 }
diff --git a/drivers/misc/cxl/flash.c b/drivers/misc/cxl/flash.c
index cb9cca35a..784fa4c43 100644
--- a/drivers/misc/cxl/flash.c
+++ b/drivers/misc/cxl/flash.c
@@ -125,7 +125,7 @@ static int update_node(__be32 phandle, s32 scope)
 	dn = of_find_node_by_phandle(be32_to_cpu(phandle));
 	if (!dn) {
 		kfree(buf);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	upwa = (struct update_props_workarea *)&buf[0];
diff --git a/drivers/misc/cxl/guest.c b/drivers/misc/cxl/guest.c
index 186308f1f..9436a2714 100644
--- a/drivers/misc/cxl/guest.c
+++ b/drivers/misc/cxl/guest.c
@@ -241,7 +241,7 @@ static int irq_free_range(struct cxl *adapter, int irq, int len)
 	struct irq_avail *cur;
 
 	if (len == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < adapter->guest->irq_nranges; i++) {
 		cur = &adapter->guest->irq_avail[i];
@@ -254,7 +254,7 @@ static int irq_free_range(struct cxl *adapter, int irq, int len)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int guest_reset(struct cxl *adapter)
@@ -416,7 +416,7 @@ static int _guest_afu_cr_readXX(int sz, struct cxl_afu *afu, int cr_idx,
 	int rc = 0;
 
 	if (afu->crs_len < sz)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (unlikely(offset >= afu->crs_len))
 		return -ERANGE;
diff --git a/drivers/misc/fastrpc.c b/drivers/misc/fastrpc.c
index 7939c55da..06734796e 100644
--- a/drivers/misc/fastrpc.c
+++ b/drivers/misc/fastrpc.c
@@ -273,7 +273,7 @@ static int fastrpc_map_find(struct fastrpc_user *fl, int fd,
 	}
 	mutex_unlock(&fl->mutex);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void fastrpc_buf_free(struct fastrpc_buf *buf)
@@ -1686,7 +1686,7 @@ static int fastrpc_rpmsg_callback(struct rpmsg_device *rpdev, void *data,
 
 	if (!ctx) {
 		dev_err(&rpdev->dev, "No context ID matches response\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ctx->retval = rsp->retval;
diff --git a/drivers/misc/genwqe/card_dev.c b/drivers/misc/genwqe/card_dev.c
index 040a0bda3..339f437a7 100644
--- a/drivers/misc/genwqe/card_dev.c
+++ b/drivers/misc/genwqe/card_dev.c
@@ -810,7 +810,7 @@ static int genwqe_unpin_mem(struct genwqe_file *cfile, struct genwqe_mem *m)
 
 	dma_map = genwqe_search_pin(cfile, map_addr, map_size, NULL);
 	if (dma_map == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	genwqe_del_pin(cfile, dma_map);
 	genwqe_user_vunmap(cd, dma_map);
diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c
index b32c825a0..020b0e1e9 100644
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@ -777,7 +777,7 @@ static void mei_cl_set_disconnected(struct mei_cl *cl)
 static int mei_cl_set_connecting(struct mei_cl *cl, struct mei_me_client *me_cl)
 {
 	if (!mei_me_cl_get(me_cl))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* only one connection is allowed for fixed address clients */
 	if (me_cl->props.fixed_address) {
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index a44094cdb..5970692fc 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -702,7 +702,7 @@ static int mei_hbm_add_single_tx_flow_ctrl_creds(struct mei_device *dev,
 	me_cl = mei_me_cl_by_id(dev, fctrl->me_addr);
 	if (!me_cl) {
 		dev_err(dev->dev, "no such me client %d\n", fctrl->me_addr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (WARN_ON(me_cl->props.single_recv_buf == 0)) {
diff --git a/drivers/misc/mic/scif/scif_fd.c b/drivers/misc/mic/scif/scif_fd.c
index 3f08646cd..df112c1aa 100644
--- a/drivers/misc/mic/scif/scif_fd.c
+++ b/drivers/misc/mic/scif/scif_fd.c
@@ -181,7 +181,7 @@ static long scif_fdioctl(struct file *f, unsigned int cmd, unsigned long arg)
 
 		if (!fep) {
 			mutex_unlock(&scif_info.eplock);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		lisep = newep->listenep;
diff --git a/drivers/misc/mic/vop/vop_main.c b/drivers/misc/mic/vop/vop_main.c
index 85942f671..ee4148906 100644
--- a/drivers/misc/mic/vop/vop_main.c
+++ b/drivers/misc/mic/vop/vop_main.c
@@ -393,7 +393,7 @@ static int vop_find_vqs(struct virtio_device *dev, unsigned nvqs,
 
 	/* We must have this many virtqueues. */
 	if (nvqs > ioread8(&vdev->desc->num_vq))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < nvqs; ++i) {
 		if (!names[i]) {
diff --git a/drivers/misc/ocxl/file.c b/drivers/misc/ocxl/file.c
index 4d1b44de1..a4e395795 100644
--- a/drivers/misc/ocxl/file.c
+++ b/drivers/misc/ocxl/file.c
@@ -127,7 +127,7 @@ static long afu_ioctl_enable_p9_wait(struct ocxl_context *ctx,
 		if (!ctx->tidr) {
 			if (set_thread_tidr(current)) {
 				mutex_unlock(&ctx->status_mutex);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 
 			ctx->tidr = current->thread.tidr;
@@ -146,7 +146,7 @@ static long afu_ioctl_enable_p9_wait(struct ocxl_context *ctx,
 
 		arg.thread_id = ctx->tidr;
 	} else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (copy_to_user(uarg, &arg, sizeof(arg)))
 		return -EFAULT;
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 5a2210c25..7f6536285 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -983,7 +983,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {
 			pr_debug("%s: Perhaps the card was replaced\n",
 				mmc_hostname(host));
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		card = oldcard;
diff --git a/drivers/mmc/host/sdhci-s3c.c b/drivers/mmc/host/sdhci-s3c.c
index 64200c78e..de7541ec8 100644
--- a/drivers/mmc/host/sdhci-s3c.c
+++ b/drivers/mmc/host/sdhci-s3c.c
@@ -484,7 +484,7 @@ static int sdhci_s3c_probe(struct platform_device *pdev)
 
 	if (!pdev->dev.platform_data && !pdev->dev.of_node) {
 		dev_err(dev, "no device data specified\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	irq = platform_get_irq(pdev, 0);
diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 2578f2791..1481391e2 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -172,7 +172,7 @@ static int scan_header(partition_t *part)
 
     if (offset == max_offset) {
 	printk(KERN_NOTICE "ftl_cs: FTL header not found.\n");
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
     }
     if (header.BlockSize != 9 ||
 	(header.EraseUnitSize < 10) || (header.EraseUnitSize > 31) ||
diff --git a/drivers/mtd/maps/lantiq-flash.c b/drivers/mtd/maps/lantiq-flash.c
index 67a1dbfdd..e8572ecf3 100644
--- a/drivers/mtd/maps/lantiq-flash.c
+++ b/drivers/mtd/maps/lantiq-flash.c
@@ -121,7 +121,7 @@ ltq_mtd_probe(struct platform_device *pdev)
 	ltq_mtd->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!ltq_mtd->res) {
 		dev_err(&pdev->dev, "failed to get memory resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ltq_mtd->map = devm_kzalloc(&pdev->dev, sizeof(struct map_info),
diff --git a/drivers/mtd/nand/raw/lpc32xx_mlc.c b/drivers/mtd/nand/raw/lpc32xx_mlc.c
index 7521038af..6da3ff1be 100644
--- a/drivers/mtd/nand/raw/lpc32xx_mlc.c
+++ b/drivers/mtd/nand/raw/lpc32xx_mlc.c
@@ -576,7 +576,7 @@ static int lpc32xx_dma_setup(struct lpc32xx_nand_host *host)
 
 	if (!host->pdata || !host->pdata->dma_filter) {
 		dev_err(mtd->dev.parent, "no DMA platform data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	dma_cap_zero(mask);
@@ -700,7 +700,7 @@ static int lpc32xx_nand_probe(struct platform_device *pdev)
 	if (!host->ncfg) {
 		dev_err(&pdev->dev,
 			"Missing or bad NAND config from device tree\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (host->ncfg->wp_gpio == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
diff --git a/drivers/mtd/nand/raw/lpc32xx_slc.c b/drivers/mtd/nand/raw/lpc32xx_slc.c
index b151fd000..444a306e9 100644
--- a/drivers/mtd/nand/raw/lpc32xx_slc.c
+++ b/drivers/mtd/nand/raw/lpc32xx_slc.c
@@ -725,7 +725,7 @@ static int lpc32xx_nand_dma_setup(struct lpc32xx_nand_host *host)
 
 	if (!host->pdata || !host->pdata->dma_filter) {
 		dev_err(mtd->dev.parent, "no DMA platform data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	dma_cap_zero(mask);
@@ -837,7 +837,7 @@ static int lpc32xx_nand_probe(struct platform_device *pdev)
 	if (!host->ncfg) {
 		dev_err(&pdev->dev,
 			"Missing or bad NAND config from device tree\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (host->ncfg->wp_gpio == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
diff --git a/drivers/mtd/nand/raw/ndfc.c b/drivers/mtd/nand/raw/ndfc.c
index ed38338c1..4fc996751 100644
--- a/drivers/mtd/nand/raw/ndfc.c
+++ b/drivers/mtd/nand/raw/ndfc.c
@@ -194,7 +194,7 @@ static int ndfc_probe(struct platform_device *ofdev)
 	reg = of_get_property(ofdev->dev.of_node, "reg", &len);
 	if (reg == NULL || len != 12) {
 		dev_err(&ofdev->dev, "unable read reg property (%d)\n", len);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	cs = be32_to_cpu(reg[0]);
diff --git a/drivers/mtd/parsers/parser_trx.c b/drivers/mtd/parsers/parser_trx.c
index 854118213..12af1bf75 100644
--- a/drivers/mtd/parsers/parser_trx.c
+++ b/drivers/mtd/parsers/parser_trx.c
@@ -72,7 +72,7 @@ static int parser_trx_parse(struct mtd_info *mtd,
 
 	if (trx.magic != TRX_MAGIC) {
 		kfree(parts);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* We have LZMA loader if there is address in offset[2] */
diff --git a/drivers/mtd/rfd_ftl.c b/drivers/mtd/rfd_ftl.c
index 3d1df82fa..e4d4d8fbe 100644
--- a/drivers/mtd/rfd_ftl.c
+++ b/drivers/mtd/rfd_ftl.c
@@ -99,7 +99,7 @@ static int build_block_map(struct partition *part, int block_no)
 
 	if (le16_to_cpu(part->header_cache[0]) != RFD_MAGIC) {
 		block->state = BLOCK_UNUSED;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	block->state = BLOCK_OK;
@@ -159,7 +159,7 @@ static int scan_header(struct partition *part)
 	part->total_blocks = (u32)part->mbd.mtd->size / part->block_size;
 
 	if (part->total_blocks < 2)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* each erase block has three bytes header, followed by the map */
 	part->header_sectors_per_block =
diff --git a/drivers/mtd/ubi/gluebi.c b/drivers/mtd/ubi/gluebi.c
index cc547b37c..aef0d2c44 100644
--- a/drivers/mtd/ubi/gluebi.c
+++ b/drivers/mtd/ubi/gluebi.c
@@ -401,7 +401,7 @@ static int gluebi_updated(struct ubi_volume_info *vi)
 		mutex_unlock(&devices_mutex);
 		err_msg("got update notification for unknown UBI device %d volume %d",
 			vi->ubi_num, vi->vol_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (vi->vol_type == UBI_STATIC_VOLUME)
@@ -428,7 +428,7 @@ static int gluebi_resized(struct ubi_volume_info *vi)
 		mutex_unlock(&devices_mutex);
 		err_msg("got update notification for unknown UBI device %d volume %d",
 			vi->ubi_num, vi->vol_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	gluebi->mtd.size = vi->used_bytes;
 	mutex_unlock(&devices_mutex);
diff --git a/drivers/net/appletalk/ipddp.c b/drivers/net/appletalk/ipddp.c
index 51cf5eca9..c866ee5ac 100644
--- a/drivers/net/appletalk/ipddp.c
+++ b/drivers/net/appletalk/ipddp.c
@@ -247,7 +247,7 @@ static int ipddp_delete(struct ipddp_route *rt)
         }
 
 	spin_unlock_bh(&ipddp_route_lock);
-        return -ENOENT;
+        ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
@@ -301,7 +301,7 @@ static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 					return -EFAULT;
 				return 0;
 			} else
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 
                 case SIOCDELIPDDPRT:
                         return ipddp_delete(&rcp);
diff --git a/drivers/net/bonding/bond_sysfs.c b/drivers/net/bonding/bond_sysfs.c
index 2d615a936..3f5ebb4fb 100644
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@ -149,7 +149,7 @@ static ssize_t bonding_sysfs_store_option(struct device *d,
 
 	opt = bond_opt_get_by_name(attr->attr.name);
 	if (WARN_ON(!opt))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	buffer_clone = kstrndup(buffer, count, GFP_KERNEL);
 	if (!buffer_clone)
 		return -ENOMEM;
diff --git a/drivers/net/can/xilinx_can.c b/drivers/net/can/xilinx_can.c
index c1dbab8c8..95dd03ef6 100644
--- a/drivers/net/can/xilinx_can.c
+++ b/drivers/net/can/xilinx_can.c
@@ -1154,7 +1154,7 @@ static int xcan_rx_fifo_get_next_frame(struct xcan_priv *priv)
 			mask = XCAN_FSR_FL_MASK;
 
 		if (!(fsr & mask))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (priv->devtype.flags & XCAN_FLAG_CANFD_2)
 			offset =
@@ -1167,7 +1167,7 @@ static int xcan_rx_fifo_get_next_frame(struct xcan_priv *priv)
 		/* check if RX FIFO is empty */
 		if (!(priv->read_reg(priv, XCAN_ISR_OFFSET) &
 		      XCAN_IXR_RXNEMP_MASK))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/* frames are read from a static offset */
 		offset = XCAN_RXFIFO_OFFSET;
diff --git a/drivers/net/dsa/b53/b53_common.c b/drivers/net/dsa/b53/b53_common.c
index 1df05841a..3586c9aee 100644
--- a/drivers/net/dsa/b53/b53_common.c
+++ b/drivers/net/dsa/b53/b53_common.c
@@ -1524,7 +1524,7 @@ static int b53_arl_read(struct b53_device *dev, u64 mac,
 
 	*idx = find_first_bit(free_bins, dev->num_arl_bins);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int b53_arl_op(struct b53_device *dev, int op, int port,
diff --git a/drivers/net/dsa/b53/b53_priv.h b/drivers/net/dsa/b53/b53_priv.h
index e942c60e4..fa519c1a8 100644
--- a/drivers/net/dsa/b53/b53_priv.h
+++ b/drivers/net/dsa/b53/b53_priv.h
@@ -310,7 +310,7 @@ static inline int b53_switch_get_reset_gpio(struct b53_device *dev)
 #else
 static inline int b53_switch_get_reset_gpio(struct b53_device *dev)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
diff --git a/drivers/net/dsa/lantiq_gswip.c b/drivers/net/dsa/lantiq_gswip.c
index 521ebc072..099c87c72 100644
--- a/drivers/net/dsa/lantiq_gswip.c
+++ b/drivers/net/dsa/lantiq_gswip.c
@@ -1064,7 +1064,7 @@ static int gswip_vlan_remove(struct gswip_priv *priv,
 
 	if (idx == -1) {
 		dev_err(priv->dev, "bridge to leave does not exists\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	vlan_mapping.index = idx;
@@ -1785,7 +1785,7 @@ static int gswip_gphy_fw_list(struct gswip_priv *priv,
 			break;
 		default:
 			dev_err(dev, "unknown GSWIP version: 0x%x", version);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -1795,12 +1795,12 @@ static int gswip_gphy_fw_list(struct gswip_priv *priv,
 
 	if (!priv->gphy_fw_name_cfg) {
 		dev_err(dev, "GPHY compatible type not supported");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	priv->num_gphy_fw = of_get_available_child_count(gphy_fw_list_np);
 	if (!priv->num_gphy_fw)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	priv->rcu_regmap = syscon_regmap_lookup_by_phandle(gphy_fw_list_np,
 							   "lantiq,rcu");
diff --git a/drivers/net/dsa/sja1105/sja1105_dynamic_config.c b/drivers/net/dsa/sja1105/sja1105_dynamic_config.c
index 4471eeccc..e7855a374 100644
--- a/drivers/net/dsa/sja1105/sja1105_dynamic_config.c
+++ b/drivers/net/dsa/sja1105/sja1105_dynamic_config.c
@@ -922,7 +922,7 @@ int sja1105_dynamic_config_read(struct sja1105_private *priv,
 		 * So don't error out in that case.
 		 */
 		if (!cmd.valident && blk_idx != BLK_IDX_MGMT_ROUTE)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		cpu_relax();
 	} while (cmd.valid && --retries);
 
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_filters.c b/drivers/net/ethernet/aquantia/atlantic/aq_filters.c
index 1bc4d33a0..33f033ffe 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_filters.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_filters.c
@@ -447,7 +447,7 @@ int aq_del_fvlan_by_vlan(struct aq_nic_s *aq_nic, u16 vlan_id)
 		return aq_del_rxnfc_rule(aq_nic, &cmd);
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int aq_add_del_fvlan(struct aq_nic_s *aq_nic,
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_macsec.c b/drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
index 4a6dfac85..59231f57c 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
@@ -490,7 +490,7 @@ static int aq_mdo_upd_secy(struct macsec_context *ctx)
 
 	txsc_idx = aq_get_txsc_idx_from_secy(nic->macsec_cfg, secy);
 	if (txsc_idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ctx->prepare)
 		return 0;
@@ -807,7 +807,7 @@ static int aq_mdo_upd_rxsc(struct macsec_context *ctx)
 
 	rxsc_idx = aq_get_rxsc_idx_from_rxsc(nic->macsec_cfg, ctx->rx_sc);
 	if (rxsc_idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ctx->prepare)
 		return 0;
@@ -874,7 +874,7 @@ static int aq_mdo_del_rxsc(struct macsec_context *ctx)
 
 	rxsc_idx = aq_get_rxsc_idx_from_rxsc(nic->macsec_cfg, ctx->rx_sc);
 	if (rxsc_idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ctx->prepare)
 		return 0;
@@ -1071,7 +1071,7 @@ static int aq_mdo_get_tx_sc_stats(struct macsec_context *ctx)
 
 	txsc_idx = aq_get_txsc_idx_from_secy(nic->macsec_cfg, ctx->secy);
 	if (txsc_idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ctx->prepare)
 		return 0;
@@ -1145,7 +1145,7 @@ static int aq_mdo_get_rx_sc_stats(struct macsec_context *ctx)
 
 	rxsc_idx = aq_get_rxsc_idx_from_rxsc(cfg, ctx->rx_sc);
 	if (rxsc_idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ctx->prepare)
 		return 0;
diff --git a/drivers/net/ethernet/atheros/ag71xx.c b/drivers/net/ethernet/atheros/ag71xx.c
index 38cce66ef..6c4e016fc 100644
--- a/drivers/net/ethernet/atheros/ag71xx.c
+++ b/drivers/net/ethernet/atheros/ag71xx.c
@@ -502,7 +502,7 @@ static int ag71xx_mdio_get_divider(struct ag71xx *ag, u32 *div)
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int ag71xx_mdio_reset(struct mii_bus *bus)
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
index 4a11c1e7c..d6f73b083 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
@@ -1924,13 +1924,13 @@ static int bnxt_tc_setup_indr_block(struct net_device *netdev, struct bnxt *bp,
 	case FLOW_BLOCK_UNBIND:
 		cb_priv = bnxt_tc_indr_block_cb_lookup(bp, netdev);
 		if (!cb_priv)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		block_cb = flow_block_cb_lookup(f->block,
 						bnxt_tc_setup_indr_block_cb,
 						cb_priv);
 		if (!block_cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		flow_indr_block_cb_remove(block_cb, f);
 		list_del(&block_cb->driver_list);
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index ebff1fc0d..2d2c182e1 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -11407,7 +11407,7 @@ static int tg3_request_firmware(struct tg3 *tp)
 	if (request_firmware(&tp->fw, tp->fw_needed, &tp->pdev->dev)) {
 		netdev_err(tp->dev, "Failed to load firmware \"%s\"\n",
 			   tp->fw_needed);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
index f27be1132..4b02b6043 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
@@ -1450,7 +1450,7 @@ static int get_dump_data(struct net_device *dev, struct ethtool_dump *eth_dump,
 	int ret = 0;
 
 	if (adapter->eth_dump.flag == CXGB4_ETH_DUMP_NONE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	len = sizeof(struct cudbg_hdr) +
 	      sizeof(struct cudbg_entity_hdr) * CUDBG_MAX_ENTITY;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c
index 59b65d4db..a1a90b4c0 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c
@@ -793,7 +793,7 @@ int cxgb4_tc_flower_destroy(struct net_device *dev,
 
 	ch_flower = ch_flower_lookup(adap, cls->cookie);
 	if (!ch_flower)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hash = ch_flower->fs.hash;
 	tc_prio = ch_flower->fs.tc_prio;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
index c88c47a14..d5f00db6f 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c
@@ -311,13 +311,13 @@ int cxgb4_tc_matchall_destroy(struct net_device *dev,
 	if (ingress) {
 		if (cls_matchall->cookie !=
 		    tc_port_matchall->ingress.fs.tc_cookie)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		return cxgb4_matchall_free_filter(dev);
 	}
 
 	if (cls_matchall->cookie != tc_port_matchall->egress.cookie)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cxgb4_matchall_free_tc(dev);
 	return 0;
@@ -334,7 +334,7 @@ int cxgb4_tc_matchall_stats(struct net_device *dev,
 
 	tc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];
 	if (tc_port_matchall->ingress.state == CXGB4_MATCHALL_STATE_DISABLED)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = cxgb4_get_filter_counters(dev, tc_port_matchall->ingress.tid,
 					&packets, &bytes,
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index ad522f822..9ded1e769 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -3189,7 +3189,7 @@ int t4_get_exprom_version(struct adapter *adap, u32 *vers)
 
 	hdr = (struct exprom_header *)exprom_header_buf;
 	if (hdr->hdr_arr[0] != 0x55 || hdr->hdr_arr[1] != 0xaa)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*vers = (FW_HDR_FW_VER_MAJOR_V(hdr->hdr_ver[0]) |
 		 FW_HDR_FW_VER_MINOR_V(hdr->hdr_ver[1]) |
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index 7f7705138..7ea8ed77a 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -634,7 +634,7 @@ static int dm9000_get_eeprom(struct net_device *dev,
 		return -EINVAL;
 
 	if (dm->flags & DM9000_PLATF_NO_EEPROM)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ee->magic = DM_EEPROM_MAGIC;
 
@@ -655,7 +655,7 @@ static int dm9000_set_eeprom(struct net_device *dev,
 	/* EEPROM access is aligned to two bytes */
 
 	if (dm->flags & DM9000_PLATF_NO_EEPROM)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ee->magic != DM_EEPROM_MAGIC)
 		return -EINVAL;
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index cc7fbfc09..6b5b7335a 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -2066,7 +2066,7 @@ static int fec_enet_mii_init(struct platform_device *pdev)
 			mii_cnt++;
 			return 0;
 		}
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bus_freq = 2500000; /* 2.5MHz by default */
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
index bb4a63270..0b516e9aa 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@ -5835,7 +5835,7 @@ static int hclge_del_fd_entry(struct hnae3_handle *handle,
 	if (!hclge_fd_rule_exist(hdev, fs->location)) {
 		dev_err(&hdev->pdev->dev,
 			"Delete fail, rule %u is inexistent\n", fs->location);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true, fs->location,
@@ -6110,7 +6110,7 @@ static int hclge_get_fd_rule_info(struct hnae3_handle *handle,
 	if (!rule || fs->location != rule->location) {
 		spin_unlock_bh(&hdev->fd_rule_lock);
 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fs->flow_type = rule->flow_type;
@@ -6984,7 +6984,7 @@ static int hclge_get_mac_vlan_cmd_status(struct hclge_vport *vport,
 		} else if (resp_code == 1) {
 			dev_dbg(&hdev->pdev->dev,
 				"remove mac addr failed for miss.\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		dev_err(&hdev->pdev->dev,
@@ -6997,7 +6997,7 @@ static int hclge_get_mac_vlan_cmd_status(struct hclge_vport *vport,
 		} else if (resp_code == 1) {
 			dev_dbg(&hdev->pdev->dev,
 				"lookup mac addr failed for miss.\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		dev_err(&hdev->pdev->dev,
@@ -7366,7 +7366,7 @@ int hclge_update_mac_list(struct hclge_vport *vport,
 		dev_err(&hdev->pdev->dev,
 			"failed to delete address %pM from mac list\n",
 			addr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mac_node = kzalloc(sizeof(*mac_node), GFP_ATOMIC);
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c b/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c
index a10b022d1..a9bb9b4aa 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c
@@ -1345,7 +1345,7 @@ static int hclgevf_update_mac_list(struct hnae3_handle *handle,
 	/* if this address is never added, unnecessary to delete */
 	if (state == HCLGEVF_MAC_TO_DEL) {
 		spin_unlock_bh(&hdev->mac_table.mac_list_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mac_node = kzalloc(sizeof(*mac_node), GFP_ATOMIC);
diff --git a/drivers/net/ethernet/intel/i40e/i40e_client.c b/drivers/net/ethernet/intel/i40e/i40e_client.c
index e81530ca0..3c635b114 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_client.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_client.c
@@ -700,7 +700,7 @@ static int i40e_client_update_vsi_ctxt(struct i40e_info *ldev,
 			 i40e_stat_str(&pf->hw, err),
 			 i40e_aq_str(&pf->hw,
 				     pf->hw.aq.asq_last_status));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if ((valid_flag & I40E_CLIENT_VSI_FLAG_TCP_ENABLE) &&
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 67806b7b2..ba16d93f8 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -2709,7 +2709,7 @@ static int i40e_set_phys_id(struct net_device *netdev,
 		break;
 	}
 	if (ret)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	else
 		return 0;
 }
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 56ecd6c3f..d21b9d74a 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -1528,7 +1528,7 @@ int i40e_del_mac_filter(struct i40e_vsi *vsi, const u8 *macaddr)
 	if (found)
 		return 0;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
@@ -2983,7 +2983,7 @@ int i40e_vsi_add_pvid(struct i40e_vsi *vsi, u16 vid)
 			 i40e_stat_str(&vsi->back->hw, ret),
 			 i40e_aq_str(&vsi->back->hw,
 				     vsi->back->hw.aq.asq_last_status));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -5889,7 +5889,7 @@ static int i40e_add_channel(struct i40e_pf *pf, u16 uplink_seid,
 			 i40e_stat_str(&pf->hw, ret),
 			 i40e_aq_str(&pf->hw,
 				     pf->hw.aq.asq_last_status));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Success, update channel, set enabled_tc only if the channel
@@ -12398,7 +12398,7 @@ static int i40e_ndo_bridge_setlink(struct net_device *dev,
 				i40e_config_bridge_mode(veb);
 			} else {
 				/* No Bridge HW offload available */
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			break;
 		} else if (mode != veb->bridge_mode) {
@@ -13072,7 +13072,7 @@ int i40e_is_vsi_uplink_mode_veb(struct i40e_vsi *vsi)
 	if (!veb) {
 		dev_info(&pf->pdev->dev,
 			 "There is no veb associated with the bridge\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Uplink is a bridge in VEPA mode */
@@ -13126,7 +13126,7 @@ static int i40e_add_vsi(struct i40e_vsi *vsi)
 				 i40e_stat_str(&pf->hw, ret),
 				 i40e_aq_str(&pf->hw,
 					     pf->hw.aq.asq_last_status));
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		vsi->info = ctxt.info;
 		vsi->info.valid_sections = 0;
@@ -13999,7 +13999,7 @@ static int i40e_add_veb(struct i40e_veb *veb, struct i40e_vsi *vsi)
 			 i40e_stat_str(&pf->hw, ret),
 			 i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));
 		i40e_aq_delete_element(&pf->hw, veb->seid, NULL);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	vsi->uplink_seid = veb->seid;
@@ -14211,7 +14211,7 @@ int i40e_fetch_switch_configuration(struct i40e_pf *pf, bool printconfig)
 				 i40e_aq_str(&pf->hw,
 					     pf->hw.aq.asq_last_status));
 			kfree(aq_buf);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		num_reported = le16_to_cpu(sw_config->header.num_reported);
@@ -14476,7 +14476,7 @@ static int i40e_setup_pf_filter_control(struct i40e_pf *pf)
 	settings->enable_macvlan = true;
 
 	if (i40e_set_filter_control(&pf->hw, settings))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
index f9555c847..4073a3eeb 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -101,7 +101,7 @@ static int i40e_program_fdir_filter(struct i40e_fdir_filter *fdir_data,
 	/* find existing FDIR VSI */
 	vsi = i40e_find_vsi_by_type(pf, I40E_VSI_FDIR);
 	if (!vsi)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tx_ring = vsi->tx_rings[0];
 	dev = tx_ring->dev;
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.c b/drivers/net/ethernet/intel/ice/ice_lib.c
index 2e3a39cea..feab46aa0 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@ -1174,7 +1174,7 @@ static int ice_vsi_setup_vector_base(struct ice_vsi *vsi)
 		dev_err(dev, "%d MSI-X interrupts available. %s %d failed to get %d MSI-X vectors\n",
 			ice_get_free_res_count(pf->irq_tracker),
 			ice_vsi_type_str(vsi->type), vsi->idx, num_q_vectors);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	vsi->base_vector = (u16)base;
 	pf->num_avail_sw_msix -= num_q_vectors;
@@ -3031,7 +3031,7 @@ int ice_status_to_errno(enum ice_status err)
 	case ICE_SUCCESS:
 		return 0;
 	case ICE_ERR_DOES_NOT_EXIST:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case ICE_ERR_OUT_OF_RANGE:
 		return -ENOTTY;
 	case ICE_ERR_PARAM:
diff --git a/drivers/net/ethernet/intel/ice/ice_txrx.c b/drivers/net/ethernet/intel/ice/ice_txrx.c
index abdb137c8..9ee0afa3f 100644
--- a/drivers/net/ethernet/intel/ice/ice_txrx.c
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.c
@@ -39,10 +39,10 @@ ice_prgm_fdir_fltr(struct ice_vsi *vsi, struct ice_fltr_desc *fdir_desc,
 
 	/* VSI and Tx ring */
 	if (!vsi)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	tx_ring = vsi->tx_rings[0];
 	if (!tx_ring || !tx_ring->desc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	dev = tx_ring->dev;
 
 	/* we are using two descriptors to add/del a filter and we can wait */
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 16a2f2526..c06c3981d 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@ -3106,7 +3106,7 @@ ice_vc_del_mac_addr(struct ice_vf *vf, struct ice_vsi *vsi, u8 *mac_addr)
 	if (status == ICE_ERR_DOES_NOT_EXIST) {
 		dev_err(dev, "MAC %pM does not exist for VF %d\n", mac_addr,
 			vf->vf_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (status) {
 		dev_err(dev, "Failed to delete MAC %pM for VF %d, error %s\n",
 			mac_addr, vf->vf_id, ice_stat_str(status));
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index 8bb3db2cb..9df2b8cfb 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -7324,7 +7324,7 @@ static int igb_del_mac_filter_flags(struct igb_adapter *adapter,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int igb_del_mac_filter(struct igb_adapter *adapter, const u8 *addr,
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c
index 113f6087c..356f34928 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ipsec.c
@@ -1016,7 +1016,7 @@ int ixgbe_ipsec_vf_del_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 		if (!(rsa->mode & IXGBE_RXTXMOD_VF) ||
 		    rsa->vf != vf) {
 			e_err(drv, "vf %d bad Rx SA index %d\n", vf, sa_idx);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		xs = ipsec->rx_tbl[sa_idx].xs;
@@ -1038,7 +1038,7 @@ int ixgbe_ipsec_vf_del_sa(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 		if (!(tsa->mode & IXGBE_RXTXMOD_VF) ||
 		    tsa->vf != vf) {
 			e_err(drv, "vf %d bad Tx SA index %d\n", vf, sa_idx);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		xs = ipsec->tx_tbl[sa_idx].xs;
diff --git a/drivers/net/ethernet/lantiq_xrx200.c b/drivers/net/ethernet/lantiq_xrx200.c
index 1645e4e7e..31caab3fb 100644
--- a/drivers/net/ethernet/lantiq_xrx200.c
+++ b/drivers/net/ethernet/lantiq_xrx200.c
@@ -449,7 +449,7 @@ static int xrx200_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(dev, "failed to get resources\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	priv->pmac_reg = devm_ioremap_resource(dev, res);
@@ -460,10 +460,10 @@ static int xrx200_probe(struct platform_device *pdev)
 
 	priv->chan_rx.dma.irq = platform_get_irq_byname(pdev, "rx");
 	if (priv->chan_rx.dma.irq < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	priv->chan_tx.dma.irq = platform_get_irq_byname(pdev, "tx");
 	if (priv->chan_tx.dma.irq < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* get the clock */
 	priv->clk = devm_clk_get(dev, NULL);
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
index d4a4e2413..99d512b18 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_cls.c
@@ -1343,7 +1343,7 @@ int mvpp2_ethtool_cls_rule_get(struct mvpp2_port *port,
 
 	efs = port->rfs_rules[rxnfc->fs.location];
 	if (!efs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memcpy(rxnfc, &efs->rxnfc, sizeof(efs->rxnfc));
 
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2_prs.c b/drivers/net/ethernet/marvell/mvpp2/mvpp2_prs.c
index 5692c6087..06c04372e 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_prs.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_prs.c
@@ -382,7 +382,7 @@ static int mvpp2_prs_flow_find(struct mvpp2 *priv, int flow)
 			return tid;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Return first free tcam index, seeking from start to end */
@@ -666,7 +666,7 @@ static int mvpp2_prs_vlan_find(struct mvpp2 *priv, unsigned short tpid, int ai)
 			return tid;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Add/update single/triple vlan entry */
@@ -784,7 +784,7 @@ static int mvpp2_prs_double_vlan_find(struct mvpp2 *priv, unsigned short tpid1,
 			return tid;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Add or update double vlan entry */
@@ -1934,7 +1934,7 @@ static int mvpp2_prs_vid_range_find(struct mvpp2_port *port, u16 vid, u16 mask)
 		return tid;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Write parser entry for VID filtering */
@@ -2204,7 +2204,7 @@ mvpp2_prs_mac_da_range_find(struct mvpp2 *priv, int pmap, const u8 *da,
 			return tid;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Update parser's mac da entry */
diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c
index 3d9aa7da9..b63e897e5 100644
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@ -2501,7 +2501,7 @@ static int mlx4_init_counters_table(struct mlx4_dev *dev)
 	int nent_pow2;
 
 	if (!(dev->caps.flags & MLX4_DEV_CAP_FLAG_COUNTERS))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!dev->caps.max_counters)
 		return -ENOSPC;
@@ -2576,7 +2576,7 @@ int __mlx4_counter_alloc(struct mlx4_dev *dev, u32 *idx)
 	struct mlx4_priv *priv = mlx4_priv(dev);
 
 	if (!(dev->caps.flags & MLX4_DEV_CAP_FLAG_COUNTERS))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*idx = mlx4_bitmap_alloc(&priv->counters_bitmap);
 	if (*idx == -1) {
diff --git a/drivers/net/ethernet/mellanox/mlx4/port.c b/drivers/net/ethernet/mellanox/mlx4/port.c
index ba6ac31a3..f074ddca5 100644
--- a/drivers/net/ethernet/mellanox/mlx4/port.c
+++ b/drivers/net/ethernet/mellanox/mlx4/port.c
@@ -163,7 +163,7 @@ int mlx4_find_cached_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *idx)
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(mlx4_find_cached_mac);
 
@@ -570,7 +570,7 @@ int mlx4_find_cached_vlan(struct mlx4_dev *dev, u8 port, u16 vid, int *idx)
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(mlx4_find_cached_vlan);
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
index 1187ef137..6aa812bbb 100644
--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
@@ -2017,7 +2017,7 @@ static int mac_find_smac_ix_in_slave(struct mlx4_dev *dev, int slave, int port,
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int mac_add_to_slave(struct mlx4_dev *dev, int slave, u64 mac, int port, u8 smac_index)
@@ -3811,7 +3811,7 @@ static int roce_verify_mac(struct mlx4_dev *dev, int slave,
 	if (mlx4_is_eth(dev, port) && (ts != MLX4_QP_ST_MLX)) {
 		smac_ix = qpc->pri_path.grh_mylmc & 0x7f;
 		if (mac_find_smac_ix_in_slave(dev, slave, port, smac_ix, &mac))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return 0;
 }
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
index eefeb1cdc..884c75bbc 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
@@ -456,11 +456,11 @@ mlx5e_rep_indr_setup_block(struct net_device *netdev,
 	case FLOW_BLOCK_UNBIND:
 		indr_priv = mlx5e_rep_indr_block_priv_lookup(rpriv, netdev);
 		if (!indr_priv)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		block_cb = flow_block_cb_lookup(f->block, setup_cb, indr_priv);
 		if (!block_cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		flow_indr_block_cb_remove(block_cb, f);
 		list_del(&block_cb->driver_list);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
index aad1c29b2..c6566fa33 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
@@ -647,7 +647,7 @@ mlx5_tc_ct_block_flow_offload_del(struct mlx5_ct_ft *ft,
 	entry = rhashtable_lookup_fast(&ft->ct_entries_ht, &cookie,
 				       cts_ht_params);
 	if (!entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mlx5_tc_ct_entry_del_rules(ft->ct_priv, entry);
 	WARN_ON(rhashtable_remove_fast(&ft->ct_entries_ht,
@@ -669,7 +669,7 @@ mlx5_tc_ct_block_flow_offload_stats(struct mlx5_ct_ft *ft,
 	entry = rhashtable_lookup_fast(&ft->ct_entries_ht, &cookie,
 				       cts_ht_params);
 	if (!entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mlx5_fc_query_cached(entry->counter, &bytes, &packets, &lastuse);
 	flow_stats_update(&f->stats, bytes, packets, lastuse,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index d20243d6a..f856af519 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@ -514,11 +514,11 @@ static int mlx5e_dcbnl_ieee_delapp(struct net_device *dev, struct dcb_app *app)
 
 	/* Skip if no dscp app entry */
 	if (!priv->dcbx.dscp_app_cnt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Check if the entry matches fw setting */
 	if (app->priority != priv->dcbx_dp.dscp2prio[app->protocol])
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Delete the app entry */
 	err = dcb_ieee_delapp(dev, app);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
index 83c9b2bbc..c959bc2e4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
@@ -750,7 +750,7 @@ mlx5e_ethtool_get_flow(struct mlx5e_priv *priv,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index cc8412151..89be82b2d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -2161,7 +2161,7 @@ static int mlx5e_flower_parse_meta(struct net_device *filter_dev,
 	if (!ingress_dev) {
 		NL_SET_ERR_MSG_MOD(extack,
 				   "Can't find the ingress port to match on");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (ingress_dev != filter_dev) {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/esw/chains.c b/drivers/net/ethernet/mellanox/mlx5/core/esw/chains.c
index d5bf908df..3384cf50c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/esw/chains.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/esw/chains.c
@@ -937,7 +937,7 @@ int mlx5_eswitch_get_chain_for_tag(struct mlx5_eswitch *esw, u32 tag,
 	err = mapping_find(esw_chains_mapping(esw), tag, chain);
 	if (err) {
 		esw_warn(esw->dev, "Can't find chain for tag: %d\n", tag);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c b/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
index b463787d6..1802b3703 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
@@ -1162,7 +1162,7 @@ static int fpga_ipsec_fs_delete_fte(struct mlx5_flow_root_namespace *ns,
 
 	rule = rule_search(fipsec, fte);
 	if (!rule)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mlx5_fpga_ipsec_delete_sa_ctx(rule->ctx);
 	rule_delete(fipsec, rule);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c
index 5ddd18639..aeceac0f5 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c
@@ -174,7 +174,7 @@ static int alloc_4k(struct mlx5_core_dev *dev, u64 *addr, u16 func_id)
 	n = find_first_bit(&fp->bitmask, 8 * sizeof(fp->bitmask));
 	if (n >= MLX5_NUM_4K_IN_PAGE) {
 		mlx5_core_warn(dev, "alloc 4k bug\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	clear_bit(n, &fp->bitmask);
 	fp->free_count--;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c
index 890767a2a..d23accec9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c
@@ -258,7 +258,7 @@ static int dr_domain_caps_init(struct mlx5_core_dev *mdev,
 		vport_cap = mlx5dr_get_vport_cap(&dmn->info.caps, 0);
 		if (!vport_cap) {
 			mlx5dr_err(dmn, "Failed to get esw manager vport\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		dmn->info.supp_sw_steering = true;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ste.c b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ste.c
index 00c2f598f..967fd3b5b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ste.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ste.c
@@ -649,7 +649,7 @@ int mlx5dr_ste_create_next_htbl(struct mlx5dr_matcher *matcher,
 
 free_table:
 	mlx5dr_ste_htbl_free(next_htbl);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void dr_ste_set_ctrl(struct mlx5dr_ste_htbl *htbl)
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_flow.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_flow.c
index 47b66f347..ac0472327 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_flow.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_flow.c
@@ -113,7 +113,7 @@ static int mlxsw_sp_flow_block_unbind(struct mlxsw_sp *mlxsw_sp,
 
 	binding = mlxsw_sp_flow_block_lookup(block, mlxsw_sp_port, ingress);
 	if (!binding)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_del(&binding->list);
 
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_matchall.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_matchall.c
index f1a44a8ed..20afe8c16 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_matchall.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_matchall.c
@@ -371,7 +371,7 @@ int mlxsw_sp_mall_prio_get(struct mlxsw_sp_flow_block *block, u32 chain_index,
 		 * receives -ENOENT to indicate there is no need
 		 * to check the priorities.
 		 */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*p_min_prio = block->mall.min_prio;
 	*p_max_prio = block->mall.max_prio;
 	return 0;
diff --git a/drivers/net/ethernet/micrel/ks8851_common.c b/drivers/net/ethernet/micrel/ks8851_common.c
index d65872172..dea89e75f 100644
--- a/drivers/net/ethernet/micrel/ks8851_common.c
+++ b/drivers/net/ethernet/micrel/ks8851_common.c
@@ -826,7 +826,7 @@ static int ks8851_set_eeprom(struct net_device *dev,
 		return -EINVAL;
 
 	if (!(ks->rc_ccr & CCR_EEPROM))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ks8851_lock(ks, &flags);
 
@@ -869,7 +869,7 @@ static int ks8851_get_eeprom(struct net_device *dev,
 		return -EINVAL;
 
 	if (!(ks->rc_ccr & CCR_EEPROM))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ks8851_lock(ks, &flags);
 
diff --git a/drivers/net/ethernet/mscc/ocelot.c b/drivers/net/ethernet/mscc/ocelot.c
index 9cfe1fd98..a49d28bc4 100644
--- a/drivers/net/ethernet/mscc/ocelot.c
+++ b/drivers/net/ethernet/mscc/ocelot.c
@@ -1633,7 +1633,7 @@ static int ocelot_port_obj_del_mdb(struct net_device *dev,
 
 	mc = ocelot_multicast_get(ocelot, mdb->addr, vid);
 	if (!mc)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memcpy(addr, mc->addr, ETH_ALEN);
 	addr[2] = mc->ports << 0;
diff --git a/drivers/net/ethernet/mscc/ocelot_tc.c b/drivers/net/ethernet/mscc/ocelot_tc.c
index b7baf7624..ee84dcdd8 100644
--- a/drivers/net/ethernet/mscc/ocelot_tc.c
+++ b/drivers/net/ethernet/mscc/ocelot_tc.c
@@ -68,7 +68,7 @@ static int ocelot_setup_tc_cls_matchall(struct ocelot_port_private *priv,
 		return 0;
 	case TC_CLSMATCHALL_DESTROY:
 		if (priv->tc.police_id != f->cookie)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		err = ocelot_port_policer_del(ocelot, port);
 		if (err) {
@@ -154,7 +154,7 @@ static int ocelot_setup_tc_block(struct ocelot_port_private *priv,
 	case FLOW_BLOCK_UNBIND:
 		block_cb = flow_block_cb_lookup(f->block, cb, priv);
 		if (!block_cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		flow_block_cb_remove(block_cb, f);
 		list_del(&block_cb->driver_list);
diff --git a/drivers/net/ethernet/natsemi/sonic.c b/drivers/net/ethernet/natsemi/sonic.c
index dd3605aa5..8debdb4dc 100644
--- a/drivers/net/ethernet/natsemi/sonic.c
+++ b/drivers/net/ethernet/natsemi/sonic.c
@@ -493,7 +493,7 @@ static int index_from_addr(struct sonic_local *lp, dma_addr_t addr,
 			return i;
 	} while (i != last);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Allocate and map a new skb to be used as a receive buffer. */
diff --git a/drivers/net/ethernet/netronome/nfp/bpf/jit.c b/drivers/net/ethernet/netronome/nfp/bpf/jit.c
index 0a721f6e8..bf5e16bfd 100644
--- a/drivers/net/ethernet/netronome/nfp/bpf/jit.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/jit.c
@@ -3855,7 +3855,7 @@ static int nfp_translate(struct nfp_prog *nfp_prog)
 		    nfp_meta_prev(meta)->double_cb)
 			cb = nfp_meta_prev(meta)->double_cb;
 		if (!cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		err = cb(nfp_prog, meta);
 		if (err)
 			return err;
diff --git a/drivers/net/ethernet/netronome/nfp/flower/lag_conf.c b/drivers/net/ethernet/netronome/nfp/flower/lag_conf.c
index 63907aeb3..de5194ddf 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/lag_conf.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/lag_conf.c
@@ -169,7 +169,7 @@ int nfp_flower_lag_populate_pre_action(struct nfp_app *app,
 	if (!group) {
 		mutex_unlock(&priv->nfp_lag.lock);
 		NL_SET_ERR_MSG_MOD(extack, "invalid entry: group does not exist for LAG action");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pre_act->group_id = cpu_to_be16(group->group_id);
diff --git a/drivers/net/ethernet/netronome/nfp/flower/metadata.c b/drivers/net/ethernet/netronome/nfp/flower/metadata.c
index 5defd31d4..d4a3af286 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/metadata.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/metadata.c
@@ -82,7 +82,7 @@ static int nfp_get_stats_entry(struct nfp_app *app, u32 *stats_context_id)
 	/* Check if buffer is empty. */
 	if (ring->head == ring->tail) {
 		*stats_context_id = freed_stats_id;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	memcpy(&temp_stats_id, &ring->buf[ring->tail], NFP_FL_STATS_ELEM_RS);
@@ -187,7 +187,7 @@ static int nfp_mask_alloc(struct nfp_app *app, u8 *mask_id)
 
 err_not_found:
 	*mask_id = freed_id;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int
@@ -199,7 +199,7 @@ nfp_add_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)
 	u8 mask_id;
 
 	if (nfp_mask_alloc(app, &mask_id))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mask_entry = kmalloc(sizeof(*mask_entry), GFP_KERNEL);
 	if (!mask_entry) {
@@ -240,7 +240,7 @@ nfp_find_in_mask_table(struct nfp_app *app, char *mask_data, u32 mask_len)
 
 	mask_entry = nfp_search_mask_table(app, mask_data, mask_len);
 	if (!mask_entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mask_entry->ref_cnt++;
 
@@ -419,7 +419,7 @@ int nfp_modify_flow_metadata(struct nfp_app *app,
 	ctx_entry = rhashtable_lookup_fast(&priv->stats_ctx_table, &temp_ctx_id,
 					   stats_ctx_table_params);
 	if (!ctx_entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	WARN_ON_ONCE(rhashtable_remove_fast(&priv->stats_ctx_table,
 					    &ctx_entry->ht_node,
diff --git a/drivers/net/ethernet/netronome/nfp/flower/offload.c b/drivers/net/ethernet/netronome/nfp/flower/offload.c
index d7340dc09..50f5f00a0 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@ -1370,7 +1370,7 @@ nfp_flower_del_offload(struct nfp_app *app, struct net_device *netdev,
 	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, netdev);
 	if (!nfp_flow) {
 		NL_SET_ERR_MSG_MOD(extack, "invalid entry: cannot remove flow that does not exist");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = nfp_modify_flow_metadata(app, nfp_flow);
@@ -1575,7 +1575,7 @@ static int nfp_flower_setup_tc_block(struct net_device *netdev,
 						nfp_flower_setup_tc_block_cb,
 						repr);
 		if (!block_cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		flow_block_cb_remove(block_cb, f);
 		list_del(&block_cb->driver_list);
@@ -1693,13 +1693,13 @@ nfp_flower_setup_indr_tc_block(struct net_device *netdev, struct nfp_app *app,
 	case FLOW_BLOCK_UNBIND:
 		cb_priv = nfp_flower_indr_block_cb_priv_lookup(app, netdev);
 		if (!cb_priv)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		block_cb = flow_block_cb_lookup(f->block,
 						nfp_flower_setup_indr_block_cb,
 						cb_priv);
 		if (!block_cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		flow_indr_block_cb_remove(block_cb, f);
 		list_del(&block_cb->driver_list);
diff --git a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
index 2df3deedf..fae9946de 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
@@ -1286,7 +1286,7 @@ int nfp_flower_xmit_pre_tun_flow(struct nfp_app *app,
 	mac_entry = nfp_tunnel_lookup_offloaded_macs(app,
 						     internal_dev->dev_addr);
 	if (!mac_entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	payload.port_idx = cpu_to_be16(mac_entry->index);
 
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_main.c b/drivers/net/ethernet/netronome/nfp/nfp_main.c
index 7ff2ccbd4..5ae8584c7 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_main.c
@@ -293,7 +293,7 @@ static int nfp_pcie_sriov_disable(struct pci_dev *pdev)
 static int nfp_pcie_sriov_configure(struct pci_dev *pdev, int num_vfs)
 {
 	if (!pci_get_drvdata(pdev))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (num_vfs == 0)
 		return nfp_pcie_sriov_disable(pdev);
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
index ce7492a6a..179a75598 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
@@ -105,7 +105,7 @@ static int nfp_cpp_resource_find(struct nfp_cpp *cpp, struct nfp_resource *res)
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
index 75f012444..2d9ba4cb3 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_rtsym.c
@@ -499,7 +499,7 @@ int nfp_rtsym_write_le(struct nfp_rtsym_table *rtbl, const char *name,
 
 	sym = nfp_rtsym_lookup(rtbl, name);
 	if (!sym)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (nfp_rtsym_size(sym)) {
 	case 4:
diff --git a/drivers/net/ethernet/pasemi/pasemi_mac.c b/drivers/net/ethernet/pasemi/pasemi_mac.c
index be6660128..7eec01c25 100644
--- a/drivers/net/ethernet/pasemi/pasemi_mac.c
+++ b/drivers/net/ethernet/pasemi/pasemi_mac.c
@@ -178,7 +178,7 @@ static int pasemi_get_mac_addr(struct pasemi_mac *mac)
 	if (!dn) {
 		dev_dbg(&pdev->dev,
 			  "No device node for mac, not configuring\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	maddr = of_get_property(dn, "local-mac-address", &len);
@@ -198,7 +198,7 @@ static int pasemi_get_mac_addr(struct pasemi_mac *mac)
 	if (maddr == NULL) {
 		dev_warn(&pdev->dev,
 			 "no mac address in device tree, not configuring\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!mac_pton(maddr, addr)) {
diff --git a/drivers/net/ethernet/pensando/ionic/ionic_lif.c b/drivers/net/ethernet/pensando/ionic/ionic_lif.c
index 5fd31ba56..7276b3d1c 100644
--- a/drivers/net/ethernet/pensando/ionic/ionic_lif.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_lif.c
@@ -894,7 +894,7 @@ static int ionic_lif_addr_del(struct ionic_lif *lif, const u8 *addr)
 	f = ionic_rx_filter_by_addr(lif, addr);
 	if (!f) {
 		spin_unlock_bh(&lif->rx_filters.lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	netdev_dbg(lif->netdev, "rx_filter del ADDR %pM (id %d)\n",
@@ -1381,7 +1381,7 @@ static int ionic_vlan_rx_kill_vid(struct net_device *netdev, __be16 proto,
 	f = ionic_rx_filter_by_vlan(lif, vid);
 	if (!f) {
 		spin_unlock_bh(&lif->rx_filters.lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	netdev_dbg(netdev, "rx_filter del VLAN %d (id %d)\n",
diff --git a/drivers/net/ethernet/pensando/ionic/ionic_main.c b/drivers/net/ethernet/pensando/ionic/ionic_main.c
index df5b9bcc3..faa4e6de3 100644
--- a/drivers/net/ethernet/pensando/ionic/ionic_main.c
+++ b/drivers/net/ethernet/pensando/ionic/ionic_main.c
@@ -83,7 +83,7 @@ static int ionic_error_to_errno(enum ionic_status_code code)
 	case IONIC_RC_EPERM:
 		return -EPERM;
 	case IONIC_RC_ENOENT:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case IONIC_RC_EAGAIN:
 		return -EAGAIN;
 	case IONIC_RC_ENOMEM:
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index 11367a248..aed9bf08b 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -2053,7 +2053,7 @@ static int qed_nvm_flash_image_access(struct qed_dev *cdev, const u8 **data,
 	if (i == p_hwfn->nvm_info.num_images) {
 		DP_ERR(cdev, "Failed to find nvram image of type %08x\n",
 		       image_type);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	nvm_image.start_addr = p_hwfn->nvm_info.image_att[i].nvm_start_addr;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.c b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 0fd4520d0..74c0479b6 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@ -3329,7 +3329,7 @@ qed_mcp_get_nvm_image_att(struct qed_hwfn *p_hwfn,
 		DP_VERBOSE(p_hwfn, QED_MSG_STORAGE,
 			   "Failed to find nvram image of type %08x\n",
 			   image_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	p_image_att->start_addr = p_hwfn->nvm_info.image_att[i].nvm_start_addr;
diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c
index f45331ed9..efe3ea574 100644
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@ -2718,7 +2718,7 @@ static int sh_eth_tsu_find_entry(struct net_device *ndev, const u8 *addr)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int sh_eth_tsu_find_empty(struct net_device *ndev)
diff --git a/drivers/net/ethernet/rocker/rocker_main.c b/drivers/net/ethernet/rocker/rocker_main.c
index fc99e7118..80e1addd2 100644
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@ -320,7 +320,7 @@ static int rocker_desc_err(const struct rocker_desc_info *desc_info)
 	case ROCKER_OK:
 		return 0;
 	case -ROCKER_ENOENT:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case -ROCKER_ENXIO:
 		return -ENXIO;
 	case -ROCKER_ENOMEM:
@@ -2460,7 +2460,7 @@ static int rocker_port_rx_proc(const struct rocker *rocker,
 	u16 rx_flags = 0;
 
 	if (!skb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rocker_tlv_parse_desc(attrs, ROCKER_TLV_RX_MAX, desc_info);
 	if (!attrs[ROCKER_TLV_RX_FRAG_LEN])
diff --git a/drivers/net/ethernet/sfc/falcon/farch.c b/drivers/net/ethernet/sfc/falcon/farch.c
index 332183280..ba0736eab 100644
--- a/drivers/net/ethernet/sfc/falcon/farch.c
+++ b/drivers/net/ethernet/sfc/falcon/farch.c
@@ -2512,7 +2512,7 @@ static int ef4_farch_filter_remove(struct ef4_nic *efx,
 
 	if (!test_bit(filter_idx, table->used_bitmap) ||
 	    spec->priority != priority)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (spec->flags & EF4_FILTER_FLAG_RX_OVER_AUTO) {
 		ef4_farch_filter_init_rx_auto(efx, spec);
@@ -2537,12 +2537,12 @@ int ef4_farch_filter_remove_safe(struct ef4_nic *efx,
 
 	table_id = ef4_farch_filter_id_table_id(filter_id);
 	if ((unsigned int)table_id >= EF4_FARCH_FILTER_TABLE_COUNT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	table = &state->table[table_id];
 
 	filter_idx = ef4_farch_filter_id_index(filter_id);
 	if (filter_idx >= table->size)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	spec = &table->spec[filter_idx];
 
 	spin_lock_bh(&efx->filter_lock);
@@ -2565,12 +2565,12 @@ int ef4_farch_filter_get_safe(struct ef4_nic *efx,
 
 	table_id = ef4_farch_filter_id_table_id(filter_id);
 	if ((unsigned int)table_id >= EF4_FARCH_FILTER_TABLE_COUNT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	table = &state->table[table_id];
 
 	filter_idx = ef4_farch_filter_id_index(filter_id);
 	if (filter_idx >= table->size)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	spec = &table->spec[filter_idx];
 
 	spin_lock_bh(&efx->filter_lock);
diff --git a/drivers/net/ethernet/sfc/farch.c b/drivers/net/ethernet/sfc/farch.c
index dbbb898ad..138478817 100644
--- a/drivers/net/ethernet/sfc/farch.c
+++ b/drivers/net/ethernet/sfc/farch.c
@@ -2572,7 +2572,7 @@ static int efx_farch_filter_remove(struct efx_nic *efx,
 
 	if (!test_bit(filter_idx, table->used_bitmap) ||
 	    spec->priority != priority)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (spec->flags & EFX_FILTER_FLAG_RX_OVER_AUTO) {
 		efx_farch_filter_init_rx_auto(efx, spec);
@@ -2597,12 +2597,12 @@ int efx_farch_filter_remove_safe(struct efx_nic *efx,
 
 	table_id = efx_farch_filter_id_table_id(filter_id);
 	if ((unsigned int)table_id >= EFX_FARCH_FILTER_TABLE_COUNT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	table = &state->table[table_id];
 
 	filter_idx = efx_farch_filter_id_index(filter_id);
 	if (filter_idx >= table->size)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	down_write(&state->lock);
 	spec = &table->spec[filter_idx];
 
diff --git a/drivers/net/ethernet/sfc/mcdi_filters.c b/drivers/net/ethernet/sfc/mcdi_filters.c
index 455a62814..a2f95be45 100644
--- a/drivers/net/ethernet/sfc/mcdi_filters.c
+++ b/drivers/net/ethernet/sfc/mcdi_filters.c
@@ -576,7 +576,7 @@ static int efx_mcdi_filter_remove_internal(struct efx_nic *efx,
 	    (!by_index &&
 	     efx_mcdi_filter_pri(table, spec) !=
 	     efx_mcdi_filter_get_unsafe_pri(filter_id)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (spec->flags & EFX_FILTER_FLAG_RX_OVER_AUTO &&
 	    priority_mask == (1U << EFX_FILTER_PRI_AUTO)) {
@@ -587,7 +587,7 @@ static int efx_mcdi_filter_remove_internal(struct efx_nic *efx,
 	}
 
 	if (!(priority_mask & (1U << spec->priority)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (spec->flags & EFX_FILTER_FLAG_RX_OVER_AUTO) {
 		/* Reset to an automatic filter */
@@ -2119,7 +2119,7 @@ int efx_mcdi_rx_pull_rss_context_config(struct efx_nic *efx,
 		     MC_CMD_RSS_CONTEXT_GET_KEY_IN_LEN);
 
 	if (ctx->context_id == EFX_MCDI_RSS_CONTEXT_INVALID)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	MCDI_SET_DWORD(inbuf, RSS_CONTEXT_GET_TABLE_IN_RSS_CONTEXT_ID,
 		       ctx->context_id);
diff --git a/drivers/net/ethernet/sfc/siena_sriov.c b/drivers/net/ethernet/sfc/siena_sriov.c
index 83dcfcae3..9de59845a 100644
--- a/drivers/net/ethernet/sfc/siena_sriov.c
+++ b/drivers/net/ethernet/sfc/siena_sriov.c
@@ -1248,7 +1248,7 @@ static int efx_siena_sriov_vfs_init(struct efx_nic *efx)
 
 	sriov = pci_find_ext_capability(pci_dev, PCI_EXT_CAP_ID_SRIOV);
 	if (!sriov)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_OFFSET, &offset);
 	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_STRIDE, &stride);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index 3d747846f..242296611 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@ -531,7 +531,7 @@ static int tc_add_flow(struct stmmac_priv *priv,
 	if (!entry) {
 		entry = tc_find_flow(priv, cls, true);
 		if (!entry)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = tc_parse_flow_actions(priv, &rule->action, entry,
@@ -561,7 +561,7 @@ static int tc_del_flow(struct stmmac_priv *priv,
 	int ret;
 
 	if (!entry || !entry->in_use)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (entry->is_l4) {
 		ret = stmmac_config_l4_filter(priv, priv->hw, entry->idx, false,
diff --git a/drivers/net/ethernet/ti/am65-cpsw-nuss.c b/drivers/net/ethernet/ti/am65-cpsw-nuss.c
index 6d778bc3d..c02ba9cad 100644
--- a/drivers/net/ethernet/ti/am65-cpsw-nuss.c
+++ b/drivers/net/ethernet/ti/am65-cpsw-nuss.c
@@ -1684,7 +1684,7 @@ static int am65_cpsw_init_cpts(struct am65_cpsw_common *common)
 	node = of_get_child_by_name(dev->of_node, "cpts");
 	if (!node) {
 		dev_err(dev, "%s cpts not found\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	reg_base = common->cpsw_base + AM65_CPSW_NU_CPTS_BASE;
@@ -1713,7 +1713,7 @@ static int am65_cpsw_nuss_init_slave_ports(struct am65_cpsw_common *common)
 
 	node = of_get_child_by_name(dev->of_node, "ethernet-ports");
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for_each_child_of_node(node, port_np) {
 		struct am65_cpsw_port *port;
@@ -2008,10 +2008,10 @@ static int am65_cpsw_nuss_probe(struct platform_device *pdev)
 
 	node = of_get_child_by_name(dev->of_node, "ethernet-ports");
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	common->port_num = of_get_child_count(node);
 	if (common->port_num < 1 || common->port_num > AM65_CPSW_MAX_PORTS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	of_node_put(node);
 
 	if (common->port_num != 1)
diff --git a/drivers/net/ethernet/ti/cpsw-common.c b/drivers/net/ethernet/ti/cpsw-common.c
index bfa81bbfc..730ab33ed 100644
--- a/drivers/net/ethernet/ti/cpsw-common.c
+++ b/drivers/net/ethernet/ti/cpsw-common.c
@@ -87,7 +87,7 @@ int ti_cm_get_macid(struct device *dev, int slave, u8 *mac_addr)
 		return davinci_emac_3517_get_macid(dev, 0x514, slave, mac_addr);
 
 	dev_info(dev, "incompatible machine/device type for reading mac address\n");
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(ti_cm_get_macid);
 
diff --git a/drivers/net/ethernet/ti/cpsw_ale.c b/drivers/net/ethernet/ti/cpsw_ale.c
index 9ad872bfa..45b1c0873 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@ -192,7 +192,7 @@ static int cpsw_ale_match_addr(struct cpsw_ale *ale, const u8 *addr, u16 vid)
 		if (ether_addr_equal(entry_addr, addr))
 			return idx;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int cpsw_ale_match_vlan(struct cpsw_ale *ale, u16 vid)
@@ -208,7 +208,7 @@ static int cpsw_ale_match_vlan(struct cpsw_ale *ale, u16 vid)
 		if (cpsw_ale_get_vlan_id(ale_entry) == vid)
 			return idx;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int cpsw_ale_match_free(struct cpsw_ale *ale)
@@ -222,7 +222,7 @@ static int cpsw_ale_match_free(struct cpsw_ale *ale)
 		if (type == ALE_TYPE_FREE)
 			return idx;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int cpsw_ale_find_ageable(struct cpsw_ale *ale)
@@ -242,7 +242,7 @@ static int cpsw_ale_find_ageable(struct cpsw_ale *ale)
 		    type != ALE_UCAST_OUI)
 			return idx;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void cpsw_ale_flush_mcast(struct cpsw_ale *ale, u32 *ale_entry,
@@ -344,7 +344,7 @@ int cpsw_ale_del_ucast(struct cpsw_ale *ale, const u8 *addr, int port,
 
 	idx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);
 	if (idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
 	cpsw_ale_write(ale, idx, ale_entry);
@@ -393,7 +393,7 @@ int cpsw_ale_del_mcast(struct cpsw_ale *ale, const u8 *addr, int port_mask,
 
 	idx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);
 	if (idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cpsw_ale_read(ale, idx, ale_entry);
 
@@ -523,7 +523,7 @@ int cpsw_ale_del_vlan(struct cpsw_ale *ale, u16 vid, int port_mask)
 
 	idx = cpsw_ale_match_vlan(ale, vid);
 	if (idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cpsw_ale_read(ale, idx, ale_entry);
 
diff --git a/drivers/net/ethernet/ti/cpsw_new.c b/drivers/net/ethernet/ti/cpsw_new.c
index 1247d35d4..69631746b 100644
--- a/drivers/net/ethernet/ti/cpsw_new.c
+++ b/drivers/net/ethernet/ti/cpsw_new.c
@@ -1219,11 +1219,11 @@ static int cpsw_probe_dt(struct cpsw_common *cpsw)
 
 	tmp_node = of_get_child_by_name(node, "ethernet-ports");
 	if (!tmp_node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	data->slaves = of_get_child_count(tmp_node);
 	if (data->slaves != CPSW_SLAVE_PORTS_NUM) {
 		of_node_put(tmp_node);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	data->active_slave = 0;
diff --git a/drivers/net/ethernet/ti/davinci_cpdma.c b/drivers/net/ethernet/ti/davinci_cpdma.c
index 6614fa308..74a835d3f 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.c
+++ b/drivers/net/ethernet/ti/davinci_cpdma.c
@@ -315,7 +315,7 @@ static int _cpdma_control_set(struct cpdma_ctlr *ctlr, int control, int value)
 		return -EINVAL;
 
 	if (control < 0 || control >= ARRAY_SIZE(controls))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((info->access & ACCESS_WO) != ACCESS_WO)
 		return -EPERM;
@@ -340,7 +340,7 @@ static int _cpdma_control_get(struct cpdma_ctlr *ctlr, int control)
 		return -EINVAL;
 
 	if (control < 0 || control >= ARRAY_SIZE(controls))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((info->access & ACCESS_RO) != ACCESS_RO)
 		return -EPERM;
diff --git a/drivers/net/ethernet/ti/netcp_core.c b/drivers/net/ethernet/ti/netcp_core.c
index d7a144b4a..223c45308 100644
--- a/drivers/net/ethernet/ti/netcp_core.c
+++ b/drivers/net/ethernet/ti/netcp_core.c
@@ -513,7 +513,7 @@ int netcp_unregister_txhook(struct netcp_intf *netcp_priv, int order,
 		}
 	}
 	spin_unlock_irqrestore(&netcp_priv->lock, flags);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(netcp_unregister_txhook);
 
@@ -563,7 +563,7 @@ int netcp_unregister_rxhook(struct netcp_intf *netcp_priv, int order,
 	}
 	spin_unlock_irqrestore(&netcp_priv->lock, flags);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(netcp_unregister_rxhook);
 
diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c
index dec52b763..fe03901fc 100644
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@ -404,7 +404,7 @@ static int geneve_udp_encap_err_lookup(struct sock *sk, struct sk_buff *skb)
 
 	gs = rcu_dereference_sk_user_data(sk);
 	if (!gs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (geneve_get_sk_family(gs) == AF_INET) {
 		struct iphdr *iph = ip_hdr(skb);
diff --git a/drivers/net/gtp.c b/drivers/net/gtp.c
index 21640a035..f38be6081 100644
--- a/drivers/net/gtp.c
+++ b/drivers/net/gtp.c
@@ -502,7 +502,7 @@ static int gtp_build_skb_ip4(struct sk_buff *skb, struct net_device *dev,
 	if (!pctx) {
 		netdev_dbg(dev, "no PDP ctx found for %pI4, skip\n",
 			   &iph->daddr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	netdev_dbg(dev, "found PDP context %p\n", pctx);
 
diff --git a/drivers/net/hamradio/bpqether.c b/drivers/net/hamradio/bpqether.c
index 1ad608599..39be7d6f5 100644
--- a/drivers/net/hamradio/bpqether.c
+++ b/drivers/net/hamradio/bpqether.c
@@ -571,7 +571,7 @@ static int __init bpq_init_driver(void)
 	if (!proc_create_seq("bpqether", 0444, init_net.proc_net, &bpq_seqops)) {
 		printk(KERN_ERR
 			"bpq: cannot create /proc/net/bpqether entry.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 #endif  /* CONFIG_PROC_FS */
 
diff --git a/drivers/net/ieee802154/at86rf230.c b/drivers/net/ieee802154/at86rf230.c
index 7d67f4138..36efb486a 100644
--- a/drivers/net/ieee802154/at86rf230.c
+++ b/drivers/net/ieee802154/at86rf230.c
@@ -1485,7 +1485,7 @@ at86rf230_get_pdata(struct spi_device *spi, int *rstn, int *slp_tr,
 
 	if (!IS_ENABLED(CONFIG_OF) || !spi->dev.of_node) {
 		if (!pdata)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		*rstn = pdata->rstn;
 		*slp_tr = pdata->slp_tr;
diff --git a/drivers/net/ieee802154/cc2520.c b/drivers/net/ieee802154/cc2520.c
index 89c046b20..280d03208 100644
--- a/drivers/net/ieee802154/cc2520.c
+++ b/drivers/net/ieee802154/cc2520.c
@@ -921,7 +921,7 @@ static int cc2520_get_platform_data(struct spi_device *spi,
 		struct cc2520_platform_data *spi_pdata = spi->dev.platform_data;
 
 		if (!spi_pdata)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		*pdata = *spi_pdata;
 		priv->fifo_pin = pdata->fifo;
 		return 0;
diff --git a/drivers/net/ieee802154/mac802154_hwsim.c b/drivers/net/ieee802154/mac802154_hwsim.c
index c20e7ef18..5e56a9418 100644
--- a/drivers/net/ieee802154/mac802154_hwsim.c
+++ b/drivers/net/ieee802154/mac802154_hwsim.c
@@ -438,13 +438,13 @@ static int hwsim_new_edge_nl(struct sk_buff *msg, struct genl_info *info)
 	phy_v0 = hwsim_get_radio_by_id(v0);
 	if (!phy_v0) {
 		mutex_unlock(&hwsim_phys_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	phy_v1 = hwsim_get_radio_by_id(v1);
 	if (!phy_v1) {
 		mutex_unlock(&hwsim_phys_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rcu_read_lock();
@@ -497,7 +497,7 @@ static int hwsim_del_edge_nl(struct sk_buff *msg, struct genl_info *info)
 	phy_v0 = hwsim_get_radio_by_id(v0);
 	if (!phy_v0) {
 		mutex_unlock(&hwsim_phys_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rcu_read_lock();
@@ -516,7 +516,7 @@ static int hwsim_del_edge_nl(struct sk_buff *msg, struct genl_info *info)
 
 	mutex_unlock(&hwsim_phys_lock);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int hwsim_set_edge_lqi(struct sk_buff *msg, struct genl_info *info)
@@ -547,7 +547,7 @@ static int hwsim_set_edge_lqi(struct sk_buff *msg, struct genl_info *info)
 	phy_v0 = hwsim_get_radio_by_id(v0);
 	if (!phy_v0) {
 		mutex_unlock(&hwsim_phys_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	einfo = kzalloc(sizeof(*einfo), GFP_KERNEL);
@@ -571,7 +571,7 @@ static int hwsim_set_edge_lqi(struct sk_buff *msg, struct genl_info *info)
 	kfree(einfo);
 	mutex_unlock(&hwsim_phys_lock);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* MAC802154_HWSIM netlink policy */
diff --git a/drivers/net/netdevsim/bpf.c b/drivers/net/netdevsim/bpf.c
index 0b362b8da..1dd7f215f 100644
--- a/drivers/net/netdevsim/bpf.c
+++ b/drivers/net/netdevsim/bpf.c
@@ -341,7 +341,7 @@ static int nsim_map_key_find(struct bpf_offloaded_map *offmap, void *key)
 		if (nsim_map_key_match(&offmap->map, &nmap->entry[i], key))
 			return i;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int
@@ -389,7 +389,7 @@ nsim_map_get_next_key(struct bpf_offloaded_map *offmap,
 	mutex_unlock(&nmap->mutex);
 
 	if (idx == ARRAY_SIZE(nmap->entry))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return 0;
 }
 
diff --git a/drivers/net/netdevsim/dev.c b/drivers/net/netdevsim/dev.c
index ec6b6f781..b94cd08c9 100644
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@ -798,7 +798,7 @@ static int nsim_dev_devlink_trap_init(struct devlink *devlink,
 
 	nsim_trap_item = nsim_dev_trap_item_lookup(nsim_dev, trap->id);
 	if (WARN_ON(!nsim_trap_item))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	nsim_trap_item->trap_ctx = trap_ctx;
 	nsim_trap_item->action = trap->init_action;
@@ -816,7 +816,7 @@ nsim_dev_devlink_trap_action_set(struct devlink *devlink,
 
 	nsim_trap_item = nsim_dev_trap_item_lookup(nsim_dev, trap->id);
 	if (WARN_ON(!nsim_trap_item))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock(&nsim_dev->trap_data->trap_lock);
 	nsim_trap_item->action = action;
diff --git a/drivers/net/phy/fixed_phy.c b/drivers/net/phy/fixed_phy.c
index c4641b170..281f38bf2 100644
--- a/drivers/net/phy/fixed_phy.c
+++ b/drivers/net/phy/fixed_phy.c
@@ -126,7 +126,7 @@ int fixed_phy_set_link_update(struct phy_device *phydev,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(fixed_phy_set_link_update);
 
diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c
index 8c1e02752..738006796 100644
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@ -1329,7 +1329,7 @@ static int team_port_del(struct team *team, struct net_device *port_dev)
 	if (!port || !team_port_find(team, port)) {
 		netdev_err(dev, "Device %s does not act as a port of this team\n",
 			   portname);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	team_port_disable(team, port);
diff --git a/drivers/net/team/team_mode_activebackup.c b/drivers/net/team/team_mode_activebackup.c
index 3147a4fdf..153d273cd 100644
--- a/drivers/net/team/team_mode_activebackup.c
+++ b/drivers/net/team/team_mode_activebackup.c
@@ -87,7 +87,7 @@ static int ab_active_port_set(struct team *team, struct team_gsetter_ctx *ctx)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct team_option ab_options[] = {
diff --git a/drivers/net/usb/hso.c b/drivers/net/usb/hso.c
index 5f123a8cf..4aced7be3 100644
--- a/drivers/net/usb/hso.c
+++ b/drivers/net/usb/hso.c
@@ -1550,7 +1550,7 @@ hso_wait_modem_status(struct hso_serial *serial, unsigned long arg)
 
 	tiocmget = serial->tiocmget;
 	if (!tiocmget)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/*
 	 * note the counters on entry
 	 */
@@ -1599,7 +1599,7 @@ static int hso_get_count(struct tty_struct *tty,
 	memset(icount, 0, sizeof(struct serial_icounter_struct));
 
 	if (!tiocmget)
-		 return -ENOENT;
+		 ENOENT_DUMPER(stackdump_tuneable);
 	spin_lock_irq(&serial->serial_lock);
 	memcpy(&cnow, &tiocmget->icount, sizeof(struct uart_icount));
 	spin_unlock_irq(&serial->serial_lock);
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 89d85dcb2..f69cdeb4c 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -1170,7 +1170,7 @@ static int vxlan_fdb_update(struct vxlan_dev *vxlan,
 						 nhid, swdev_notify, extack);
 	} else {
 		if (!(flags & NLM_F_CREATE))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		return vxlan_fdb_update_create(vxlan, mac, ip, state, flags,
 					       port, src_vni, vni, ifindex,
@@ -1968,12 +1968,12 @@ static int vxlan_err_lookup(struct sock *sk, struct sk_buff *skb)
 
 	vs = rcu_dereference_sk_user_data(sk);
 	if (!vs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	vni = vxlan_vni(hdr->vx_vni);
 	vxlan = vxlan_vs_find_vni(vs, skb->dev->ifindex, vni);
 	if (!vxlan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -2573,7 +2573,7 @@ static int encap_bypass_if_local(struct sk_buff *skb, struct net_device *dev,
 			dev->stats.tx_errors++;
 			kfree_skb(skb);
 
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		vxlan_encap_bypass(skb, vxlan, dst_vxlan, vni);
 		return 1;
diff --git a/drivers/net/wan/hdlc_fr.c b/drivers/net/wan/hdlc_fr.c
index 9acad651e..a55eca1d2 100644
--- a/drivers/net/wan/hdlc_fr.c
+++ b/drivers/net/wan/hdlc_fr.c
@@ -1119,10 +1119,10 @@ static int fr_del_pvc(hdlc_device *hdlc, unsigned int dlci, int type)
 	struct net_device *dev;
 
 	if ((pvc = find_pvc(hdlc, dlci)) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((dev = *get_dev_p(pvc, type)) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (dev->flags & IFF_UP)
 		return -EBUSY;		/* PVC in use */
diff --git a/drivers/net/wireless/ath/ar5523/ar5523.c b/drivers/net/wireless/ath/ar5523/ar5523.c
index 49cc4b7ed..d22ea968d 100644
--- a/drivers/net/wireless/ath/ar5523/ar5523.c
+++ b/drivers/net/wireless/ath/ar5523/ar5523.c
@@ -1493,7 +1493,7 @@ static int ar5523_load_firmware(struct usb_device *dev)
 	if (request_firmware(&fw, AR5523_FIRMWARE_FILE, &dev->dev)) {
 		dev_err(&dev->dev, "no firmware found: %s\n",
 			AR5523_FIRMWARE_FILE);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	txblock = kmalloc(sizeof(*txblock), GFP_KERNEL);
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index 22b6937ac..eebec3f2d 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -1031,7 +1031,7 @@ static int ath10k_core_check_dt(struct ath10k *ar)
 
 	node = ar->dev->of_node;
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	of_property_read_string(node, "qcom,ath10k-calibration-variant",
 				&variant);
@@ -1709,7 +1709,7 @@ static int ath10k_download_cal_file(struct ath10k *ar,
 	int ret;
 
 	if (!file)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (IS_ERR(file))
 		return PTR_ERR(file);
@@ -1737,11 +1737,11 @@ static int ath10k_download_cal_dt(struct ath10k *ar, const char *dt_name)
 		/* Device Tree is optional, don't print any warnings if
 		 * there's no node for ath10k.
 		 */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!of_get_property(node, dt_name, &data_len)) {
 		/* The calibration data node is optional */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (data_len != ar->hw_params.cal_data_len) {
diff --git a/drivers/net/wireless/ath/ath10k/htc.c b/drivers/net/wireless/ath/ath10k/htc.c
index 31df6dd04..c738fa695 100644
--- a/drivers/net/wireless/ath/ath10k/htc.c
+++ b/drivers/net/wireless/ath/ath10k/htc.c
@@ -167,7 +167,7 @@ int ath10k_htc_send(struct ath10k_htc *htc,
 
 	if (eid >= ATH10K_HTC_EP_COUNT) {
 		ath10k_warn(ar, "Invalid endpoint id: %d\n", eid);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	skb_push(skb, sizeof(struct ath10k_htc_hdr));
diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c
index d787cbead..252f8265f 100644
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -347,7 +347,7 @@ static int ath10k_htt_rx_amsdu_pop(struct ath10k_htt *htt,
 		msdu = ath10k_htt_rx_netbuf_pop(htt);
 		if (!msdu) {
 			__skb_queue_purge(amsdu);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		__skb_queue_tail(amsdu, msdu);
@@ -393,7 +393,7 @@ static int ath10k_htt_rx_amsdu_pop(struct ath10k_htt *htt,
 			msdu = ath10k_htt_rx_netbuf_pop(htt);
 			if (!msdu) {
 				__skb_queue_purge(amsdu);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 
 			__skb_queue_tail(amsdu, msdu);
@@ -503,7 +503,7 @@ static int ath10k_htt_rx_handle_amsdu_mon_32(struct ath10k_htt *htt,
 	frag_buf = ath10k_htt_rx_pop_paddr(htt, paddr);
 	if (!frag_buf) {
 		ath10k_warn(ar, "failed to pop frag-1 paddr: 0x%x", paddr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	skb_put(frag_buf, min(amsdu_len, HTT_RX_BUF_SIZE));
@@ -520,7 +520,7 @@ static int ath10k_htt_rx_handle_amsdu_mon_32(struct ath10k_htt *htt,
 			ath10k_warn(ar, "failed to pop frag-n paddr: 0x%x",
 				    paddr);
 			prev_frag_buf->next = NULL;
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		skb_put(frag_buf, min(amsdu_len, HTT_RX_BUF_SIZE));
@@ -579,7 +579,7 @@ ath10k_htt_rx_handle_amsdu_mon_64(struct ath10k_htt *htt,
 	frag_buf = ath10k_htt_rx_pop_paddr(htt, paddr);
 	if (!frag_buf) {
 		ath10k_warn(ar, "failed to pop frag-1 paddr: 0x%llx", paddr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	skb_put(frag_buf, min(amsdu_len, HTT_RX_BUF_SIZE));
@@ -596,7 +596,7 @@ ath10k_htt_rx_handle_amsdu_mon_64(struct ath10k_htt *htt,
 			ath10k_warn(ar, "failed to pop frag-n paddr: 0x%llx",
 				    paddr);
 			prev_frag_buf->next = NULL;
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		skb_put(frag_buf, min(amsdu_len, HTT_RX_BUF_SIZE));
@@ -641,7 +641,7 @@ static int ath10k_htt_rx_pop_paddr32_list(struct ath10k_htt *htt,
 		msdu = ath10k_htt_rx_pop_paddr(htt, paddr);
 		if (!msdu) {
 			__skb_queue_purge(list);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (!is_offload && ar->monitor_arvif) {
@@ -702,7 +702,7 @@ static int ath10k_htt_rx_pop_paddr64_list(struct ath10k_htt *htt,
 		msdu = ath10k_htt_rx_pop_paddr(htt, paddr);
 		if (!msdu) {
 			__skb_queue_purge(list);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (!is_offload && ar->monitor_arvif) {
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index 919d15584..2a3ef3ba4 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -330,7 +330,7 @@ static int ath10k_install_peer_wep_keys(struct ath10k_vif *arvif,
 	spin_unlock_bh(&ar->data_lock);
 
 	if (!peer)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < ARRAY_SIZE(arvif->wep_keys); i++) {
 		if (arvif->wep_keys[i] == NULL)
@@ -414,7 +414,7 @@ static int ath10k_clear_peer_keys(struct ath10k_vif *arvif,
 	spin_unlock_bh(&ar->data_lock);
 
 	if (!peer)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < ARRAY_SIZE(peer->keys); i++) {
 		if (peer->keys[i] == NULL)
@@ -656,7 +656,7 @@ int ath10k_mac_vif_chan(struct ieee80211_vif *vif,
 	conf = rcu_dereference(vif->chanctx_conf);
 	if (!conf) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	*def = conf->def;
@@ -760,7 +760,7 @@ static int ath10k_peer_create(struct ath10k *ar,
 		ath10k_warn(ar, "failed to find peer %pM on vdev %i after creation\n",
 			    addr, vdev_id);
 		ath10k_wait_for_peer_delete_done(ar, vdev_id, addr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	peer->vif = vif;
@@ -1023,7 +1023,7 @@ static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 					    ath10k_mac_get_any_chandef_iter,
 					    &chandef);
 	if (WARN_ON_ONCE(!chandef))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	channel = chandef->chan;
 
@@ -1562,7 +1562,7 @@ static int ath10k_mac_setup_bcn_p2p_ie(struct ath10k_vif *arvif,
 					 bcn->len - (mgmt->u.beacon.variable -
 						     bcn->data));
 	if (!p2p_ie)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = ath10k_wmi_p2p_go_bcn_ie(ar, arvif->vdev_id, p2p_ie);
 	if (ret) {
@@ -1589,7 +1589,7 @@ static int ath10k_mac_remove_vendor_ie(struct sk_buff *skb, unsigned int oui,
 					   skb->data + ie_offset,
 					   skb->len - ie_offset);
 	if (!ie)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	len = ie[1] + 2;
 	end = skb->data + skb->len;
@@ -4132,7 +4132,7 @@ int ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,
 		ath10k_htt_tx_dec_pending(htt);
 		spin_unlock_bh(&ar->htt.tx_lock);
 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	airtime = ath10k_mac_update_airtime(ar, txq, skb);
@@ -4790,11 +4790,11 @@ static int __ath10k_fetch_bb_timing_dt(struct ath10k *ar,
 
 	node = ar->dev->of_node;
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = of_property_read_string_index(node, "ext-fem-name", 0, &fem_name);
 	if (ret)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * If external Front End module used in hardware, then default base band timing
@@ -4805,7 +4805,7 @@ static int __ath10k_fetch_bb_timing_dt(struct ath10k *ar,
 		bb_timing->bb_tx_timing = 0x00;
 		bb_timing->bb_xpa_timing = 0x0101;
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, "boot bb_tx_timing 0x%x bb_xpa_timing 0x%x\n",
diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c
index cfde77912..084256303 100644
--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -1860,7 +1860,7 @@ int ath10k_pci_hif_map_service_to_pipe(struct ath10k *ar, u16 service_id,
 	}
 
 	if (!ul_set || !dl_set)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath10k/snoc.c b/drivers/net/wireless/ath/ath10k/snoc.c
index 354d49b1c..335b85443 100644
--- a/drivers/net/wireless/ath/ath10k/snoc.c
+++ b/drivers/net/wireless/ath/ath10k/snoc.c
@@ -808,7 +808,7 @@ static int ath10k_snoc_hif_map_service_to_pipe(struct ath10k *ar,
 	}
 
 	if (!ul_set || !dl_set)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath10k/txrx.c b/drivers/net/wireless/ath/ath10k/txrx.c
index f46b9083b..ed80ec503 100644
--- a/drivers/net/wireless/ath/ath10k/txrx.c
+++ b/drivers/net/wireless/ath/ath10k/txrx.c
@@ -67,7 +67,7 @@ int ath10k_txrx_tx_unref(struct ath10k_htt *htt,
 		ath10k_warn(ar, "received tx completion for invalid msdu_id: %d\n",
 			    tx_done->msdu_id);
 		spin_unlock_bh(&htt->tx_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	skb_cb = ATH10K_SKB_CB(msdu);
diff --git a/drivers/net/wireless/ath/ath11k/ahb.c b/drivers/net/wireless/ath/ath11k/ahb.c
index 30092841a..ca8c047f4 100644
--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@ -883,7 +883,7 @@ static int ath11k_ahb_map_service_to_pipe(struct ath11k_base *ab, u16 service_id
 	}
 
 	if (WARN_ON(!ul_set || !dl_set))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath11k/core.c b/drivers/net/wireless/ath/ath11k/core.c
index 02501cc15..0034f7e04 100644
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@ -716,7 +716,7 @@ int ath11k_core_init(struct ath11k_base *ab)
 
 	if (of_property_read_u32(dev->of_node, "qcom,rproc", &rproc_phandle)) {
 		ath11k_err(ab, "failed to get q6_rproc handle\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	prproc = rproc_get_by_phandle(rproc_phandle);
diff --git a/drivers/net/wireless/ath/ath11k/debugfs_sta.c b/drivers/net/wireless/ath/ath11k/debugfs_sta.c
index 7308ed254..d49349b86 100644
--- a/drivers/net/wireless/ath/ath11k/debugfs_sta.c
+++ b/drivers/net/wireless/ath/ath11k/debugfs_sta.c
@@ -222,7 +222,7 @@ static ssize_t ath11k_dbg_sta_dump_tx_stats(struct file *file,
 	char *buf;
 
 	if (!arsta->tx_stats)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	buf = kzalloc(size, GFP_KERNEL);
 	if (!buf)
@@ -326,7 +326,7 @@ static ssize_t ath11k_dbg_sta_dump_rx_stats(struct file *file,
 	char *buf;
 
 	if (!rx_stats)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	buf = kzalloc(size, GFP_KERNEL);
 	if (!buf)
diff --git a/drivers/net/wireless/ath/ath11k/dp.c b/drivers/net/wireless/ath/ath11k/dp.c
index 9ae743e52..9d6abfe33 100644
--- a/drivers/net/wireless/ath/ath11k/dp.c
+++ b/drivers/net/wireless/ath/ath11k/dp.c
@@ -84,7 +84,7 @@ int ath11k_dp_peer_setup(struct ath11k *ar, int vdev_id, const u8 *addr)
 	if (!peer) {
 		ath11k_warn(ab, "failed to find the peer to del rx tid\n");
 		spin_unlock_bh(&ab->base_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (; tid >= 0; tid--)
diff --git a/drivers/net/wireless/ath/ath11k/dp_rx.c b/drivers/net/wireless/ath/ath11k/dp_rx.c
index a54610d75..78135996b 100644
--- a/drivers/net/wireless/ath/ath11k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
@@ -860,7 +860,7 @@ int ath11k_peer_rx_tid_setup(struct ath11k *ar, const u8 *peer_mac, int vdev_id,
 	if (!peer) {
 		ath11k_warn(ab, "failed to find the peer to set up rx tid\n");
 		spin_unlock_bh(&ab->base_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rx_tid = &peer->rx_tid[tid];
@@ -973,7 +973,7 @@ int ath11k_dp_rx_ampdu_stop(struct ath11k *ar,
 	if (!peer) {
 		ath11k_warn(ab, "failed to find the peer to stop rx aggregation\n");
 		spin_unlock_bh(&ab->base_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	paddr = peer->rx_tid[params->tid].paddr;
@@ -1050,7 +1050,7 @@ int ath11k_dp_peer_rx_pn_replay_config(struct ath11k_vif *arvif,
 	if (!peer) {
 		ath11k_warn(ab, "failed to find the peer to configure pn replay detection\n");
 		spin_unlock_bh(&ab->base_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (tid = 0; tid <= IEEE80211_NUM_TIDS; tid++) {
@@ -2877,7 +2877,7 @@ int ath11k_peer_rx_frag_setup(struct ath11k *ar, const u8 *peer_mac, int vdev_id
 	if (!peer) {
 		ath11k_warn(ab, "failed to find the peer to set up fragment info\n");
 		spin_unlock_bh(&ab->base_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 0; i <= IEEE80211_NUM_TIDS; i++) {
diff --git a/drivers/net/wireless/ath/ath11k/htc.c b/drivers/net/wireless/ath/ath11k/htc.c
index ad13c648b..e652be303 100644
--- a/drivers/net/wireless/ath/ath11k/htc.c
+++ b/drivers/net/wireless/ath/ath11k/htc.c
@@ -91,7 +91,7 @@ int ath11k_htc_send(struct ath11k_htc *htc,
 
 	if (eid >= ATH11K_HTC_EP_COUNT) {
 		ath11k_warn(ab, "Invalid endpoint id: %d\n", eid);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	skb_push(skb, sizeof(struct ath11k_htc_hdr));
diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index 2836a0f19..4a61354e1 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -318,7 +318,7 @@ static int ath11k_mac_vif_chan(struct ieee80211_vif *vif,
 	conf = rcu_dereference(vif->chanctx_conf);
 	if (!conf) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	*def = conf->def;
@@ -2327,7 +2327,7 @@ static int ath11k_clear_peer_keys(struct ath11k_vif *arvif,
 	spin_unlock_bh(&ab->base_lock);
 
 	if (!peer)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < ARRAY_SIZE(peer->keys); i++) {
 		if (!peer->keys[i])
@@ -5523,7 +5523,7 @@ static int ath11k_mac_op_get_survey(struct ieee80211_hw *hw, int idx,
 	int ret = 0;
 
 	if (idx >= ATH11K_NUM_CHANS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ar_survey = &ar->survey[idx];
 
diff --git a/drivers/net/wireless/ath/ath11k/peer.c b/drivers/net/wireless/ath/ath11k/peer.c
index 297172538..801d100a0 100644
--- a/drivers/net/wireless/ath/ath11k/peer.c
+++ b/drivers/net/wireless/ath/ath11k/peer.c
@@ -252,7 +252,7 @@ int ath11k_peer_create(struct ath11k *ar, struct ath11k_vif *arvif,
 			    param->peer_addr, param->vdev_id);
 		ath11k_wmi_send_peer_delete_cmd(ar, param->peer_addr,
 						param->vdev_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	peer->pdev_idx = ar->pdev_idx;
diff --git a/drivers/net/wireless/ath/ath11k/wmi.c b/drivers/net/wireless/ath/ath11k/wmi.c
index c2a972377..2fcba0a8c 100644
--- a/drivers/net/wireless/ath/ath11k/wmi.c
+++ b/drivers/net/wireless/ath/ath11k/wmi.c
@@ -3865,7 +3865,7 @@ static int wmi_process_mgmt_tx_comp(struct ath11k *ar, u32 desc_id,
 		ath11k_warn(ar->ab, "received mgmt tx compl for invalid msdu_id: %d\n",
 			    desc_id);
 		spin_unlock_bh(&ar->txmgmt_idr_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	idr_remove(&ar->txmgmt_idr, desc_id);
diff --git a/drivers/net/wireless/ath/ath5k/mac80211-ops.c b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
index 5e866a193..9f2176711 100644
--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
@@ -653,7 +653,7 @@ ath5k_get_survey(struct ieee80211_hw *hw, int idx, struct survey_info *survey)
 	unsigned int div = common->clockrate * 1000;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock_bh(&common->cc_lock);
 	ath_hw_cycle_counters_update(common);
diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index 67f8f2aa7..a5b359804 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -570,7 +570,7 @@ static int ath6kl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 			ath6kl_err("key index %d out of bounds\n",
 				   sme->key_idx);
 			up(&ar->sem);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		key = &vif->keys[sme->key_idx];
@@ -656,7 +656,7 @@ static int ath6kl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		memset(vif->ssid, 0, sizeof(vif->ssid));
 		vif->ssid_len = 0;
 		ath6kl_err("invalid request\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (status) {
 		ath6kl_err("ath6kl_wmi_connect_cmd failed\n");
 		return -EIO;
@@ -1149,7 +1149,7 @@ static int ath6kl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,
 		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
 			   "%s: key index %d out of bounds\n", __func__,
 			   key_index);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	key = &vif->keys[key_index];
@@ -1264,7 +1264,7 @@ static int ath6kl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
 		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
 			   "%s: key index %d out of bounds\n", __func__,
 			   key_index);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!vif->keys[key_index].key_len) {
@@ -1297,7 +1297,7 @@ static int ath6kl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev,
 		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
 			   "%s: key index %d out of bounds\n", __func__,
 			   key_index);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	key = &vif->keys[key_index];
@@ -1333,7 +1333,7 @@ static int ath6kl_cfg80211_set_default_key(struct wiphy *wiphy,
 		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
 			   "%s: key index %d out of bounds\n",
 			   __func__, key_index);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!vif->keys[key_index].key_len) {
@@ -1783,7 +1783,7 @@ static int ath6kl_get_station(struct wiphy *wiphy, struct net_device *dev,
 	u8 mcs;
 
 	if (memcmp(mac, vif->bssid, ETH_ALEN) != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (down_interruptible(&ar->sem))
 		return -EBUSY;
@@ -3052,7 +3052,7 @@ static int ath6kl_cancel_remain_on_channel(struct wiphy *wiphy,
 	struct ath6kl *ar = ath6kl_priv(vif->ndev);
 
 	if (cookie != vif->last_roc_id)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	vif->last_cancel_roc_id = cookie;
 
 	return ath6kl_wmi_cancel_remain_on_chnl_cmd(ar->wmi, vif->fw_vif_idx);
diff --git a/drivers/net/wireless/ath/ath6kl/init.c b/drivers/net/wireless/ath/ath6kl/init.c
index aa1c71a76..7914a992d 100644
--- a/drivers/net/wireless/ath/ath6kl/init.c
+++ b/drivers/net/wireless/ath/ath6kl/init.c
@@ -1204,7 +1204,7 @@ static int ath6kl_upload_board_file(struct ath6kl *ar)
 	int ret;
 
 	if (WARN_ON(ar->fw_board == NULL))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Determine where in Target RAM to write Board Data.
diff --git a/drivers/net/wireless/ath/ath9k/hif_usb.c b/drivers/net/wireless/ath/ath9k/hif_usb.c
index 3f563e02d..ca5e9fa02 100644
--- a/drivers/net/wireless/ath/ath9k/hif_usb.c
+++ b/drivers/net/wireless/ath/ath9k/hif_usb.c
@@ -1155,7 +1155,7 @@ static int ath9k_hif_request_firmware(struct hif_device_usb *hif_dev,
 	} else if (hif_dev->fw_minor_index < FIRMWARE_MINOR_IDX_MIN) {
 		dev_err(&hif_dev->udev->dev, "no suitable firmware found!\n");
 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else {
 		if (IS_AR7010_DEVICE(hif_dev->usb_device_id->driver_info))
 			chip = "7010";
diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c
index a47f6e978..9cdf0410c 100644
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -1984,7 +1984,7 @@ static int ath9k_get_survey(struct ieee80211_hw *hw, int idx,
 
 	if (!sband || idx >= sband->n_channels) {
 		spin_unlock_irqrestore(&common->cc_lock, flags);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	chan = &sband->channels[idx];
diff --git a/drivers/net/wireless/ath/ath9k/xmit.c b/drivers/net/wireless/ath/ath9k/xmit.c
index e60d4737f..3aecfd5b3 100644
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -199,7 +199,7 @@ ath_tid_pull(struct ath_atx_tid *tid, struct sk_buff **skbuf)
 
 	skb = ieee80211_tx_dequeue(hw, txq);
 	if (!skb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = ath_tx_prepare(hw, skb, &txctl);
 	if (ret) {
diff --git a/drivers/net/wireless/ath/carl9170/main.c b/drivers/net/wireless/ath/carl9170/main.c
index 816929fb5..8cf6d4a6d 100644
--- a/drivers/net/wireless/ath/carl9170/main.c
+++ b/drivers/net/wireless/ath/carl9170/main.c
@@ -1660,7 +1660,7 @@ static int carl9170_op_get_survey(struct ieee80211_hw *hw, int idx,
 			}
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 
 found:
 	memcpy(survey, &ar->survey[idx], sizeof(*survey));
diff --git a/drivers/net/wireless/ath/wcn36xx/main.c b/drivers/net/wireless/ath/wcn36xx/main.c
index 702b689c0..307c55b57 100644
--- a/drivers/net/wireless/ath/wcn36xx/main.c
+++ b/drivers/net/wireless/ath/wcn36xx/main.c
@@ -1221,7 +1221,7 @@ static int wcn36xx_platform_get_resources(struct wcn36xx *wcn,
 	res = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "tx");
 	if (!res) {
 		wcn36xx_err("failed to get tx_irq\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	wcn->tx_irq = res->start;
 
@@ -1229,7 +1229,7 @@ static int wcn36xx_platform_get_resources(struct wcn36xx *wcn,
 	res = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "rx");
 	if (!res) {
 		wcn36xx_err("failed to get rx_irq\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	wcn->rx_irq = res->start;
 
diff --git a/drivers/net/wireless/ath/wcn36xx/smd.c b/drivers/net/wireless/ath/wcn36xx/smd.c
index 77269ac7f..cb30ea83f 100644
--- a/drivers/net/wireless/ath/wcn36xx/smd.c
+++ b/drivers/net/wireless/ath/wcn36xx/smd.c
@@ -2332,7 +2332,7 @@ static int wcn36xx_smd_missed_beacon_ind(struct wcn36xx *wcn,
 	}
 
 	wcn36xx_warn("BSS index %d not found\n", rsp->bss_index);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int wcn36xx_smd_delete_sta_context_ind(struct wcn36xx *wcn,
@@ -2364,7 +2364,7 @@ static int wcn36xx_smd_delete_sta_context_ind(struct wcn36xx *wcn,
 	wcn36xx_warn("STA with addr %pM and index %d not found\n",
 		     rsp->addr2,
 		     rsp->sta_id);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int wcn36xx_smd_print_reg_info_ind(struct wcn36xx *wcn,
diff --git a/drivers/net/wireless/ath/wil6210/cfg80211.c b/drivers/net/wireless/ath/wil6210/cfg80211.c
index 0851d2bed..1702902c1 100644
--- a/drivers/net/wireless/ath/wil6210/cfg80211.c
+++ b/drivers/net/wireless/ath/wil6210/cfg80211.c
@@ -523,7 +523,7 @@ static int wil_cfg80211_get_station(struct wiphy *wiphy,
 	wil_dbg_misc(wil, "get_station: %pM CID %d MID %d\n", mac, cid,
 		     vif->mid);
 	if (!wil_cid_valid(wil, cid))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = wil_cid_fill_sinfo(vif, cid, sinfo);
 
@@ -547,7 +547,7 @@ int wil_find_cid_by_idx(struct wil6210_priv *wil, u8 mid, int idx)
 		idx--;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int wil_cfg80211_dump_station(struct wiphy *wiphy,
@@ -560,7 +560,7 @@ static int wil_cfg80211_dump_station(struct wiphy *wiphy,
 	int cid = wil_find_cid_by_idx(wil, vif->mid, idx);
 
 	if (!wil_cid_valid(wil, cid))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ether_addr_copy(mac, wil->sta[cid].addr);
 	wil_dbg_misc(wil, "dump_station: %pM CID %d MID %d\n", mac, cid,
@@ -1240,7 +1240,7 @@ static int wil_cfg80211_connect(struct wiphy *wiphy,
 			       bss_type, IEEE80211_PRIVACY_ANY);
 	if (!bss) {
 		wil_err(wil, "Unable to find BSS\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ssid_eid = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
@@ -3118,7 +3118,7 @@ static int wil_rf_sector_get_selected(struct wiphy *wiphy,
 		cid = wil_find_cid(wil, vif->mid, mac_addr);
 		if (cid < 0) {
 			wil_err(wil, "invalid MAC address %pM\n", mac_addr);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} else {
 		if (test_bit(wil_vif_fwconnected, vif->status)) {
@@ -3238,7 +3238,7 @@ static int wil_rf_sector_set_selected(struct wiphy *wiphy,
 			if (cid < 0) {
 				wil_err(wil, "invalid MAC address %pM\n",
 					mac_addr);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		} else {
 			if (sector_index != WMI_INVALID_RF_SECTOR_INDEX) {
diff --git a/drivers/net/wireless/ath/wil6210/p2p.c b/drivers/net/wireless/ath/wil6210/p2p.c
index f26bf046d..04ee7b186 100644
--- a/drivers/net/wireless/ath/wil6210/p2p.c
+++ b/drivers/net/wireless/ath/wil6210/p2p.c
@@ -205,7 +205,7 @@ int wil_p2p_cancel_listen(struct wil6210_vif *vif, u64 cookie)
 		wil_info(wil, "Cookie mismatch: 0x%016llx vs. 0x%016llx\n",
 			 p2p->cookie, cookie);
 		mutex_unlock(&wil->mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	started = wil_p2p_stop_discovery(vif);
@@ -214,7 +214,7 @@ int wil_p2p_cancel_listen(struct wil6210_vif *vif, u64 cookie)
 
 	if (!started) {
 		wil_err(wil, "listen not started\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mutex_lock(&wil->vif_mutex);
diff --git a/drivers/net/wireless/ath/wil6210/txrx.c b/drivers/net/wireless/ath/wil6210/txrx.c
index 080e5aa60..7a6f02e62 100644
--- a/drivers/net/wireless/ath/wil6210/txrx.c
+++ b/drivers/net/wireless/ath/wil6210/txrx.c
@@ -388,14 +388,14 @@ static int wil_rx_get_cid_by_skb(struct wil6210_priv *wil, struct sk_buff *skb)
 			wil_err_ratelimited(wil,
 					    "Short data frame, len = %d\n",
 					    skb->len);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		ta = wil_skb_get_sa(skb);
 	} else {
 		if (unlikely(skb->len < sizeof(struct ieee80211_hdr_3addr))) {
 			wil_err_ratelimited(wil, "Short frame, len = %d\n",
 					    skb->len);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		hdr = (void *)skb->data;
 		ta = hdr->addr2;
diff --git a/drivers/net/wireless/ath/wil6210/wmi.c b/drivers/net/wireless/ath/wil6210/wmi.c
index c7136ce56..4161bd685 100644
--- a/drivers/net/wireless/ath/wil6210/wmi.c
+++ b/drivers/net/wireless/ath/wil6210/wmi.c
@@ -1621,7 +1621,7 @@ static int wil_find_cid_ringid_sta(struct wil6210_priv *wil,
 
 	wil_dbg_wmi(wil, "find sta cid while no rings active?\n");
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void
diff --git a/drivers/net/wireless/atmel/at76c50x-usb.c b/drivers/net/wireless/atmel/at76c50x-usb.c
index 3b2680772..33d2dfd4e 100644
--- a/drivers/net/wireless/atmel/at76c50x-usb.c
+++ b/drivers/net/wireless/atmel/at76c50x-usb.c
@@ -1262,7 +1262,7 @@ static int at76_load_external_fw(struct usb_device *udev, struct fwentry *fwe)
 	int size = fwe->extfw_size;
 
 	if (!buf || !size)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	op_mode = at76_get_op_mode(udev);
 	at76_dbg(DBG_DEVSTART, "opmode %d", op_mode);
diff --git a/drivers/net/wireless/atmel/atmel.c b/drivers/net/wireless/atmel/atmel.c
index d58758360..cbc2ade5c 100644
--- a/drivers/net/wireless/atmel/atmel.c
+++ b/drivers/net/wireless/atmel/atmel.c
@@ -3925,7 +3925,7 @@ static int reset_atmel_card(struct net_device *dev)
 					       "%s: firmware %s is missing, cannot start.\n",
 					       dev->name, priv->firmware_id);
 					priv->firmware_id[0] = '\0';
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 				}
 			}
 
diff --git a/drivers/net/wireless/broadcom/b43/main.c b/drivers/net/wireless/broadcom/b43/main.c
index 3ad94dad2..d8894c034 100644
--- a/drivers/net/wireless/broadcom/b43/main.c
+++ b/drivers/net/wireless/broadcom/b43/main.c
@@ -5158,7 +5158,7 @@ static int b43_op_get_survey(struct ieee80211_hw *hw, int idx,
 	struct ieee80211_conf *conf = &hw->conf;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	survey->channel = conf->chandef.chan;
 	survey->filled = SURVEY_INFO_NOISE_DBM;
diff --git a/drivers/net/wireless/broadcom/b43/phy_common.c b/drivers/net/wireless/broadcom/b43/phy_common.c
index 923d4cb9f..8bf2db0a5 100644
--- a/drivers/net/wireless/broadcom/b43/phy_common.c
+++ b/drivers/net/wireless/broadcom/b43/phy_common.c
@@ -523,7 +523,7 @@ int b43_phy_shm_tssi_read(struct b43_wldev *dev, u16 shm_offset)
 	    b == 0 || b == B43_TSSI_MAX ||
 	    c == 0 || c == B43_TSSI_MAX ||
 	    d == 0 || d == B43_TSSI_MAX)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/* The values are OK. Clear them. */
 	tmp = B43_TSSI_MAX | (B43_TSSI_MAX << 8) |
 	      (B43_TSSI_MAX << 16) | (B43_TSSI_MAX << 24);
diff --git a/drivers/net/wireless/broadcom/b43legacy/main.c b/drivers/net/wireless/broadcom/b43legacy/main.c
index 5208a39fd..07304348c 100644
--- a/drivers/net/wireless/broadcom/b43legacy/main.c
+++ b/drivers/net/wireless/broadcom/b43legacy/main.c
@@ -3520,7 +3520,7 @@ static int b43legacy_op_get_survey(struct ieee80211_hw *hw, int idx,
 	struct ieee80211_conf *conf = &hw->conf;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	survey->channel = conf->chandef.chan;
 	survey->filled = SURVEY_INFO_NOISE_DBM;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index a757abd7a..6741f88de 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -2897,7 +2897,7 @@ brcmf_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *ndev,
 		memcpy(mac, cfg->assoclist.mac[idx], ETH_ALEN);
 		return brcmf_cfg80211_get_station(wiphy, ndev, mac, sinfo);
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static s32
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
index 3aed4c4b8..2fa888555 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
@@ -565,7 +565,7 @@ static int brcmf_fw_request_nvram_done(const struct firmware *fw, void *ctx)
 	return 0;
 
 fail:
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int brcmf_fw_complete_request(const struct firmware *fw,
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
index 097012623..6467c0491 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
@@ -582,7 +582,7 @@ static int brcmf_fws_hanger_pushpkt(struct brcmf_fws_hanger *h,
 				    struct sk_buff *pkt, u32 slot_id)
 {
 	if (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (h->items[slot_id].state != BRCMF_FWS_HANGER_ITEM_STATE_FREE) {
 		brcmf_err("slot is not free\n");
@@ -601,7 +601,7 @@ static inline int brcmf_fws_hanger_poppkt(struct brcmf_fws_hanger *h,
 					  bool remove_item)
 {
 	if (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (h->items[slot_id].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {
 		brcmf_err("entry not in use\n");
@@ -644,7 +644,7 @@ static int brcmf_fws_hanger_mark_suppressed(struct brcmf_fws_hanger *h,
 					    u32 slot_id)
 {
 	if (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (h->items[slot_id].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {
 		brcmf_err("entry not in use\n");
@@ -1240,7 +1240,7 @@ static int brcmf_fws_enq(struct brcmf_fws_info *fws,
 	entry = brcmf_skbcb(p)->mac;
 	if (entry == NULL) {
 		bphy_err(drvr, "no mac descriptor found for skb %p\n", p);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	brcmf_dbg(DATA, "enter: fifo %d skb %p\n", fifo, p);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c
index 648efcbc8..c38f2db1b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c
@@ -428,7 +428,7 @@ static int brcms_ops_start(struct ieee80211_hw *hw)
 	if (!wl->ucode.bcm43xx_bomminor) {
 		err = brcms_request_fw(wl, wl->wlc->hw->d11core);
 		if (err)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ieee80211_wake_queues(hw);
diff --git a/drivers/net/wireless/intel/iwlegacy/4965-mac.c b/drivers/net/wireless/intel/iwlegacy/4965-mac.c
index da6d42026..794858614 100644
--- a/drivers/net/wireless/intel/iwlegacy/4965-mac.c
+++ b/drivers/net/wireless/intel/iwlegacy/4965-mac.c
@@ -4685,7 +4685,7 @@ il4965_request_firmware(struct il_priv *il, bool first)
 
 	if (il->fw_idx < il->cfg->ucode_api_min) {
 		IL_ERR("no suitable firmware found!\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	sprintf(il->firmware_name, "%s%s%s", name_pre, tag, ".ucode");
diff --git a/drivers/net/wireless/intel/iwlwifi/dvm/sta.c b/drivers/net/wireless/intel/iwlwifi/dvm/sta.c
index 51158edce..594e1a4d5 100644
--- a/drivers/net/wireless/intel/iwlwifi/dvm/sta.c
+++ b/drivers/net/wireless/intel/iwlwifi/dvm/sta.c
@@ -1163,7 +1163,7 @@ int iwl_remove_dynamic_key(struct iwl_priv *priv,
 
 	/* if station isn't there, neither is the key */
 	if (sta_id == IWL_INVALID_STATION)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock_bh(&priv->sta_lock);
 	memcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(sta_cmd));
diff --git a/drivers/net/wireless/intel/iwlwifi/fw/acpi.c b/drivers/net/wireless/intel/iwlwifi/fw/acpi.c
index dc769b580..4a9de1a2f 100644
--- a/drivers/net/wireless/intel/iwlwifi/fw/acpi.c
+++ b/drivers/net/wireless/intel/iwlwifi/fw/acpi.c
@@ -78,14 +78,14 @@ static int iwl_acpi_get_handle(struct device *dev, acpi_string method,
 	if (!root_handle) {
 		IWL_DEBUG_DEV_RADIO(dev,
 				    "ACPI: Could not retrieve root port handle\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	status = acpi_get_handle(root_handle, method, ret_handle);
 	if (ACPI_FAILURE(status)) {
 		IWL_DEBUG_DEV_RADIO(dev,
 				    "ACPI: %s method not found\n", method);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return 0;
 }
@@ -145,7 +145,7 @@ int iwl_acpi_get_dsm_u8(struct device *dev, int rev, int func)
 
 	obj = iwl_acpi_get_dsm_object(dev, rev, func, NULL);
 	if (IS_ERR(obj))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (obj->type != ACPI_TYPE_BUFFER) {
 		IWL_DEBUG_DEV_RADIO(dev,
@@ -663,7 +663,7 @@ int iwl_sar_geo_init(struct iwl_fw_runtime *fwrt,
 				"Geo SAR BIOS table invalid or unavailable. (%d)\n",
 				ret);
 		/* we don't fail if the table is not available */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	BUILD_BUG_ON(ACPI_NUM_GEO_PROFILES * ACPI_WGDS_NUM_BANDS *
diff --git a/drivers/net/wireless/intel/iwlwifi/fw/acpi.h b/drivers/net/wireless/intel/iwlwifi/fw/acpi.h
index 0ada9eddb..1b2f76c83 100644
--- a/drivers/net/wireless/intel/iwlwifi/fw/acpi.h
+++ b/drivers/net/wireless/intel/iwlwifi/fw/acpi.h
@@ -211,7 +211,7 @@ static inline void *iwl_acpi_get_dsm_object(struct device *dev, int rev,
 
 static inline int iwl_acpi_get_dsm_u8(struct device *dev, int rev, int func)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline union acpi_object *iwl_acpi_get_wifi_pkg(struct device *dev,
@@ -224,7 +224,7 @@ static inline union acpi_object *iwl_acpi_get_wifi_pkg(struct device *dev,
 
 static inline int iwl_acpi_get_mcc(struct device *dev, char *mcc)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline u64 iwl_acpi_get_pwr_limit(struct device *dev)
@@ -234,36 +234,36 @@ static inline u64 iwl_acpi_get_pwr_limit(struct device *dev)
 
 static inline int iwl_acpi_get_eckv(struct device *dev, u32 *extl_clk)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int iwl_sar_set_profile(union acpi_object *table,
 				      struct iwl_sar_profile *profile,
 				      bool enabled)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int iwl_sar_select_profile(struct iwl_fw_runtime *fwrt,
 			   __le16 per_chain_restriction[][IWL_NUM_SUB_BANDS],
 			   int prof_a, int prof_b)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int iwl_sar_get_wrds_table(struct iwl_fw_runtime *fwrt)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int iwl_sar_get_ewrd_table(struct iwl_fw_runtime *fwrt)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int iwl_sar_get_wgds_table(struct iwl_fw_runtime *fwrt)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline bool iwl_sar_geo_support(struct iwl_fw_runtime *fwrt)
@@ -274,20 +274,20 @@ static inline bool iwl_sar_geo_support(struct iwl_fw_runtime *fwrt)
 static inline int iwl_validate_sar_geo_profile(struct iwl_fw_runtime *fwrt,
 					       struct iwl_host_cmd *cmd)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int iwl_sar_geo_init(struct iwl_fw_runtime *fwrt,
 				   struct iwl_per_chain_offset_group *table)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int iwl_acpi_get_tas(struct iwl_fw_runtime *fwrt,
 				   __le32 *black_list_array,
 				   int *black_list_size)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif /* CONFIG_ACPI */
 #endif /* __iwl_fw_acpi__ */
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-drv.c b/drivers/net/wireless/intel/iwlwifi/iwl-drv.c
index 04f14bfdd..feb1b091f 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-drv.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-drv.c
@@ -245,7 +245,7 @@ static int iwl_request_firmware(struct iwl_drv *drv, bool first)
 
 		IWL_ERR(drv,
 			"check git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	snprintf(drv->firmware_name, sizeof(drv->firmware_name), "%s%s.ucode",
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c b/drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c
index ad6dc4497..57e661011 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c
@@ -134,14 +134,14 @@ static int iwl_eeprom_verify_signature(struct iwl_trans *trans, bool nvm_is_otp)
 		if (!nvm_is_otp) {
 			IWL_ERR(trans, "EEPROM with bad signature: 0x%08x\n",
 				gp);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		return 0;
 	case CSR_EEPROM_GP_GOOD_SIG_EEP_LESS_THAN_4K:
 	case CSR_EEPROM_GP_GOOD_SIG_EEP_MORE_THAN_4K:
 		if (nvm_is_otp) {
 			IWL_ERR(trans, "OTP with bad signature: 0x%08x\n", gp);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		return 0;
 	case CSR_EEPROM_GP_BAD_SIGNATURE_BOTH_EEP_AND_OTP:
@@ -149,7 +149,7 @@ static int iwl_eeprom_verify_signature(struct iwl_trans *trans, bool nvm_is_otp)
 		IWL_ERR(trans,
 			"bad EEPROM/OTP signature, type=%s, EEPROM_GP=0x%08x\n",
 			nvm_is_otp ? "OTP" : "EEPROM", gp);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c b/drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c
index 8fae7e707..86c7d3867 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c
@@ -1546,7 +1546,7 @@ static ssize_t iwl_dbgfs_bcast_filters_macs_write(struct iwl_mvm *mvm,
 	int err = 0;
 
 	if (!mvm->bcast_filters)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (sscanf(buf, "%d %hhi %i", &mac_id, &mac.default_discard,
 		   &attached_filters) != 3)
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c b/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
index 5ca45915c..85eb7d707 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
@@ -634,7 +634,7 @@ static int iwl_mvm_ftm_find_peer(struct cfg80211_pmsr_request *req,
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static u64 iwl_mvm_ftm_get_host_time(struct iwl_mvm *mvm, __le32 fw_gp2_ts)
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
index 95a613537..a28729321 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
@@ -1031,12 +1031,12 @@ static void iwl_mvm_lari_cfg(struct iwl_mvm *mvm)
 inline int iwl_mvm_sar_select_profile(struct iwl_mvm *mvm,
 				      int prof_a, int prof_b)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 inline int iwl_mvm_get_sar_geo_profile(struct iwl_mvm *mvm)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int iwl_mvm_sar_geo_init(struct iwl_mvm *mvm)
@@ -1046,7 +1046,7 @@ static int iwl_mvm_sar_geo_init(struct iwl_mvm *mvm)
 
 int iwl_mvm_ppag_send_cmd(struct iwl_mvm *mvm)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int iwl_mvm_ppag_init(struct iwl_mvm *mvm)
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
index 77916231f..1d24fbcdc 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
@@ -314,7 +314,7 @@ int iwl_mvm_init_fw_regd(struct iwl_mvm *mvm)
 			rtnl_dereference(mvm->hw->wiphy->regd);
 
 	if (!r)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* save the last source in case we overwrite it below */
 	used_src = mvm->mcc_src;
@@ -4734,11 +4734,11 @@ static int iwl_mvm_mac_get_survey(struct ieee80211_hw *hw, int idx,
 
 	/* only support global statistics right now */
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!fw_has_capa(&mvm->fw->ucode_capa,
 			 IWL_UCODE_TLV_CAPA_RADIO_BEACON_STATS))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&mvm->mutex);
 
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
index 51a061b13..a225a6e49 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
@@ -1322,7 +1322,7 @@ static int iwl_mvm_scan_uid_by_status(struct iwl_mvm *mvm, int status)
 		if (mvm->scan_uid_status[i] == status)
 			return i;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void iwl_mvm_scan_umac_dwell(struct iwl_mvm *mvm,
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
index 27977992f..e15fe5e82 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
@@ -3610,7 +3610,7 @@ int iwl_mvm_remove_sta_key(struct iwl_mvm *mvm,
 	if (!__test_and_clear_bit(keyconf->hw_key_idx, mvm->fw_key_table)) {
 		IWL_ERR(mvm, "offset %d not used in fw key table.\n",
 			keyconf->hw_key_idx);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* track which key was deleted last */
diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index e5160d620..657e5697b 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@ -2817,7 +2817,7 @@ static int iwl_dbgfs_monitor_data_open(struct inode *inode,
 	if (!trans->dbg.dest_tlv ||
 	    trans->dbg.dest_tlv->monitor_mode != EXTERNAL_MODE) {
 		IWL_ERR(trans, "Debug destination is not set to DRAM\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (trans_pcie->fw_mon_data.state != IWL_FW_MON_DBGFS_STATE_CLOSED)
diff --git a/drivers/net/wireless/intersil/hostap/hostap_ap.c b/drivers/net/wireless/intersil/hostap/hostap_ap.c
index 3ec46f48c..705bd04d9 100644
--- a/drivers/net/wireless/intersil/hostap/hostap_ap.c
+++ b/drivers/net/wireless/intersil/hostap/hostap_ap.c
@@ -2532,7 +2532,7 @@ static int prism2_hostapd_remove_sta(struct ap_data *ap,
 	spin_unlock_bh(&ap->sta_table_lock);
 
 	if (!sta)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)
 		hostap_event_expired_sta(sta->local->dev, sta);
@@ -2554,7 +2554,7 @@ static int prism2_hostapd_get_info_sta(struct ap_data *ap,
 	spin_unlock_bh(&ap->sta_table_lock);
 
 	if (!sta)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	param->u.get_info_sta.inactive_sec = (jiffies - sta->last_rx) / HZ;
 
@@ -2578,7 +2578,7 @@ static int prism2_hostapd_set_flags_sta(struct ap_data *ap,
 	spin_unlock_bh(&ap->sta_table_lock);
 
 	if (!sta)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -2603,7 +2603,7 @@ static int prism2_hostapd_sta_clear_stats(struct ap_data *ap,
 	spin_unlock_bh(&ap->sta_table_lock);
 
 	if (!sta)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/intersil/orinoco/fw.c b/drivers/net/wireless/intersil/orinoco/fw.c
index 015af7828..30b0a745d 100644
--- a/drivers/net/wireless/intersil/orinoco/fw.c
+++ b/drivers/net/wireless/intersil/orinoco/fw.c
@@ -294,7 +294,7 @@ symbol_dl_firmware(struct orinoco_private *priv,
 	if (!orinoco_cached_fw_get(priv, true)) {
 		if (request_firmware(&fw_entry, fw->pri_fw, priv->dev) != 0) {
 			dev_err(dev, "Cannot find firmware: %s\n", fw->pri_fw);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} else
 		fw_entry = orinoco_cached_fw_get(priv, true);
@@ -313,7 +313,7 @@ symbol_dl_firmware(struct orinoco_private *priv,
 	if (!orinoco_cached_fw_get(priv, false)) {
 		if (request_firmware(&fw_entry, fw->sta_fw, priv->dev) != 0) {
 			dev_err(dev, "Cannot find firmware: %s\n", fw->sta_fw);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} else
 		fw_entry = orinoco_cached_fw_get(priv, false);
diff --git a/drivers/net/wireless/intersil/p54/main.c b/drivers/net/wireless/intersil/p54/main.c
index a3ca6620d..5bc46e885 100644
--- a/drivers/net/wireless/intersil/p54/main.c
+++ b/drivers/net/wireless/intersil/p54/main.c
@@ -609,7 +609,7 @@ static int p54_get_survey(struct ieee80211_hw *dev, int idx,
 	bool in_use = false;
 
 	if (idx >= priv->chan_num)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 #define MAX_TRIES 1
 	for (tries = 0; tries < MAX_TRIES; tries++) {
diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index 1356e8cbe..5a09f4d56 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -1993,13 +1993,13 @@ static int mac80211_hwsim_get_survey(struct ieee80211_hw *hw, int idx,
 	struct mac80211_hwsim_data *hwsim = hw->priv;
 
 	if (idx < 0 || idx >= ARRAY_SIZE(hwsim->survey_data))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&hwsim->mutex);
 	survey->channel = hwsim->survey_data[idx].channel;
 	if (!survey->channel) {
 		mutex_unlock(&hwsim->mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/drivers/net/wireless/marvell/libertas/firmware.c b/drivers/net/wireless/marvell/libertas/firmware.c
index 69029c59a..d8aa15565 100644
--- a/drivers/net/wireless/marvell/libertas/firmware.c
+++ b/drivers/net/wireless/marvell/libertas/firmware.c
@@ -223,6 +223,6 @@ int lbs_get_firmware(struct device *dev, u32 card_model,
 	release_firmware(*mainfw);
 	*mainfw = NULL;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(lbs_get_firmware);
diff --git a/drivers/net/wireless/marvell/libertas_tf/main.c b/drivers/net/wireless/marvell/libertas_tf/main.c
index 02bd7c99b..710538808 100644
--- a/drivers/net/wireless/marvell/libertas_tf/main.c
+++ b/drivers/net/wireless/marvell/libertas_tf/main.c
@@ -463,7 +463,7 @@ static int lbtf_op_get_survey(struct ieee80211_hw *hw, int idx,
 	struct ieee80211_conf *conf = &hw->conf;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	survey->channel = conf->chandef.chan;
 	survey->filled = SURVEY_INFO_NOISE_DBM;
diff --git a/drivers/net/wireless/marvell/mwifiex/cfg80211.c b/drivers/net/wireless/marvell/mwifiex/cfg80211.c
index 4e4f59c17..697e9b6f0 100644
--- a/drivers/net/wireless/marvell/mwifiex/cfg80211.c
+++ b/drivers/net/wireless/marvell/mwifiex/cfg80211.c
@@ -338,7 +338,7 @@ mwifiex_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
 	int ret;
 
 	if (cookie != priv->roc_cfg.cookie)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = mwifiex_remain_on_chan_cfg(priv, HostCmd_ACT_GEN_REMOVE,
 					 &priv->roc_cfg.chan, 0);
@@ -1386,7 +1386,7 @@ mwifiex_dump_station_info(struct mwifiex_private *priv,
 
 	if (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {
 		if (!node)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME) |
 				BIT_ULL(NL80211_STA_INFO_TX_FAILED);
@@ -1476,9 +1476,9 @@ mwifiex_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 	struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
 
 	if (!priv->media_connected)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (memcmp(mac, priv->cfg_bssid, ETH_ALEN))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return mwifiex_dump_station_info(priv, NULL, sinfo);
 }
@@ -1511,7 +1511,7 @@ mwifiex_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *dev,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int
@@ -1543,7 +1543,7 @@ mwifiex_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *dev,
 	}
 
 	if (idx >= priv->adapter->num_in_chan_stats)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!pchan_stats[idx].cca_scan_dur)
 		return 0;
@@ -3854,14 +3854,14 @@ mwifiex_cfg80211_tdls_chan_switch(struct wiphy *wiphy, struct net_device *dev,
 		spin_unlock_bh(&priv->sta_list_spinlock);
 		wiphy_err(wiphy, "%s: Invalid TDLS peer %pM\n",
 			  __func__, addr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!(sta_ptr->tdls_cap.extcap.ext_capab[3] &
 	      WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH)) {
 		spin_unlock_bh(&priv->sta_list_spinlock);
 		wiphy_err(wiphy, "%pM do not support tdls cs\n", addr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (sta_ptr->tdls_status == TDLS_CHAN_SWITCHING ||
diff --git a/drivers/net/wireless/marvell/mwl8k.c b/drivers/net/wireless/marvell/mwl8k.c
index 97f23f93f..7deae2417 100644
--- a/drivers/net/wireless/marvell/mwl8k.c
+++ b/drivers/net/wireless/marvell/mwl8k.c
@@ -5412,7 +5412,7 @@ static int mwl8k_get_survey(struct ieee80211_hw *hw, int idx,
 			sband = hw->wiphy->bands[NL80211_BAND_5GHZ];
 
 		if (!sband || idx >= sband->n_channels)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		memcpy(survey, &priv->survey[idx], sizeof(*survey));
 		survey->channel = &sband->channels[idx];
@@ -5421,7 +5421,7 @@ static int mwl8k_get_survey(struct ieee80211_hw *hw, int idx,
 	}
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	survey->channel = conf->chandef.chan;
 	survey->filled = SURVEY_INFO_NOISE_DBM;
diff --git a/drivers/net/wireless/mediatek/mt76/eeprom.c b/drivers/net/wireless/mediatek/mt76/eeprom.c
index c236e303c..001b6b929 100644
--- a/drivers/net/wireless/mediatek/mt76/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/eeprom.c
@@ -24,15 +24,15 @@ mt76_get_of_eeprom(struct mt76_dev *dev, int len)
 	int ret;
 
 	if (!np)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list = of_get_property(np, "mediatek,mtd-eeprom", &size);
 	if (!list)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	phandle = be32_to_cpup(list++);
 	if (!phandle)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	np = of_find_node_by_phandle(phandle);
 	if (!np)
@@ -78,7 +78,7 @@ mt76_get_of_eeprom(struct mt76_dev *dev, int len)
 	of_node_put(np);
 	return ret;
 #else
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 #endif
 }
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x0/usb_mcu.c b/drivers/net/wireless/mediatek/mt76/mt76x0/usb_mcu.c
index 45502fd46..e0371f4ab 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x0/usb_mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x0/usb_mcu.c
@@ -157,7 +157,7 @@ static int mt76x0u_load_firmware(struct mt76x02_dev *dev)
 err_inv_fw:
 	dev_err(dev->mt76.dev, "Invalid firmware image\n");
 	release_firmware(fw);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int mt76x0u_mcu_init(struct mt76x02_dev *dev)
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x2/eeprom.c b/drivers/net/wireless/mediatek/mt76/mt76x2/eeprom.c
index 410ffce3b..b0d04ac57 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x2/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x2/eeprom.c
@@ -174,7 +174,7 @@ mt76x2_eeprom_load(struct mt76x02_dev *dev)
 
 out:
 	if (!found)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/mediatek/mt76/mt76x2/pci_mcu.c b/drivers/net/wireless/mediatek/mt76/mt76x2/pci_mcu.c
index ca6f96841..aa017af61 100644
--- a/drivers/net/wireless/mediatek/mt76/mt76x2/pci_mcu.c
+++ b/drivers/net/wireless/mediatek/mt76/mt76x2/pci_mcu.c
@@ -151,7 +151,7 @@ mt76pci_load_firmware(struct mt76x02_dev *dev)
 error:
 	dev_err(dev->mt76.dev, "Invalid firmware\n");
 	release_firmware(fw);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int
diff --git a/drivers/net/wireless/mediatek/mt7601u/mcu.c b/drivers/net/wireless/mediatek/mt7601u/mcu.c
index af55ed82b..9f8688289 100644
--- a/drivers/net/wireless/mediatek/mt7601u/mcu.c
+++ b/drivers/net/wireless/mediatek/mt7601u/mcu.c
@@ -483,7 +483,7 @@ static int mt7601u_load_firmware(struct mt7601u_dev *dev)
 err_inv_fw:
 	dev_err(dev->dev, "Invalid firmware image\n");
 	release_firmware(fw);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int mt7601u_mcu_init(struct mt7601u_dev *dev)
diff --git a/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c b/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c
index 54cdf3ad0..157fe54ca 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c
+++ b/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c
@@ -501,14 +501,14 @@ qtnf_dump_station(struct wiphy *wiphy, struct net_device *dev,
 	switch (vif->wdev.iftype) {
 	case NL80211_IFTYPE_STATION:
 		if (idx != 0 || !vif->wdev.current_bss)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		ether_addr_copy(mac, vif->bssid);
 		break;
 	case NL80211_IFTYPE_AP:
 		sta_node = qtnf_sta_list_lookup_index(&vif->sta_list, idx);
 		if (unlikely(!sta_node))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		ether_addr_copy(mac, sta_node->mac_addr);
 		break;
@@ -767,7 +767,7 @@ qtnf_dump_survey(struct wiphy *wiphy, struct net_device *dev,
 		sband = wiphy->bands[NL80211_BAND_5GHZ];
 
 	if (!sband || idx >= sband->n_channels)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	chan = &sband->channels[idx];
 	survey->channel = chan;
@@ -1115,7 +1115,7 @@ qtnf_wiphy_setup_if_comb(struct wiphy *wiphy, struct qtnf_mac_info *mac_info)
 	n_if_comb = mac_info->n_if_comb;
 
 	if (!if_comb || !n_if_comb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < n_if_comb; i++) {
 		if_comb[i].radar_detect_widths = mac_info->radar_detect_widths;
diff --git a/drivers/net/wireless/quantenna/qtnfmac/commands.c b/drivers/net/wireless/quantenna/qtnfmac/commands.c
index f40d8c3c3..0e3103a68 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/commands.c
+++ b/drivers/net/wireless/quantenna/qtnfmac/commands.c
@@ -60,7 +60,7 @@ static int qtnf_cmd_resp_result_decode(enum qlink_cmd_result qcode)
 	case QLINK_CMD_RESULT_ENOTSUPP:
 		return -ENOTSUPP;
 	case QLINK_CMD_RESULT_ENOTFOUND:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case QLINK_CMD_RESULT_EALREADY:
 		return -EALREADY;
 	case QLINK_CMD_RESULT_EADDRINUSE:
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
index a779fe771..4130d1a7a 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
@@ -10507,7 +10507,7 @@ int rt2800_get_survey(struct ieee80211_hw *hw, int idx,
 	u32 idle, busy, busy_ext;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	survey->channel = conf->chandef.chan;
 
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00firmware.c b/drivers/net/wireless/ralink/rt2x00/rt2x00firmware.c
index c20886b02..e54524eb9 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00firmware.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00firmware.c
@@ -46,7 +46,7 @@ static int rt2x00lib_request_firmware(struct rt2x00_dev *rt2x00dev)
 	if (!fw || !fw->size || !fw->data) {
 		rt2x00_err(rt2x00dev, "Failed to read Firmware\n");
 		release_firmware(fw);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rt2x00_info(rt2x00dev, "Firmware detected - version: %d.%d\n",
@@ -78,7 +78,7 @@ static int rt2x00lib_request_firmware(struct rt2x00_dev *rt2x00dev)
 exit:
 	release_firmware(fw);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int rt2x00lib_load_firmware(struct rt2x00_dev *rt2x00dev)
diff --git a/drivers/net/wireless/realtek/rtw88/fw.c b/drivers/net/wireless/realtek/rtw88/fw.c
index 6478fd7a7..a8ec04408 100644
--- a/drivers/net/wireless/realtek/rtw88/fw.c
+++ b/drivers/net/wireless/realtek/rtw88/fw.c
@@ -1339,7 +1339,7 @@ static int rtw_download_beacon(struct rtw_dev *rtwdev)
 					    struct rtw_rsvd_page, build_list);
 	if (!rsvd_pkt) {
 		rtw_err(rtwdev, "failed to get rsvd page from build list\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (rsvd_pkt->type != RSVD_BEACON &&
diff --git a/drivers/net/wireless/realtek/rtw88/main.c b/drivers/net/wireless/realtek/rtw88/main.c
index 0eefafc51..54706625b 100644
--- a/drivers/net/wireless/realtek/rtw88/main.c
+++ b/drivers/net/wireless/realtek/rtw88/main.c
@@ -1135,7 +1135,7 @@ static int rtw_load_firmware(struct rtw_dev *rtwdev, enum rtw_fw_type type)
 
 	default:
 		rtw_warn(rtwdev, "unsupported firmware type\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fw->rtwdev = rtwdev;
diff --git a/drivers/net/wireless/realtek/rtw88/wow.c b/drivers/net/wireless/realtek/rtw88/wow.c
index 2fcdf70a3..a9435c377 100644
--- a/drivers/net/wireless/realtek/rtw88/wow.c
+++ b/drivers/net/wireless/realtek/rtw88/wow.c
@@ -482,7 +482,7 @@ static int rtw_wow_swap_fw(struct rtw_dev *rtwdev, enum rtw_fw_type type)
 
 	default:
 		rtw_warn(rtwdev, "unsupported firmware type to swap\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = rtw_download_firmware(rtwdev, fw);
diff --git a/drivers/net/wireless/rndis_wlan.c b/drivers/net/wireless/rndis_wlan.c
index 8852a1832..99981e5fb 100644
--- a/drivers/net/wireless/rndis_wlan.c
+++ b/drivers/net/wireless/rndis_wlan.c
@@ -1517,7 +1517,7 @@ static int remove_key(struct usbnet *usbdev, u8 index, const u8 *bssid)
 	int ret;
 
 	if (index >= RNDIS_WLAN_NUM_KEYS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (priv->encr_keys[index].len == 0)
 		return 0;
@@ -2436,7 +2436,7 @@ static int rndis_set_default_key(struct wiphy *wiphy, struct net_device *netdev,
 	netdev_dbg(usbdev->net, "%s(%i)\n", __func__, key_index);
 
 	if (key_index >= RNDIS_WLAN_NUM_KEYS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	priv->encr_tx_key_index = key_index;
 
@@ -2479,7 +2479,7 @@ static int rndis_get_station(struct wiphy *wiphy, struct net_device *dev,
 	struct usbnet *usbdev = priv->usbdev;
 
 	if (!ether_addr_equal(priv->bssid, mac))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rndis_fill_station_info(usbdev, sinfo);
 
@@ -2493,7 +2493,7 @@ static int rndis_dump_station(struct wiphy *wiphy, struct net_device *dev,
 	struct usbnet *usbdev = priv->usbdev;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memcpy(mac, priv->bssid, ETH_ALEN);
 
diff --git a/drivers/net/wireless/st/cw1200/sta.c b/drivers/net/wireless/st/cw1200/sta.c
index 236022d4a..fec587714 100644
--- a/drivers/net/wireless/st/cw1200/sta.c
+++ b/drivers/net/wireless/st/cw1200/sta.c
@@ -1552,7 +1552,7 @@ int cw1200_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	if (WARN_ON(!sta_priv->link_id)) {
 		wiphy_info(priv->hw->wiphy,
 			   "[AP] No more link IDs available.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	entry = &priv->link_id_db[sta_priv->link_id - 1];
@@ -1675,7 +1675,7 @@ static int cw1200_set_tim_impl(struct cw1200_common *priv, bool aid0_bit_set)
 	if (!skb) {
 		if (!__cw1200_flush(priv, true))
 			wsm_unlock_tx(priv);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (tim_offset && tim_length >= 6) {
diff --git a/drivers/net/wireless/st/cw1200/txrx.c b/drivers/net/wireless/st/cw1200/txrx.c
index 400dd5859..2b1b8bbb0 100644
--- a/drivers/net/wireless/st/cw1200/txrx.c
+++ b/drivers/net/wireless/st/cw1200/txrx.c
@@ -459,7 +459,7 @@ cw1200_tx_h_calc_link_ids(struct cw1200_common *priv,
 		if (!t->txpriv.link_id) {
 			wiphy_err(priv->hw->wiphy,
 				  "No more link IDs available.\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		t->txpriv.raw_link_id = t->txpriv.link_id;
 	}
diff --git a/drivers/net/wireless/st/cw1200/wsm.c b/drivers/net/wireless/st/cw1200/wsm.c
index c86f31dcc..5661dca43 100644
--- a/drivers/net/wireless/st/cw1200/wsm.c
+++ b/drivers/net/wireless/st/cw1200/wsm.c
@@ -1649,7 +1649,7 @@ static int wsm_get_tx_queue_and_mask(struct cw1200_common *priv,
 	idx = cw1200_get_prio_queue(priv,
 			tx_allowed_mask, &total);
 	if (idx < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 found:
 	*queue_p = &priv->tx_queue[idx];
diff --git a/drivers/net/wireless/ti/wl1251/main.c b/drivers/net/wireless/ti/wl1251/main.c
index 480a8d084..56eab9cd9 100644
--- a/drivers/net/wireless/ti/wl1251/main.c
+++ b/drivers/net/wireless/ti/wl1251/main.c
@@ -1332,7 +1332,7 @@ static int wl1251_op_get_survey(struct ieee80211_hw *hw, int idx,
 	struct ieee80211_conf *conf = &hw->conf;
  
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
  
 	survey->channel = conf->chandef.chan;
 	survey->filled = SURVEY_INFO_NOISE_DBM;
diff --git a/drivers/net/wireless/ti/wlcore/cmd.c b/drivers/net/wireless/ti/wlcore/cmd.c
index 6ef8fc9ae..3750fa8be 100644
--- a/drivers/net/wireless/ti/wlcore/cmd.c
+++ b/drivers/net/wireless/ti/wlcore/cmd.c
@@ -274,7 +274,7 @@ int wl12xx_cmd_role_disable(struct wl1271 *wl, u8 *role_id)
 	wl1271_debug(DEBUG_CMD, "cmd role disable");
 
 	if (WARN_ON(*role_id == WL12XX_INVALID_ROLE_ID))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd) {
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index de6c8a758..b230f9d2c 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -2892,7 +2892,7 @@ static int wl1271_ssid_set(struct wl12xx_vif *wlvif, struct sk_buff *skb,
 
 	if (!ptr) {
 		wl1271_error("No SSID in IEs!");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ssid_len = ptr[1];
@@ -5020,7 +5020,7 @@ static int wl1271_op_get_survey(struct ieee80211_hw *hw, int idx,
 	struct ieee80211_conf *conf = &hw->conf;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	survey->channel = conf->chandef.chan;
 	survey->filled = 0;
diff --git a/drivers/net/wireless/virt_wifi.c b/drivers/net/wireless/virt_wifi.c
index c878097f0..a5b64adab 100644
--- a/drivers/net/wireless/virt_wifi.c
+++ b/drivers/net/wireless/virt_wifi.c
@@ -299,7 +299,7 @@ static int virt_wifi_get_station(struct wiphy *wiphy, struct net_device *dev,
 	wiphy_debug(wiphy, "get_station\n");
 
 	if (!priv->is_connected || !ether_addr_equal(mac, fake_router_bssid))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	sinfo->filled = BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |
 		BIT_ULL(NL80211_STA_INFO_TX_FAILED) |
@@ -324,7 +324,7 @@ static int virt_wifi_dump_station(struct wiphy *wiphy, struct net_device *dev,
 	wiphy_debug(wiphy, "dump_station\n");
 
 	if (idx != 0 || !priv->is_connected)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ether_addr_copy(mac, fake_router_bssid);
 	return virt_wifi_get_station(wiphy, dev, fake_router_bssid, sinfo);
diff --git a/drivers/net/wireless/zydas/zd1211rw/zd_usb.c b/drivers/net/wireless/zydas/zd1211rw/zd_usb.c
index 8ff037412..2b471c05d 100644
--- a/drivers/net/wireless/zydas/zd1211rw/zd_usb.c
+++ b/drivers/net/wireless/zydas/zd1211rw/zd_usb.c
@@ -1894,7 +1894,7 @@ int zd_usb_iowrite16v_async(struct zd_usb *usb, const struct zd_ioreq16 *ioreqs,
 
 	ep = usb_pipe_endpoint(udev, usb_sndintpipe(udev, EP_REGS_OUT));
 	if (!ep)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!urb)
diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c
index 286054b60..bce27b060 100644
--- a/drivers/net/xen-netback/xenbus.c
+++ b/drivers/net/xen-netback/xenbus.c
@@ -488,7 +488,7 @@ static int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])
 		mac[i] = simple_strtoul(s, &e, 16);
 		if ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\0' : ':'))) {
 			kfree(macstr);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		s = e+1;
 	}
diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c
index 88280057e..5b4e45f54 100644
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@ -910,7 +910,7 @@ static int xennet_fill_frags(struct netfront_queue *queue,
 		if (unlikely(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS)) {
 			queue->rx.rsp_cons = ++cons + skb_queue_len(list);
 			kfree_skb(nskb);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,
@@ -1456,7 +1456,7 @@ static int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])
 		mac[i] = simple_strtoul(s, &e, 16);
 		if ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\0' : ':'))) {
 			kfree(macstr);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		s = e+1;
 	}
diff --git a/drivers/nfc/nfcmrvl/fw_dnld.c b/drivers/nfc/nfcmrvl/fw_dnld.c
index 52c8ae504..691e081b8 100644
--- a/drivers/nfc/nfcmrvl/fw_dnld.c
+++ b/drivers/nfc/nfcmrvl/fw_dnld.c
@@ -514,7 +514,7 @@ int nfcmrvl_fw_dnld_start(struct nci_dev *ndev, const char *firmware_name)
 			       &ndev->nfc_dev->dev);
 	if (res < 0) {
 		nfc_err(priv->dev, "failed to retrieve FW %s", firmware_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fw_dnld->header = (const struct nfcmrvl_fw *) priv->fw_dnld.fw->data;
diff --git a/drivers/nvme/host/tcp.c b/drivers/nvme/host/tcp.c
index 79ef2b8e2..e730fc5c1 100644
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@ -480,7 +480,7 @@ static int nvme_tcp_handle_c2h_data(struct nvme_tcp_queue *queue,
 		dev_err(queue->ctrl->ctrl.device,
 			"queue %d tag %#x not found\n",
 			nvme_tcp_queue_id(queue), pdu->command_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!blk_rq_payload_bytes(rq)) {
@@ -584,7 +584,7 @@ static int nvme_tcp_handle_r2t(struct nvme_tcp_queue *queue,
 		dev_err(queue->ctrl->ctrl.device,
 			"queue %d tag %#x not found\n",
 			nvme_tcp_queue_id(queue), pdu->command_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	req = blk_mq_rq_to_pdu(rq);
 
@@ -669,7 +669,7 @@ static int nvme_tcp_recv_data(struct nvme_tcp_queue *queue, struct sk_buff *skb,
 		dev_err(queue->ctrl->ctrl.device,
 			"queue %d tag %#x not found\n",
 			nvme_tcp_queue_id(queue), pdu->command_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	req = blk_mq_rq_to_pdu(rq);
 
diff --git a/drivers/nvme/target/fc.c b/drivers/nvme/target/fc.c
index 27fd3b5aa..140e14c46 100644
--- a/drivers/nvme/target/fc.c
+++ b/drivers/nvme/target/fc.c
@@ -2060,7 +2060,7 @@ nvmet_fc_rcv_ls_req(struct nvmet_fc_target_port *target_port,
 			(w0->ls_cmd <= NVME_FC_LAST_LS_CMD_VALUE) ?
 				nvmefc_ls_names[w0->ls_cmd] : "");
 		nvmet_fc_tgtport_put(tgtport);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	iod->lsrsp = lsrsp;
@@ -2704,7 +2704,7 @@ nvmet_fc_rcv_fcp_req(struct nvmet_fc_target_port *target_port,
 		spin_unlock_irqrestore(&queue->qlock, flags);
 		/* release the queue lookup reference */
 		nvmet_fc_tgt_q_put(queue);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	deferfcp = list_first_entry_or_null(&queue->avail_defer_list,
diff --git a/drivers/nvme/target/fcloop.c b/drivers/nvme/target/fcloop.c
index 2ff1d1334..9bcd5fffa 100644
--- a/drivers/nvme/target/fcloop.c
+++ b/drivers/nvme/target/fcloop.c
@@ -1131,7 +1131,7 @@ fcloop_delete_local_port(struct device *dev, struct device_attribute *attr,
 	spin_unlock_irqrestore(&fcloop_lock, flags);
 
 	if (!lport)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = __wait_localport_unreg(lport);
 
@@ -1327,7 +1327,7 @@ fcloop_delete_remote_port(struct device *dev, struct device_attribute *attr,
 	spin_unlock_irqrestore(&fcloop_lock, flags);
 
 	if (!nport)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = __remoteport_unreg(nport, rport);
 
@@ -1425,7 +1425,7 @@ fcloop_delete_target_port(struct device *dev, struct device_attribute *attr,
 	spin_unlock_irqrestore(&fcloop_lock, flags);
 
 	if (!nport)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = __targetport_unreg(nport, tport);
 
diff --git a/drivers/nvmem/snvs_lpgpr.c b/drivers/nvmem/snvs_lpgpr.c
index c527d26ca..493c3f668 100644
--- a/drivers/nvmem/snvs_lpgpr.c
+++ b/drivers/nvmem/snvs_lpgpr.c
@@ -96,7 +96,7 @@ static int snvs_lpgpr_probe(struct platform_device *pdev)
 	const struct snvs_lpgpr_cfg *dcfg;
 
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
diff --git a/drivers/of/address.c b/drivers/of/address.c
index 8eea3f6e2..da2dff1b6 100644
--- a/drivers/of/address.c
+++ b/drivers/of/address.c
@@ -704,7 +704,7 @@ static int parser_init(struct of_pci_range_parser *parser,
 
 	parser->range = of_get_property(node, name, &rlen);
 	if (parser->range == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	parser->end = parser->range + rlen / sizeof(__be32);
 
diff --git a/drivers/of/base.c b/drivers/of/base.c
index ae03b1218..cbffa894e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1257,7 +1257,7 @@ int of_phandle_iterator_init(struct of_phandle_iterator *it,
 
 	list = of_get_property(np, list_name, &size);
 	if (!list)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	it->cells_name = cells_name;
 	it->cell_count = cell_count;
@@ -1280,7 +1280,7 @@ int of_phandle_iterator_next(struct of_phandle_iterator *it)
 	}
 
 	if (!it->cur || it->phandle_end >= it->list_end)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	it->cur = it->phandle_end;
 
@@ -1753,7 +1753,7 @@ int of_count_phandle_with_args(const struct device_node *np, const char *list_na
 
 		list = of_get_property(np, list_name, &size);
 		if (!list)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		return size / sizeof(*list);
 	}
diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 4602e467c..815596e00 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -485,7 +485,7 @@ static int __init __reserved_mem_reserve_reg(unsigned long node,
 
 	prop = of_get_flat_dt_prop(node, "reg", &len);
 	if (!prop)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (len && len % t_len != 0) {
 		pr_err("Reserved memory: invalid reg property in '%s', skipping node.\n",
@@ -913,13 +913,13 @@ int __init early_init_dt_scan_chosen_stdout(void)
 	if (offset < 0)
 		offset = fdt_path_offset(fdt, "/chosen@0");
 	if (offset < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	p = fdt_getprop(fdt, offset, "stdout-path", &l);
 	if (!p)
 		p = fdt_getprop(fdt, offset, "linux,stdout-path", &l);
 	if (!p || !l)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	q = strchrnul(p, ':');
 	if (*q != '\0')
diff --git a/drivers/opp/of.c b/drivers/opp/of.c
index 314f30614..574e95a4f 100644
--- a/drivers/opp/of.c
+++ b/drivers/opp/of.c
@@ -1101,7 +1101,7 @@ int dev_pm_opp_of_get_sharing_cpus(struct device *cpu_dev,
 	np = dev_pm_opp_of_get_opp_desc_node(cpu_dev);
 	if (!np) {
 		dev_dbg(cpu_dev, "%s: Couldn't find opp node.\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	cpumask_set_cpu(cpu_dev->id, cpumask);
diff --git a/drivers/pci/controller/dwc/pcie-al.c b/drivers/pci/controller/dwc/pcie-al.c
index 270868f38..e67c2d6c7 100644
--- a/drivers/pci/controller/dwc/pcie-al.c
+++ b/drivers/pci/controller/dwc/pcie-al.c
@@ -416,7 +416,7 @@ static int al_pcie_probe(struct platform_device *pdev)
 	ecam_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "config");
 	if (!ecam_res) {
 		dev_err(dev, "couldn't find 'config' reg in DT\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	al_pcie->ecam_size = resource_size(ecam_res);
 
diff --git a/drivers/pci/controller/pci-hyperv.c b/drivers/pci/controller/pci-hyperv.c
index bf40ff09c..3b47f45b0 100644
--- a/drivers/pci/controller/pci-hyperv.c
+++ b/drivers/pci/controller/pci-hyperv.c
@@ -2168,7 +2168,7 @@ static int hv_pci_start_relations_work(struct hv_pcibus_device *hbus,
 	if (hbus->state == hv_pcibus_removing) {
 		dev_info(&hbus->hdev->device,
 			 "PCI VMBus BUS_RELATIONS: ignored\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	dr_wrk = kzalloc(sizeof(*dr_wrk), GFP_NOWAIT);
diff --git a/drivers/pci/controller/pci-mvebu.c b/drivers/pci/controller/pci-mvebu.c
index 153a64676..6d0489262 100644
--- a/drivers/pci/controller/pci-mvebu.c
+++ b/drivers/pci/controller/pci-mvebu.c
@@ -764,7 +764,7 @@ static int mvebu_get_tgt_attr(struct device_node *np, int devfn,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #ifdef CONFIG_PM_SLEEP
diff --git a/drivers/pci/controller/pcie-tango.c b/drivers/pci/controller/pcie-tango.c
index 8f640c70f..5c90bc5f8 100644
--- a/drivers/pci/controller/pcie-tango.c
+++ b/drivers/pci/controller/pcie-tango.c
@@ -261,10 +261,10 @@ static int tango_pcie_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	if (of_pci_dma_range_parser_init(&parser, dev->of_node) < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (of_pci_range_parser_one(&parser, &range) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	range.pci_addr += range.size;
 	pcie->msi_doorbell = range.pci_addr + res->start + SMP8759_DOORBELL;
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9338f914..0ee26dcc1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3518,7 +3518,7 @@ static int pci_rebar_find_pos(struct pci_dev *pdev, int bar)
 			return pos;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/drivers/pci/setup-bus.c b/drivers/pci/setup-bus.c
index 9b94b1f16..c1bec2346 100644
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@ -2168,7 +2168,7 @@ int pci_reassign_bridge_resources(struct pci_dev *bridge, unsigned long type)
 
 	if (list_empty(&saved)) {
 		up_read(&pci_bus_sem);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	__pci_bus_size_bridges(bridge->subordinate, &added);
diff --git a/drivers/pci/vpd.c b/drivers/pci/vpd.c
index 7915d10f9..972e1746a 100644
--- a/drivers/pci/vpd.c
+++ b/drivers/pci/vpd.c
@@ -495,7 +495,7 @@ int pci_vpd_find_tag(const u8 *buf, unsigned int off, unsigned int len, u8 rdt)
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(pci_vpd_find_tag);
 
@@ -513,7 +513,7 @@ int pci_vpd_find_info_keyword(const u8 *buf, unsigned int off,
 		     pci_vpd_info_field_size(&buf[i]);
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(pci_vpd_find_info_keyword);
 
diff --git a/drivers/perf/arm-cci.c b/drivers/perf/arm-cci.c
index 87c4be9dd..66ed360ee 100644
--- a/drivers/perf/arm-cci.c
+++ b/drivers/perf/arm-cci.c
@@ -338,7 +338,7 @@ static int cci400_validate_hw_event(struct cci_pmu *cci_pmu, unsigned long hw_ev
 	int if_type;
 
 	if (hw_event & ~CCI400_PMU_EVENT_MASK)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (hw_event == CCI400_PMU_CYCLES)
 		return hw_event;
@@ -359,14 +359,14 @@ static int cci400_validate_hw_event(struct cci_pmu *cci_pmu, unsigned long hw_ev
 		if_type = CCI_IF_MASTER;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (ev_code >= cci_pmu->model->event_ranges[if_type].min &&
 		ev_code <= cci_pmu->model->event_ranges[if_type].max)
 		return hw_event;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int probe_cci400_revision(struct cci_pmu *cci_pmu)
@@ -546,7 +546,7 @@ static int cci500_validate_hw_event(struct cci_pmu *cci_pmu,
 	int if_type;
 
 	if (hw_event & ~CCI5xx_PMU_EVENT_MASK)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (ev_source) {
 	case CCI5xx_PORT_S0:
@@ -570,14 +570,14 @@ static int cci500_validate_hw_event(struct cci_pmu *cci_pmu,
 		if_type = CCI_IF_GLOBAL;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (ev_code >= cci_pmu->model->event_ranges[if_type].min &&
 		ev_code <= cci_pmu->model->event_ranges[if_type].max)
 		return hw_event;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
@@ -597,7 +597,7 @@ static int cci550_validate_hw_event(struct cci_pmu *cci_pmu,
 	int if_type;
 
 	if (hw_event & ~CCI5xx_PMU_EVENT_MASK)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (ev_source) {
 	case CCI5xx_PORT_S0:
@@ -622,14 +622,14 @@ static int cci550_validate_hw_event(struct cci_pmu *cci_pmu,
 		if_type = CCI_IF_GLOBAL;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (ev_code >= cci_pmu->model->event_ranges[if_type].min &&
 		ev_code <= cci_pmu->model->event_ranges[if_type].max)
 		return hw_event;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #endif	/* CONFIG_ARM_CCI5xx_PMU */
@@ -820,7 +820,7 @@ static int pmu_map_event(struct perf_event *event)
 
 	if (event->attr.type < PERF_TYPE_MAX ||
 			!cci_pmu->model->validate_hw_event)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return	cci_pmu->model->validate_hw_event(cci_pmu, event->attr.config);
 }
@@ -1321,7 +1321,7 @@ static int cci_pmu_event_init(struct perf_event *event)
 	int err = 0;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Shared by all CPUs, no meaningful state to sample */
 	if (is_sampling_event(event) || event->attach_state & PERF_ATTACH_TASK)
diff --git a/drivers/perf/arm-ccn.c b/drivers/perf/arm-ccn.c
index 7b7d23f25..d625e2687 100644
--- a/drivers/perf/arm-ccn.c
+++ b/drivers/perf/arm-ccn.c
@@ -725,7 +725,7 @@ static int arm_ccn_pmu_event_init(struct perf_event *event)
 	struct perf_event *sibling;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ccn = pmu_to_arm_ccn(event->pmu);
 
diff --git a/drivers/perf/arm_dsu_pmu.c b/drivers/perf/arm_dsu_pmu.c
index 96ed93cc7..4c3b42b92 100644
--- a/drivers/perf/arm_dsu_pmu.c
+++ b/drivers/perf/arm_dsu_pmu.c
@@ -446,7 +446,7 @@ static int dsu_pmu_add(struct perf_event *event, int flags)
 
 	if (WARN_ON_ONCE(!cpumask_test_cpu(smp_processor_id(),
 					   &dsu_pmu->associated_cpus)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	idx = dsu_pmu_get_event_idx(hw_events, event);
 	if (idx < 0)
@@ -545,7 +545,7 @@ static int dsu_pmu_event_init(struct perf_event *event)
 	struct dsu_pmu *dsu_pmu = to_dsu_pmu(event->pmu);
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* We don't support sampling */
 	if (is_sampling_event(event)) {
diff --git a/drivers/perf/arm_pmu.c b/drivers/perf/arm_pmu.c
index df352b334..10a4c7eaa 100644
--- a/drivers/perf/arm_pmu.c
+++ b/drivers/perf/arm_pmu.c
@@ -59,12 +59,12 @@ armpmu_map_cache_event(const unsigned (*cache_map)
 		return -EINVAL;
 
 	if (!cache_map)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = (int)(*cache_map)[cache_type][cache_op][cache_result];
 
 	if (ret == CACHE_OP_UNSUPPORTED)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ret;
 }
@@ -78,7 +78,7 @@ armpmu_map_hw_event(const unsigned (*event_map)[PERF_COUNT_HW_MAX], u64 config)
 		return -EINVAL;
 
 	if (!event_map)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mapping = (*event_map)[config];
 	return mapping == HW_OP_UNSUPPORTED ? -ENOENT : mapping;
@@ -114,7 +114,7 @@ armpmu_map_event(struct perf_event *event,
 		return armpmu_map_raw_event(raw_event_mask, config);
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int armpmu_event_set_period(struct perf_event *event)
@@ -255,7 +255,7 @@ armpmu_add(struct perf_event *event, int flags)
 
 	/* An event following a process won't be stopped earlier */
 	if (!cpumask_test_cpu(smp_processor_id(), &armpmu->supported_cpus))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* If we don't have a space for the counter then finish early. */
 	idx = armpmu->get_event_idx(hw_events, event);
@@ -432,14 +432,14 @@ static int armpmu_event_init(struct perf_event *event)
 	 */
 	if (event->cpu != -1 &&
 		!cpumask_test_cpu(event->cpu, &armpmu->supported_cpus))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* does not support taken branch sampling */
 	if (has_branch_stack(event))
 		return -EOPNOTSUPP;
 
 	if (armpmu->map_event(event) == -ENOENT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return __hw_perf_event_init(event);
 }
diff --git a/drivers/perf/arm_smmuv3_pmu.c b/drivers/perf/arm_smmuv3_pmu.c
index 4cdb35d16..130be1632 100644
--- a/drivers/perf/arm_smmuv3_pmu.c
+++ b/drivers/perf/arm_smmuv3_pmu.c
@@ -348,7 +348,7 @@ static int smmu_pmu_event_init(struct perf_event *event)
 	u16 event_id;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (hwc->sample_period) {
 		dev_dbg(dev, "Sampling not supported\n");
diff --git a/drivers/perf/arm_spe_pmu.c b/drivers/perf/arm_spe_pmu.c
index e51ddb6d6..05b47b4b1 100644
--- a/drivers/perf/arm_spe_pmu.c
+++ b/drivers/perf/arm_spe_pmu.c
@@ -664,11 +664,11 @@ static int arm_spe_pmu_event_init(struct perf_event *event)
 
 	/* This is, of course, deeply driver-specific */
 	if (attr->type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (event->cpu >= 0 &&
 	    !cpumask_test_cpu(event->cpu, &spe_pmu->supported_cpus))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (arm_spe_event_to_pmsevfr(event) & SYS_PMSEVFR_EL1_RES0)
 		return -EOPNOTSUPP;
@@ -792,7 +792,7 @@ static int arm_spe_pmu_add(struct perf_event *event, int flags)
 	int cpu = event->cpu == -1 ? smp_processor_id() : event->cpu;
 
 	if (!cpumask_test_cpu(cpu, &spe_pmu->supported_cpus))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;
 
diff --git a/drivers/perf/fsl_imx8_ddr_perf.c b/drivers/perf/fsl_imx8_ddr_perf.c
index 397540a4b..66ea672ad 100644
--- a/drivers/perf/fsl_imx8_ddr_perf.c
+++ b/drivers/perf/fsl_imx8_ddr_perf.c
@@ -283,7 +283,7 @@ static u32 ddr_perf_alloc_counter(struct ddr_pmu *pmu, int event)
 		if (pmu->events[EVENT_CYCLES_COUNTER] == NULL)
 			return EVENT_CYCLES_COUNTER;
 		else
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 1; i < NUM_COUNTERS; i++) {
@@ -291,7 +291,7 @@ static u32 ddr_perf_alloc_counter(struct ddr_pmu *pmu, int event)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void ddr_perf_free_counter(struct ddr_pmu *pmu, int counter)
@@ -321,7 +321,7 @@ static int ddr_perf_event_init(struct perf_event *event)
 	struct perf_event *sibling;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (is_sampling_event(event) || event->attach_state & PERF_ATTACH_TASK)
 		return -EOPNOTSUPP;
diff --git a/drivers/perf/hisilicon/hisi_uncore_pmu.c b/drivers/perf/hisilicon/hisi_uncore_pmu.c
index 97aff877a..723bd836e 100644
--- a/drivers/perf/hisilicon/hisi_uncore_pmu.c
+++ b/drivers/perf/hisilicon/hisi_uncore_pmu.c
@@ -135,7 +135,7 @@ int hisi_uncore_pmu_event_init(struct perf_event *event)
 	struct hisi_pmu *hisi_pmu;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * We do not support sampling as the counters are all
diff --git a/drivers/perf/qcom_l2_pmu.c b/drivers/perf/qcom_l2_pmu.c
index 4da37f650..05d64b7fe 100644
--- a/drivers/perf/qcom_l2_pmu.c
+++ b/drivers/perf/qcom_l2_pmu.c
@@ -485,7 +485,7 @@ static int l2_cache_event_init(struct perf_event *event)
 	struct l2cache_pmu *l2cache_pmu;
 
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	l2cache_pmu = to_l2cache_pmu(event->pmu);
 
diff --git a/drivers/perf/qcom_l3_pmu.c b/drivers/perf/qcom_l3_pmu.c
index 9ddb577c5..27f984d0a 100644
--- a/drivers/perf/qcom_l3_pmu.c
+++ b/drivers/perf/qcom_l3_pmu.c
@@ -484,7 +484,7 @@ static int qcom_l3_cache__event_init(struct perf_event *event)
 	 * Is the event for this PMU?
 	 */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Sampling not supported since these events are not core-attributable.
diff --git a/drivers/perf/thunderx2_pmu.c b/drivers/perf/thunderx2_pmu.c
index aac9823b0..a7b4264d4 100644
--- a/drivers/perf/thunderx2_pmu.c
+++ b/drivers/perf/thunderx2_pmu.c
@@ -576,7 +576,7 @@ static int tx2_uncore_event_init(struct perf_event *event)
 
 	/* Test the event attr type check for PMU enumeration */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * SOC PMU counters are shared across all cores.
diff --git a/drivers/perf/xgene_pmu.c b/drivers/perf/xgene_pmu.c
index edac28cd2..7a14e4d19 100644
--- a/drivers/perf/xgene_pmu.c
+++ b/drivers/perf/xgene_pmu.c
@@ -895,7 +895,7 @@ static int xgene_perf_event_init(struct perf_event *event)
 
 	/* Test the event attr type check for PMU enumeration */
 	if (event->attr.type != event->pmu->type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * SOC PMU counters are shared across all cores.
diff --git a/drivers/phy/lantiq/phy-lantiq-rcu-usb2.c b/drivers/phy/lantiq/phy-lantiq-rcu-usb2.c
index be09b1530..be1cd73f2 100644
--- a/drivers/phy/lantiq/phy-lantiq-rcu-usb2.c
+++ b/drivers/phy/lantiq/phy-lantiq-rcu-usb2.c
@@ -165,7 +165,7 @@ static int ltq_rcu_usb2_of_parse(struct ltq_rcu_usb2_priv *priv,
 	offset = of_get_address(dev->of_node, 0, NULL, NULL);
 	if (!offset) {
 		dev_err(dev, "Failed to get RCU PHY reg offset\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	priv->phy_reg_offset = __be32_to_cpu(*offset);
 
@@ -173,7 +173,7 @@ static int ltq_rcu_usb2_of_parse(struct ltq_rcu_usb2_priv *priv,
 		offset = of_get_address(dev->of_node, 1, NULL, NULL);
 		if (!offset) {
 			dev_err(dev, "Failed to get RCU ANA CFG1 reg offset\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		priv->ana_cfg1_reg_offset = __be32_to_cpu(*offset);
 	}
diff --git a/drivers/phy/rockchip/phy-rockchip-pcie.c b/drivers/phy/rockchip/phy-rockchip-pcie.c
index 75216091d..f0e810a4e 100644
--- a/drivers/phy/rockchip/phy-rockchip-pcie.c
+++ b/drivers/phy/rockchip/phy-rockchip-pcie.c
@@ -404,7 +404,7 @@ static int rockchip_pcie_phy_probe(struct platform_device *pdev)
 
 	/* parse #phy-cells to see if it's legacy PHY model */
 	if (of_property_read_u32(dev->of_node, "#phy-cells", &phy_num))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	phy_num = (phy_num == 0) ? 1 : PHY_MAX_LANE_NUM;
 	dev_dbg(dev, "phy number is %d\n", phy_num);
diff --git a/drivers/phy/st/phy-miphy28lp.c b/drivers/phy/st/phy-miphy28lp.c
index 068160a34..3b667ed4d 100644
--- a/drivers/phy/st/phy-miphy28lp.c
+++ b/drivers/phy/st/phy-miphy28lp.c
@@ -877,7 +877,7 @@ static int miphy28lp_get_one_addr(struct device *dev,
 		if (!*base) {
 			dev_err(dev, "failed to ioremap %s address region\n"
 					, rname);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/drivers/phy/ti/phy-dm816x-usb.c b/drivers/phy/ti/phy-dm816x-usb.c
index 26f194779..0408706cd 100644
--- a/drivers/phy/ti/phy-dm816x-usb.c
+++ b/drivers/phy/ti/phy-dm816x-usb.c
@@ -202,7 +202,7 @@ static int dm816x_usb_phy_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	phy->syscon = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
 						      "syscon");
diff --git a/drivers/pinctrl/bcm/pinctrl-ns.c b/drivers/pinctrl/bcm/pinctrl-ns.c
index e79690bd8..f81fe408b 100644
--- a/drivers/pinctrl/bcm/pinctrl-ns.c
+++ b/drivers/pinctrl/bcm/pinctrl-ns.c
@@ -301,7 +301,7 @@ static int ns_pinctrl_probe(struct platform_device *pdev)
 
 	if (of_property_read_u32(np, "offset", &ns_pinctrl->offset)) {
 		dev_err(dev, "Failed to get register offset\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	memcpy(pctldesc, &ns_pinctrl_desc, sizeof(*pctldesc));
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
index 821242bb4..35a3bf2a2 100644
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -670,7 +670,7 @@ int pinctrl_generic_remove_group(struct pinctrl_dev *pctldev,
 	group = radix_tree_lookup(&pctldev->pin_group_tree,
 				  selector);
 	if (!group)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	radix_tree_delete(&pctldev->pin_group_tree, selector);
 	devm_kfree(pctldev->dev, group);
diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index c6fe7d64c..db55e82c9 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -294,7 +294,7 @@ static int pinctrl_find_cells_size(const struct device_node *np)
 		error = of_property_read_u32(np->parent->parent,
 					     cells_name, &cells_size);
 		if (error)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return cells_size;
@@ -323,11 +323,11 @@ static int pinctrl_get_list_and_count(const struct device_node *np,
 
 	*list = of_get_property(np, list_name, &size);
 	if (!*list)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*cells_size = pinctrl_find_cells_size(np);
 	if (*cells_size < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* First element is always the index within the pinctrl device */
 	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
diff --git a/drivers/pinctrl/freescale/pinctrl-imx1-core.c b/drivers/pinctrl/freescale/pinctrl-imx1-core.c
index 08d110078..590f21c77 100644
--- a/drivers/pinctrl/freescale/pinctrl-imx1-core.c
+++ b/drivers/pinctrl/freescale/pinctrl-imx1-core.c
@@ -609,7 +609,7 @@ int imx1_pinctrl_core_probe(struct platform_device *pdev,
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ipctl->base = devm_ioremap(&pdev->dev, res->start,
 			resource_size(res));
diff --git a/drivers/pinctrl/freescale/pinctrl-mxs.c b/drivers/pinctrl/freescale/pinctrl-mxs.c
index 735cedd09..791d323bb 100644
--- a/drivers/pinctrl/freescale/pinctrl-mxs.c
+++ b/drivers/pinctrl/freescale/pinctrl-mxs.c
@@ -408,7 +408,7 @@ static int mxs_pinctrl_probe_dt(struct platform_device *pdev,
 	child = of_get_next_child(np, NULL);
 	if (!child) {
 		dev_err(&pdev->dev, "no group is defined\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Count total functions and groups */
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
index 5f125bd62..2f618ab52 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
@@ -752,7 +752,7 @@ static int armada_37xx_irqchip_register(struct platform_device *pdev,
 
 	if (of_address_to_resource(info->dev->of_node, 1, &res)) {
 		dev_err(dev, "cannot find IO resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	info->base = devm_ioremap_resource(info->dev, &res);
diff --git a/drivers/pinctrl/pinctrl-rockchip.c b/drivers/pinctrl/pinctrl-rockchip.c
index c07324d1f..7c1cf126d 100644
--- a/drivers/pinctrl/pinctrl-rockchip.c
+++ b/drivers/pinctrl/pinctrl-rockchip.c
@@ -3514,7 +3514,7 @@ static int rockchip_get_bank_data(struct rockchip_pin_bank *bank,
 
 	if (of_address_to_resource(bank->of_node, 0, &res)) {
 		dev_err(info->dev, "cannot find IO resource for bank\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bank->reg_base = devm_ioremap_resource(info->dev, &res);
@@ -3534,7 +3534,7 @@ static int rockchip_get_bank_data(struct rockchip_pin_bank *bank,
 		if (!node) {
 			if (of_address_to_resource(bank->of_node, 1, &res)) {
 				dev_err(info->dev, "cannot find IO resource for bank\n");
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 
 			base = devm_ioremap_resource(info->dev, &res);
diff --git a/drivers/pinctrl/pinctrl-rza1.c b/drivers/pinctrl/pinctrl-rza1.c
index 38a14bbce..2d47afb68 100644
--- a/drivers/pinctrl/pinctrl-rza1.c
+++ b/drivers/pinctrl/pinctrl-rza1.c
@@ -533,7 +533,7 @@ static inline int rza1_pinmux_get_swio(unsigned int port,
 			return swio_pin->input;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
@@ -900,7 +900,7 @@ static int rza1_parse_pinmux_node(struct rza1_pinctrl *rza1_pctl,
 	of_pins = of_find_property(np, prop_name, NULL);
 	if (!of_pins) {
 		dev_dbg(rza1_pctl->dev, "Missing %s property\n", prop_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	npins = of_pins->length / sizeof(u32);
 
diff --git a/drivers/pinctrl/pinctrl-rza2.c b/drivers/pinctrl/pinctrl-rza2.c
index c5bf98c86..c4d84e752 100644
--- a/drivers/pinctrl/pinctrl-rza2.c
+++ b/drivers/pinctrl/pinctrl-rza2.c
@@ -337,7 +337,7 @@ static int rza2_dt_node_to_map(struct pinctrl_dev *pctldev,
 	of_pins = of_find_property(np, "pinmux", NULL);
 	if (!of_pins) {
 		dev_info(priv->dev, "Missing pinmux property\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	npins = of_pins->length / sizeof(u32);
 
diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 9503ddf2e..f90be54be 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -818,7 +818,7 @@ int pinmux_generic_remove_function(struct pinctrl_dev *pctldev,
 	function = radix_tree_lookup(&pctldev->pin_function_tree,
 				     selector);
 	if (!function)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	radix_tree_delete(&pctldev->pin_function_tree, selector);
 	devm_kfree(pctldev->dev, function);
diff --git a/drivers/platform/chrome/chromeos_laptop.c b/drivers/platform/chrome/chromeos_laptop.c
index 472a03daa..d3f896099 100644
--- a/drivers/platform/chrome/chromeos_laptop.c
+++ b/drivers/platform/chrome/chromeos_laptop.c
@@ -683,7 +683,7 @@ static int __init chromeos_laptop_get_irq_from_dmi(const char *dmi_name)
 	dmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, dmi_name, NULL);
 	if (!dmi_dev) {
 		pr_err("failed to find DMI device '%s'\n", dmi_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	dev_data = dmi_dev->device_data;
diff --git a/drivers/platform/x86/wmi.c b/drivers/platform/x86/wmi.c
index d88f388a3..b80626ab1 100644
--- a/drivers/platform/x86/wmi.c
+++ b/drivers/platform/x86/wmi.c
@@ -161,7 +161,7 @@ static int get_subobj_info(acpi_handle handle, const char *pathname,
 
 	status = acpi_get_handle(handle, (char *)pathname, &subobj_handle);
 	if (status == AE_NOT_FOUND)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	else if (ACPI_FAILURE(status))
 		return -EIO;
 
diff --git a/drivers/power/supply/gpio-charger.c b/drivers/power/supply/gpio-charger.c
index 1b959c7f8..39b5cad2a 100644
--- a/drivers/power/supply/gpio-charger.c
+++ b/drivers/power/supply/gpio-charger.c
@@ -131,7 +131,7 @@ static int gpio_charger_probe(struct platform_device *pdev)
 
 	if (!pdata && !dev->of_node) {
 		dev_err(dev, "No platform data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	gpio_charger = devm_kzalloc(dev, sizeof(*gpio_charger), GFP_KERNEL);
diff --git a/drivers/ras/debugfs.c b/drivers/ras/debugfs.c
index 0d4f985af..f7a2b88ef 100644
--- a/drivers/ras/debugfs.c
+++ b/drivers/ras/debugfs.c
@@ -42,7 +42,7 @@ int __init ras_add_daemon_trace(void)
 	struct dentry *fentry;
 
 	if (!ras_debugfs_dir)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	fentry = debugfs_create_file("daemon_active", S_IRUSR, ras_debugfs_dir,
 				     NULL, &trace_fops);
diff --git a/drivers/regulator/fixed.c b/drivers/regulator/fixed.c
index bc0bbd99e..9eba2ad0a 100644
--- a/drivers/regulator/fixed.c
+++ b/drivers/regulator/fixed.c
@@ -183,7 +183,7 @@ static int reg_fixed_voltage_probe(struct platform_device *pdev)
 		drvdata->enable_clock = devm_clk_get(dev, NULL);
 		if (IS_ERR(drvdata->enable_clock)) {
 			dev_err(dev, "Cant get enable-clock from devicetree\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} else {
 		drvdata->desc.ops = &fixed_voltage_ops;
diff --git a/drivers/remoteproc/imx_rproc.c b/drivers/remoteproc/imx_rproc.c
index 8957ed271..aca12e117 100644
--- a/drivers/remoteproc/imx_rproc.c
+++ b/drivers/remoteproc/imx_rproc.c
@@ -205,7 +205,7 @@ static int imx_rproc_da_to_sys(struct imx_rproc *priv, u64 da,
 
 	dev_warn(priv->dev, "Translation failed: da = 0x%llx len = 0x%zx\n",
 		 da, len);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void *imx_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len)
diff --git a/drivers/reset/reset-lantiq.c b/drivers/reset/reset-lantiq.c
index ac41d093d..dc7c072d3 100644
--- a/drivers/reset/reset-lantiq.c
+++ b/drivers/reset/reset-lantiq.c
@@ -135,14 +135,14 @@ static int lantiq_rcu_reset_of_parse(struct platform_device *pdev,
 	offset = of_get_address(dev->of_node, 0, NULL, NULL);
 	if (!offset) {
 		dev_err(&pdev->dev, "Failed to get RCU reset offset\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	priv->reset_offset = __be32_to_cpu(*offset);
 
 	offset = of_get_address(dev->of_node, 1, NULL, NULL);
 	if (!offset) {
 		dev_err(&pdev->dev, "Failed to get RCU status offset\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	priv->status_offset = __be32_to_cpu(*offset);
 
diff --git a/drivers/rtc/rtc-bd70528.c b/drivers/rtc/rtc-bd70528.c
index 4492b7704..bc2d6f6e6 100644
--- a/drivers/rtc/rtc-bd70528.c
+++ b/drivers/rtc/rtc-bd70528.c
@@ -537,7 +537,7 @@ static int bd70528_probe(struct platform_device *pdev)
 		break;
 	default:
 		dev_err(&pdev->dev, "Unknown chip\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	irq = platform_get_irq_byname(pdev, irq_name);
diff --git a/drivers/rtc/rtc-omap.c b/drivers/rtc/rtc-omap.c
index c20fc7937..0eac834e5 100644
--- a/drivers/rtc/rtc-omap.c
+++ b/drivers/rtc/rtc-omap.c
@@ -747,11 +747,11 @@ static int omap_rtc_probe(struct platform_device *pdev)
 
 	rtc->irq_timer = platform_get_irq(pdev, 0);
 	if (rtc->irq_timer <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rtc->irq_alarm = platform_get_irq(pdev, 1);
 	if (rtc->irq_alarm <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rtc->clk = devm_clk_get(&pdev->dev, "ext-clk");
 	if (!IS_ERR(rtc->clk))
diff --git a/drivers/rtc/rtc-puv3.c b/drivers/rtc/rtc-puv3.c
index 954b88d24..dcc8eeb6b 100644
--- a/drivers/rtc/rtc-puv3.c
+++ b/drivers/rtc/rtc-puv3.c
@@ -182,11 +182,11 @@ static int puv3_rtc_probe(struct platform_device *pdev)
 	/* find the IRQs */
 	puv3_rtc_tickno = platform_get_irq(pdev, 1);
 	if (puv3_rtc_tickno < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	puv3_rtc_alarmno = platform_get_irq(pdev, 0);
 	if (puv3_rtc_alarmno < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dev_dbg(&pdev->dev, "PKUnity_rtc: tick irq %d, alarm irq %d\n",
 		 puv3_rtc_tickno, puv3_rtc_alarmno);
@@ -213,7 +213,7 @@ static int puv3_rtc_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "failed to get memory region resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	puv3_rtc_mem = request_mem_region(res->start, resource_size(res),
diff --git a/drivers/rtc/rtc-sh.c b/drivers/rtc/rtc-sh.c
index 9167b4801..9f6b9de71 100644
--- a/drivers/rtc/rtc-sh.c
+++ b/drivers/rtc/rtc-sh.c
@@ -482,7 +482,7 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 	ret = platform_get_irq(pdev, 0);
 	if (unlikely(ret <= 0)) {
 		dev_err(&pdev->dev, "No IRQ resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rtc->periodic_irq = ret;
@@ -494,7 +494,7 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (unlikely(res == NULL)) {
 		dev_err(&pdev->dev, "No IO resource\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	rtc->regsize = resource_size(res);
diff --git a/drivers/s390/block/dasd_proc.c b/drivers/s390/block/dasd_proc.c
index 62a859ea6..c8186507a 100644
--- a/drivers/s390/block/dasd_proc.c
+++ b/drivers/s390/block/dasd_proc.c
@@ -356,7 +356,7 @@ dasd_proc_init(void)
  out_nodevices:
 	remove_proc_entry("dasd", NULL);
  out_nodasd:
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void
diff --git a/drivers/s390/cio/blacklist.c b/drivers/s390/cio/blacklist.c
index 4dd2eb634..99800525b 100644
--- a/drivers/s390/cio/blacklist.c
+++ b/drivers/s390/cio/blacklist.c
@@ -415,7 +415,7 @@ cio_ignore_proc_init (void)
 	entry = proc_create("cio_ignore", S_IFREG | S_IRUGO | S_IWUSR, NULL,
 			    &cio_ignore_proc_ops);
 	if (!entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return 0;
 }
 
diff --git a/drivers/s390/crypto/ap_queue.c b/drivers/s390/crypto/ap_queue.c
index 73b077dca..acee8a584 100644
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@ -107,7 +107,7 @@ int ap_recv(ap_qid_t qid, unsigned long long *psmid, void *msg, size_t length)
 		return 0;
 	case AP_RESPONSE_NO_PENDING_REPLY:
 		if (status.queue_empty)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		return -EBUSY;
 	case AP_RESPONSE_RESET_IN_PROGRESS:
 		return -EBUSY;
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index 2d3bca3c0..cc6bc5e38 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -209,7 +209,7 @@ static int qeth_l2_setdelvlan_makerc(struct qeth_card *card, u16 retcode)
 	case IPA_RC_L2_DUP_VLAN_ID:
 		return -EEXIST;
 	case IPA_RC_L2_VLAN_ID_NOT_FOUND:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case IPA_RC_L2_VLAN_ID_NOT_ALLOWED:
 		return -EPERM;
 	default:
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index 1e50aa029..3dc49cda9 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -144,7 +144,7 @@ static int qeth_l3_delete_ip(struct qeth_card *card,
 
 	addr = qeth_l3_find_addr_by_ip(card, tmp_addr);
 	if (!addr || !qeth_l3_addr_match_all(addr, tmp_addr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	addr->ref_counter--;
 	if (addr->type == QETH_IP_TYPE_NORMAL && addr->ref_counter > 0)
@@ -305,7 +305,7 @@ static int qeth_l3_setdelip_cb(struct qeth_card *card, struct qeth_reply *reply,
 	case IPA_RC_DUPLICATE_IP_ADDRESS:
 		return -EADDRINUSE;
 	case IPA_RC_MC_ADDR_NOT_FOUND:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case IPA_RC_LAN_OFFLINE:
 		return -ENETDOWN;
 	default:
@@ -1258,7 +1258,7 @@ static int qeth_l3_arp_makerc(u16 rc)
 	case QETH_IPA_ARP_RC_OUT_OF_RANGE:
 		return -EINVAL;
 	case QETH_IPA_ARP_RC_Q_NO_DATA:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	default:
 		return -EIO;
 	}
diff --git a/drivers/scsi/aic94xx/aic94xx_sds.c b/drivers/scsi/aic94xx/aic94xx_sds.c
index 105adba55..001752daf 100644
--- a/drivers/scsi/aic94xx/aic94xx_sds.c
+++ b/drivers/scsi/aic94xx/aic94xx_sds.c
@@ -138,12 +138,12 @@ static int asd_read_ocm_dir(struct asd_ha_struct *asd_ha,
 	if (dir->sig[0] != 'M' || dir->sig[1] != 'O') {
 		ASD_DPRINTK("no valid dir signature(%c%c) at start of OCM\n",
 			    dir->sig[0], dir->sig[1]);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (dir->major != 0) {
 		asd_printk("unsupported major version of ocm dir:0x%x\n",
 			   dir->major);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	dir->num_de &= 0xf;
 	return 0;
@@ -184,7 +184,7 @@ static int asd_find_dir_entry(struct asd_ocm_dir *dir, u8 type,
 			break;
 	}
 	if (i >= dir->num_de)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ent = &dir->entry[i];
 	*offs = (u32) THREE_TO_NUM(ent->offs);
 	*size = (u32) THREE_TO_NUM(ent->size);
@@ -557,7 +557,7 @@ static int asd_poll_flash(struct asd_ha_struct *asd_ha)
 			return 0;
 		udelay(5);
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int asd_reset_flash(struct asd_ha_struct *asd_ha)
@@ -618,7 +618,7 @@ static int asd_flash_getid(struct asd_ha_struct *asd_ha)
 				  &asd_ha->hw_prof.flash.bar)) {
 		asd_printk("couldn't read PCI_CONF_FLSH_BAR of %s\n",
 			   pci_name(asd_ha->pcidev));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	asd_ha->hw_prof.flash.present = 1;
 	asd_ha->hw_prof.flash.wide = reg & FLASHW ? 1 : 0;
@@ -655,7 +655,7 @@ static int asd_find_flash_de(struct asd_flash_dir *flash_dir, u32 entry_type,
 			break;
 	}
 	if (i >= FLASH_MAX_DIR_ENTRIES)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	de = &flash_dir->dir_entry[i];
 	*offs = le32_to_cpu(de->offs);
 	*size = le32_to_cpu(de->pad_size);
@@ -667,12 +667,12 @@ static int asd_validate_ms(struct asd_manuf_sec *ms)
 	if (ms->sig[0] != 'S' || ms->sig[1] != 'M') {
 		ASD_DPRINTK("manuf sec: no valid sig(%c%c)\n",
 			    ms->sig[0], ms->sig[1]);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (ms->maj != 0) {
 		asd_printk("unsupported manuf. sector. major version:%x\n",
 			   ms->maj);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	ms->offs_next = le16_to_cpu((__force __le16) ms->offs_next);
 	ms->chksum = le16_to_cpu((__force __le16) ms->chksum);
@@ -784,7 +784,7 @@ static int asd_ms_get_phy_params(struct asd_ha_struct *asd_ha,
 	if (phy_param->maj != 0) {
 		asd_printk("unsupported manuf. phy param major version:0x%x\n",
 			   phy_param->maj);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ASD_DPRINTK("ms: num_phy_desc: %d\n", phy_param->num_phy_desc);
@@ -833,7 +833,7 @@ static int asd_ms_get_connector_map(struct asd_ha_struct *asd_ha,
 	if (cm->maj != 0) {
 		ASD_DPRINTK("ms: unsupported: connector map major version 0x%x"
 			    "\n", cm->maj);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* XXX */
diff --git a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index 0e33324e1..ff9a51d1d 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -1208,7 +1208,7 @@ static int bnx2fc_vport_destroy(struct fc_vport *vport)
 
 	if (!found) {
 		mutex_unlock(&n_port->lp_mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	list_del(&vn_port->list);
 	mutex_unlock(&n_port->lp_mutex);
diff --git a/drivers/scsi/csiostor/csio_hw.c b/drivers/scsi/csiostor/csio_hw.c
index 950f9cdf0..4b20151c4 100644
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@ -1984,7 +1984,7 @@ csio_hw_flash_config(struct csio_hw *hw, u32 *fw_cfg_param, char *path)
 	if (request_firmware(&cf, fw_cfg_file, dev) < 0) {
 		csio_err(hw, "could not find config file %s, err: %d\n",
 			 fw_cfg_file, ret);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (cf->size%4 != 0)
diff --git a/drivers/scsi/hisi_sas/hisi_sas_main.c b/drivers/scsi/hisi_sas/hisi_sas_main.c
index 11caa4b0d..90a53b8f6 100644
--- a/drivers/scsi/hisi_sas/hisi_sas_main.c
+++ b/drivers/scsi/hisi_sas/hisi_sas_main.c
@@ -2493,7 +2493,7 @@ int hisi_sas_get_fw_info(struct hisi_hba *hisi_hba)
 	if (device_property_read_u8_array(dev, "sas-addr", hisi_hba->sas_addr,
 					  SAS_ADDR_SIZE)) {
 		dev_err(dev, "could not get property sas-addr\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (np) {
@@ -2505,25 +2505,25 @@ int hisi_sas_get_fw_info(struct hisi_hba *hisi_hba)
 					"hisilicon,sas-syscon");
 		if (IS_ERR(hisi_hba->ctrl)) {
 			dev_err(dev, "could not get syscon\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (device_property_read_u32(dev, "ctrl-reset-reg",
 					     &hisi_hba->ctrl_reset_reg)) {
 			dev_err(dev, "could not get property ctrl-reset-reg\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (device_property_read_u32(dev, "ctrl-reset-sts-reg",
 					     &hisi_hba->ctrl_reset_sts_reg)) {
 			dev_err(dev, "could not get property ctrl-reset-sts-reg\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (device_property_read_u32(dev, "ctrl-clock-ena-reg",
 					     &hisi_hba->ctrl_clock_ena_reg)) {
 			dev_err(dev, "could not get property ctrl-clock-ena-reg\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -2535,13 +2535,13 @@ int hisi_sas_get_fw_info(struct hisi_hba *hisi_hba)
 
 	if (device_property_read_u32(dev, "phy-count", &hisi_hba->n_phy)) {
 		dev_err(dev, "could not get property phy-count\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (device_property_read_u32(dev, "queue-count",
 				     &hisi_hba->queue_count)) {
 		dev_err(dev, "could not get property queue-count\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/drivers/scsi/hisi_sas/hisi_sas_v1_hw.c b/drivers/scsi/hisi_sas/hisi_sas_v1_hw.c
index 09a7669da..6ba380135 100644
--- a/drivers/scsi/hisi_sas/hisi_sas_v1_hw.c
+++ b/drivers/scsi/hisi_sas/hisi_sas_v1_hw.c
@@ -1646,7 +1646,7 @@ static int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)
 			if (!irq) {
 				dev_err(dev, "irq init: fail map phy interrupt %d\n",
 					idx);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 
 			rc = devm_request_irq(dev, irq, phy_interrupts[j], 0,
@@ -1654,7 +1654,7 @@ static int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)
 			if (rc) {
 				dev_err(dev, "irq init: could not request phy interrupt %d, rc=%d\n",
 					irq, rc);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		}
 	}
@@ -1665,7 +1665,7 @@ static int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)
 		if (!irq) {
 			dev_err(dev, "irq init: could not map cq interrupt %d\n",
 				idx);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		rc = devm_request_irq(dev, irq, cq_interrupt_v1_hw, 0,
@@ -1673,7 +1673,7 @@ static int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)
 		if (rc) {
 			dev_err(dev, "irq init: could not request cq interrupt %d, rc=%d\n",
 				irq, rc);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -1683,7 +1683,7 @@ static int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)
 		if (!irq) {
 			dev_err(dev, "irq init: could not map fatal interrupt %d\n",
 				idx);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		rc = devm_request_irq(dev, irq, fatal_interrupts[i], 0,
@@ -1691,7 +1691,7 @@ static int interrupt_init_v1_hw(struct hisi_hba *hisi_hba)
 		if (rc) {
 			dev_err(dev, "irq init: could not request fatal interrupt %d, rc=%d\n",
 				irq, rc);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/drivers/scsi/hisi_sas/hisi_sas_v3_hw.c b/drivers/scsi/hisi_sas/hisi_sas_v3_hw.c
index 55e2321a6..912cb8e07 100644
--- a/drivers/scsi/hisi_sas/hisi_sas_v3_hw.c
+++ b/drivers/scsi/hisi_sas/hisi_sas_v3_hw.c
@@ -2411,7 +2411,7 @@ static int interrupt_init_v3_hw(struct hisi_hba *hisi_hba)
 							 PCI_IRQ_AFFINITY,
 							 &desc);
 		if (vectors < 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		setup_reply_map_v3_hw(hisi_hba, vectors - BASE_VECTORS_V3_HW);
 	} else {
 		min_msi = max_msi;
diff --git a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
index d9e94e81d..87c3b47f8 100644
--- a/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
+++ b/drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c
@@ -3654,7 +3654,7 @@ static int ibmvscsis_get_system_info(void)
 
 	rootdn = of_find_node_by_path("/");
 	if (!rootdn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	model = of_get_property(rootdn, "model", NULL);
 	id = of_get_property(rootdn, "system-id", NULL);
diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 2732fa651..4c3448f4f 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -1640,7 +1640,7 @@ store_fc_private_host_issue_lip(struct device *dev,
 		return ret ? ret: count;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static FC_DEVICE_ATTR(host, issue_lip, S_IWUSR, NULL,
@@ -1757,7 +1757,7 @@ fc_reset_statistics(struct device *dev, struct device_attribute *attr,
 		return count;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 static FC_DEVICE_ATTR(host, reset_statistics, S_IWUSR, NULL,
 				fc_reset_statistics);
@@ -3345,7 +3345,7 @@ fc_vport_setup(struct Scsi_Host *shost, int channel, struct device *pdev,
 	*ret_vport = NULL;
 
 	if ( ! fci->f->vport_create)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	size = (sizeof(struct fc_vport) + fci->f->dd_fcvport_size);
 	vport = kzalloc(size, GFP_KERNEL);
diff --git a/drivers/sh/clk/core.c b/drivers/sh/clk/core.c
index d996782a7..b2ed636eb 100644
--- a/drivers/sh/clk/core.c
+++ b/drivers/sh/clk/core.c
@@ -203,7 +203,7 @@ int clk_rate_table_find(struct clk *clk,
 		if (pos->frequency == rate)
 			return idx;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Used for clocks that always have same value as the parent clock */
diff --git a/drivers/soc/fsl/qe/ucc.c b/drivers/soc/fsl/qe/ucc.c
index cac0fb769..3bfa0edb9 100644
--- a/drivers/soc/fsl/qe/ucc.c
+++ b/drivers/soc/fsl/qe/ucc.c
@@ -201,7 +201,7 @@ int ucc_set_qe_mux_rxtx(unsigned int ucc_num, enum qe_clock clock,
 
 	/* Check for invalid combination of clock and UCC number */
 	if (!clock_bits)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (mode == COMM_DIR_RX)
 		shift += 4;
diff --git a/drivers/soc/mediatek/mtk-cmdq-helper.c b/drivers/soc/mediatek/mtk-cmdq-helper.c
index 87ee9f767..b3f36c2fa 100644
--- a/drivers/soc/mediatek/mtk-cmdq-helper.c
+++ b/drivers/soc/mediatek/mtk-cmdq-helper.c
@@ -33,7 +33,7 @@ int cmdq_dev_get_client_reg(struct device *dev,
 	int err;
 
 	if (!client_reg)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = of_parse_phandle_with_fixed_args(dev->of_node,
 					       "mediatek,gce-client-reg",
diff --git a/drivers/soc/renesas/rcar-sysc.c b/drivers/soc/renesas/rcar-sysc.c
index 04ea87a18..dd7a486cc 100644
--- a/drivers/soc/renesas/rcar-sysc.c
+++ b/drivers/soc/renesas/rcar-sysc.c
@@ -477,7 +477,7 @@ static int rcar_sysc_power_cpu(unsigned int idx, bool on)
 		return rcar_sysc_power(&pd->ch, on);
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int rcar_sysc_power_down_cpu(unsigned int cpu)
diff --git a/drivers/soc/tegra/pmc.c b/drivers/soc/tegra/pmc.c
index 42cf37a05..2b10bfe62 100644
--- a/drivers/soc/tegra/pmc.c
+++ b/drivers/soc/tegra/pmc.c
@@ -1259,7 +1259,7 @@ static int tegra_io_pad_get_dpd_register_bit(struct tegra_pmc *pmc,
 	pad = tegra_io_pad_find(pmc, id);
 	if (!pad) {
 		dev_err(pmc->dev, "invalid I/O pad ID %u\n", id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (pad->dpd == UINT_MAX)
@@ -1427,7 +1427,7 @@ static int tegra_io_pad_set_voltage(struct tegra_pmc *pmc, enum tegra_io_pad id,
 
 	pad = tegra_io_pad_find(pmc, id);
 	if (!pad)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (pad->voltage == UINT_MAX)
 		return -ENOTSUPP;
@@ -1474,7 +1474,7 @@ static int tegra_io_pad_get_voltage(struct tegra_pmc *pmc, enum tegra_io_pad id)
 
 	pad = tegra_io_pad_find(pmc, id);
 	if (!pad)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (pad->voltage == UINT_MAX)
 		return -ENOTSUPP;
diff --git a/drivers/soc/xilinx/zynqmp_power.c b/drivers/soc/xilinx/zynqmp_power.c
index 31ff49fcd..c325d8f5b 100644
--- a/drivers/soc/xilinx/zynqmp_power.c
+++ b/drivers/soc/xilinx/zynqmp_power.c
@@ -224,7 +224,7 @@ static int zynqmp_pm_probe(struct platform_device *pdev)
 		}
 	} else {
 		dev_err(&pdev->dev, "Required property not found in DT node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_suspend_mode.attr);
diff --git a/drivers/spi/spi-coldfire-qspi.c b/drivers/spi/spi-coldfire-qspi.c
index f80e06c87..ebe306f90 100644
--- a/drivers/spi/spi-coldfire-qspi.c
+++ b/drivers/spi/spi-coldfire-qspi.c
@@ -345,7 +345,7 @@ static int mcfqspi_probe(struct platform_device *pdev)
 	pdata = dev_get_platdata(&pdev->dev);
 	if (!pdata) {
 		dev_dbg(&pdev->dev, "platform data is missing\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!pdata->cs_control) {
diff --git a/drivers/ssb/sprom.c b/drivers/ssb/sprom.c
index 42d620cee..5229d7c44 100644
--- a/drivers/ssb/sprom.c
+++ b/drivers/ssb/sprom.c
@@ -181,7 +181,7 @@ int ssb_arch_register_fallback_sprom(int (*sprom_callback)(struct ssb_bus *bus,
 int ssb_fill_sprom_with_fallback(struct ssb_bus *bus, struct ssb_sprom *out)
 {
 	if (!get_fallback_sprom)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return get_fallback_sprom(bus, out);
 }
diff --git a/drivers/staging/board/board.c b/drivers/staging/board/board.c
index cb6feb34d..4aa543dc5 100644
--- a/drivers/staging/board/board.c
+++ b/drivers/staging/board/board.c
@@ -65,7 +65,7 @@ int __init board_staging_gic_setup_xlate(const char *gic_match,
 
 	WARN_ON(!irqc_node);
 	if (!irqc_node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	irqc_base = base;
 	return 0;
@@ -142,7 +142,7 @@ static int board_staging_add_dev_domain(struct platform_device *pdev,
 	np = of_find_node_by_path(domain);
 	if (!np) {
 		pr_err("Cannot find domain node %s\n", domain);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pd_args.np = np;
diff --git a/drivers/staging/fieldbus/anybuss/host.c b/drivers/staging/fieldbus/anybuss/host.c
index 549cb7d51..d02b072d6 100644
--- a/drivers/staging/fieldbus/anybuss/host.c
+++ b/drivers/staging/fieldbus/anybuss/host.c
@@ -1240,7 +1240,7 @@ static int anybus_of_get_host_idx(struct device_node *np)
 
 	host_idx = of_get_address(np, 0, NULL, NULL);
 	if (!host_idx)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return __be32_to_cpu(*host_idx);
 }
 
diff --git a/drivers/staging/fsl-dpaa2/ethsw/ethsw.c b/drivers/staging/fsl-dpaa2/ethsw/ethsw.c
index 546ad376d..69c48bbb1 100644
--- a/drivers/staging/fsl-dpaa2/ethsw/ethsw.c
+++ b/drivers/staging/fsl-dpaa2/ethsw/ethsw.c
@@ -211,7 +211,7 @@ static int ethsw_dellink_switch(struct ethsw_core *ethsw, u16 vid)
 	int i, err;
 
 	if (!ethsw->vlans[vid])
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = dpsw_vlan_remove(ethsw->mc_io, 0, ethsw->dpsw_handle, vid);
 	if (err) {
@@ -984,7 +984,7 @@ static int ethsw_port_del_vlan(struct ethsw_port_priv *port_priv, u16 vid)
 	int i, err;
 
 	if (!port_priv->vlans[vid])
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (port_priv->vlans[vid] & ETHSW_VLAN_PVID) {
 		err = ethsw_port_set_pvid(port_priv, 0);
@@ -1058,7 +1058,7 @@ static int port_mdb_del(struct net_device *netdev,
 	int err;
 
 	if (!port_lookup_address(netdev, 0, mdb->addr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = ethsw_port_fdb_del_mc(port_priv, mdb->addr);
 	if (err)
diff --git a/drivers/staging/fwserial/dma_fifo.c b/drivers/staging/fwserial/dma_fifo.c
index 5dcbab6fd..2586c08e6 100644
--- a/drivers/staging/fwserial/dma_fifo.c
+++ b/drivers/staging/fwserial/dma_fifo.c
@@ -141,7 +141,7 @@ int dma_fifo_in(struct dma_fifo *fifo, const void *src, int n)
 	int ofs, l;
 
 	if (!fifo->data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (fifo->corrupt)
 		return -ENXIO;
 
@@ -184,7 +184,7 @@ int dma_fifo_out_pend(struct dma_fifo *fifo, struct dma_pending *pended)
 	unsigned int len, n, ofs, l, limit;
 
 	if (!fifo->data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (fifo->corrupt)
 		return -ENXIO;
 
@@ -244,7 +244,7 @@ int dma_fifo_out_complete(struct dma_fifo *fifo, struct dma_pending *complete)
 	struct dma_pending *pending, *next, *tmp;
 
 	if (!fifo->data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (fifo->corrupt)
 		return -ENXIO;
 	if (list_empty(&fifo->pending) && fifo->open == 0)
diff --git a/drivers/staging/fwserial/fwserial.c b/drivers/staging/fwserial/fwserial.c
index aec0f1959..1f35f7794 100644
--- a/drivers/staging/fwserial/fwserial.c
+++ b/drivers/staging/fwserial/fwserial.c
@@ -706,7 +706,7 @@ static int fwtty_tx(struct fwtty_port *port, bool drain)
 
 	tty = tty_port_tty_get(&port->port);
 	if (!tty)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rcu_read_lock();
 	peer = rcu_dereference(port->peer);
diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index ec96f2888..9b584f460 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -330,7 +330,7 @@ static int is_psy_prop_writeable(struct gb_power_supply *gbpsy,
 
 	prop = get_psy_prop(gbpsy, psp);
 	if (!prop)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return prop->is_writeable ? 1 : 0;
 }
 
diff --git a/drivers/staging/media/atomisp/pci/atomisp_acc.c b/drivers/staging/media/atomisp/pci/atomisp_acc.c
index f638d0bd0..3c2b04f42 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_acc.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_acc.c
@@ -307,7 +307,7 @@ int atomisp_acc_wait(struct atomisp_sub_device *asd, unsigned int *handle)
 	int ret;
 
 	if (!asd->acc.pipeline)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (*handle && !acc_get_fw(asd, *handle))
 		return -EINVAL;
diff --git a/drivers/staging/media/rkvdec/rkvdec.c b/drivers/staging/media/rkvdec/rkvdec.c
index 225eeca73..bf082f0de 100644
--- a/drivers/staging/media/rkvdec/rkvdec.c
+++ b/drivers/staging/media/rkvdec/rkvdec.c
@@ -579,13 +579,13 @@ static int rkvdec_request_validate(struct media_request *req)
 
 	count = vb2_request_buffer_cnt(req);
 	if (!count)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	else if (count > 1)
 		return -EINVAL;
 
 	hdl = v4l2_ctrl_request_hdl_find(req, &ctx->ctrl_hdl);
 	if (!hdl)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = 0;
 	ctrls = ctx->coded_fmt_desc->ctrls;
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus.c b/drivers/staging/media/sunxi/cedrus/cedrus.c
index bc27f9430..eb614d360 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus.c
+++ b/drivers/staging/media/sunxi/cedrus/cedrus.c
@@ -212,13 +212,13 @@ static int cedrus_request_validate(struct media_request *req)
 	}
 
 	if (!ctx)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	count = vb2_request_buffer_cnt(req);
 	if (!count) {
 		v4l2_info(&ctx->dev->v4l2_dev,
 			  "No buffer was provided with the request\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (count > 1) {
 		v4l2_info(&ctx->dev->v4l2_dev,
 			  "More than one buffer was provided with the request\n");
@@ -230,7 +230,7 @@ static int cedrus_request_validate(struct media_request *req)
 	hdl = v4l2_ctrl_request_hdl_find(req, parent_hdl);
 	if (!hdl) {
 		v4l2_info(&ctx->dev->v4l2_dev, "Missing codec control(s)\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 0; i < CEDRUS_CONTROLS_COUNT; i++) {
@@ -243,7 +243,7 @@ static int cedrus_request_validate(struct media_request *req)
 		if (!ctrl_test) {
 			v4l2_info(&ctx->dev->v4l2_dev,
 				  "Missing required codec control\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/drivers/staging/most/i2c/i2c.c b/drivers/staging/most/i2c/i2c.c
index 893a8babd..a1b01fb35 100644
--- a/drivers/staging/most/i2c/i2c.c
+++ b/drivers/staging/most/i2c/i2c.c
@@ -84,7 +84,7 @@ static int configure_channel(struct most_interface *most_iface,
 		if (!polling_rate) {
 			if (dev->client->irq <= 0) {
 				pr_err("bad irq: %d\n", dev->client->irq);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			dev->rx.int_disabled = false;
 			ret = request_irq(dev->client->irq, most_irq_handler, 0,
diff --git a/drivers/staging/most/video/video.c b/drivers/staging/most/video/video.c
index 829df899b..649f0feee 100644
--- a/drivers/staging/most/video/video.c
+++ b/drivers/staging/most/video/video.c
@@ -513,7 +513,7 @@ static int comp_disconnect_channel(struct most_interface *iface,
 
 	if (!mdev) {
 		pr_err("no such channel is linked\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	spin_lock_irq(&list_lock);
diff --git a/drivers/staging/rtl8188eu/hal/fw.c b/drivers/staging/rtl8188eu/hal/fw.c
index 3d1d29e9f..1cff0f4ce 100644
--- a/drivers/staging/rtl8188eu/hal/fw.c
+++ b/drivers/staging/rtl8188eu/hal/fw.c
@@ -154,7 +154,7 @@ int rtl88eu_download_fw(struct adapter *adapt)
 
 	if (request_firmware(&fw, fw_name, device)) {
 		dev_err(device, "Firmware %s not available\n", fw_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (fw->size > FW_8188E_SIZE) {
diff --git a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
index 28ea8c3a4..192b8fedc 100644
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
@@ -2754,7 +2754,7 @@ static int vchiq_probe(struct platform_device *pdev)
 					  "raspberrypi,bcm2835-firmware");
 	if (!fw_node) {
 		dev_err(&pdev->dev, "Missing firmware node\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	drvdata->fw = rpi_firmware_get(fw_node);
diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 12e8a5b63..8be0983f0 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -642,7 +642,7 @@ static int wfx_update_tim(struct wfx_vif *wvif)
 	skb = ieee80211_beacon_get_tim(wvif->wdev->hw, wvif->vif,
 				       &tim_offset, &tim_length);
 	if (!skb)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	tim_ptr = skb->data + tim_offset;
 
 	if (tim_offset && tim_length >= 6) {
diff --git a/drivers/staging/wilc1000/cfg80211.c b/drivers/staging/wilc1000/cfg80211.c
index b6065a0d6..16b7a9ef2 100644
--- a/drivers/staging/wilc1000/cfg80211.c
+++ b/drivers/staging/wilc1000/cfg80211.c
@@ -743,7 +743,7 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 
 		if (associatedsta == ~0) {
 			netdev_err(dev, "sta required is not associated\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);
@@ -1104,7 +1104,7 @@ static int cancel_remain_on_channel(struct wiphy *wiphy,
 	struct wilc_priv *priv = &vif->priv;
 
 	if (cookie != priv->remain_on_ch_params.listen_cookie)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return wilc_listen_state_expired(vif, cookie);
 }
@@ -1257,7 +1257,7 @@ static int dump_station(struct wiphy *wiphy, struct net_device *dev,
 	int ret;
 
 	if (idx != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
 
diff --git a/drivers/staging/wlan-ng/cfg80211.c b/drivers/staging/wlan-ng/cfg80211.c
index fac38c842..8cdcb4dba 100644
--- a/drivers/staging/wlan-ng/cfg80211.c
+++ b/drivers/staging/wlan-ng/cfg80211.c
@@ -191,7 +191,7 @@ static int prism2_get_key(struct wiphy *wiphy, struct net_device *dev,
 	else if (len == 5)
 		params.cipher = WLAN_CIPHER_SUITE_WEP104;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	params.key_len = len;
 	params.key = wlandev->wep_keys[key_index];
 	params.seq_len = 0;
diff --git a/drivers/thermal/broadcom/ns-thermal.c b/drivers/thermal/broadcom/ns-thermal.c
index c9468ba9d..2ff7ecfb7 100644
--- a/drivers/thermal/broadcom/ns-thermal.c
+++ b/drivers/thermal/broadcom/ns-thermal.c
@@ -58,7 +58,7 @@ static int ns_thermal_probe(struct platform_device *pdev)
 
 	ns_thermal->pvtmon = of_iomap(dev_of_node(dev), 0);
 	if (WARN_ON(!ns_thermal->pvtmon))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ns_thermal->tz = devm_thermal_zone_of_sensor_register(dev, 0,
 							      ns_thermal,
diff --git a/drivers/thunderbolt/cap.c b/drivers/thunderbolt/cap.c
index 19db6cdc5..ff198ae5d 100644
--- a/drivers/thunderbolt/cap.c
+++ b/drivers/thunderbolt/cap.c
@@ -85,7 +85,7 @@ static int __tb_port_find_cap(struct tb_port *port, enum tb_port_cap cap)
 		offset = header.basic.next;
 	} while (offset);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
@@ -140,7 +140,7 @@ int tb_switch_find_cap(struct tb_switch *sw, enum tb_switch_cap cap)
 		offset = header.basic.next;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
@@ -182,10 +182,10 @@ int tb_switch_find_vse_cap(struct tb_switch *sw, enum tb_switch_vse_cap vsec)
 			if (header.extended_short.vsec_id == vsec)
 				return offset;
 			if (!header.extended_short.length)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			offset = header.extended_short.next;
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
diff --git a/drivers/tty/serial/earlycon.c b/drivers/tty/serial/earlycon.c
index 2ae9190b6..362827b22 100644
--- a/drivers/tty/serial/earlycon.c
+++ b/drivers/tty/serial/earlycon.c
@@ -206,7 +206,7 @@ int __init setup_earlycon(char *buf)
 		goto again;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/drivers/tty/serial/lantiq.c b/drivers/tty/serial/lantiq.c
index 62813e421..16619fb46 100644
--- a/drivers/tty/serial/lantiq.c
+++ b/drivers/tty/serial/lantiq.c
@@ -890,7 +890,7 @@ static int lqasc_probe(struct platform_device *pdev)
 
 	if (IS_ERR(ltq_port->freqclk)) {
 		pr_err("failed to get fpi clk\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* not all asc ports have clock gates, lets ignore the return code */
diff --git a/drivers/usb/atm/cxacru.c b/drivers/usb/atm/cxacru.c
index 5d41f85a7..f9eb732d8 100644
--- a/drivers/usb/atm/cxacru.c
+++ b/drivers/usb/atm/cxacru.c
@@ -1085,7 +1085,7 @@ static int cxacru_find_firmware(struct cxacru_data *instance,
 
 	if (request_firmware(fw_p, buf, dev)) {
 		usb_dbg(usbatm, "no stage %s firmware found\n", phase);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	usb_info(usbatm, "found firmware %s\n", buf);
diff --git a/drivers/usb/atm/speedtch.c b/drivers/usb/atm/speedtch.c
index 973548b5c..bff5cdc54 100644
--- a/drivers/usb/atm/speedtch.c
+++ b/drivers/usb/atm/speedtch.c
@@ -366,7 +366,7 @@ static int speedtch_find_firmware(struct usbatm_data *usbatm, struct usb_interfa
 
 			if (request_firmware(fw_p, buf, dev)) {
 				usb_err(usbatm, "%s: no stage %d firmware found!\n", __func__, phase);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		}
 	}
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 96d4507d9..15fa6f045 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -850,7 +850,7 @@ static int findintfep(struct usb_device *dev, unsigned int ep)
 			}
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int check_ctrlrecip(struct usb_dev_state *ps, unsigned int requesttype,
@@ -1534,7 +1534,7 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 	}
 	ep = ep_to_host_endpoint(ps->dev, uurb->endpoint);
 	if (!ep)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	is_in = (uurb->endpoint & USB_ENDPOINT_DIR_MASK) != 0;
 
 	u = 0;
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index de624c47e..b21cefe52 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2178,7 +2178,7 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 	}
 
 	if (!hcd->driver->bus_resume)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (HCD_RH_RUNNING(hcd))
 		return 0;
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index b1e14beaa..f8f238f47 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1969,7 +1969,7 @@ int usb_hub_release_port(struct usb_device *hdev, unsigned port1,
 	if (rc)
 		return rc;
 	if (*powner != owner)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*powner = NULL;
 	return rc;
 }
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index da923ec17..8916d9181 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -374,7 +374,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 */
 	ep = usb_pipe_endpoint(dev, urb->pipe);
 	if (!ep)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	urb->ep = ep;
 	urb->status = -EINPROGRESS;
diff --git a/drivers/usb/dwc2/gadget.c b/drivers/usb/dwc2/gadget.c
index 7faf5f8c0..670c9c89a 100644
--- a/drivers/usb/dwc2/gadget.c
+++ b/drivers/usb/dwc2/gadget.c
@@ -1661,7 +1661,7 @@ static int dwc2_hsotg_process_req_status(struct dwc2_hsotg *hsotg,
 	case USB_RECIP_ENDPOINT:
 		ep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));
 		if (!ep)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		reply = cpu_to_le16(ep->halted ? 1 : 0);
 		break;
@@ -1776,7 +1776,7 @@ static int dwc2_hsotg_process_req_feature(struct dwc2_hsotg *hsotg,
 			hsotg->test_mode = wIndex >> 8;
 			break;
 		default:
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		ret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);
@@ -1792,7 +1792,7 @@ static int dwc2_hsotg_process_req_feature(struct dwc2_hsotg *hsotg,
 		if (!ep) {
 			dev_dbg(hsotg->dev, "%s: no endpoint for 0x%04x\n",
 				__func__, wIndex);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		switch (wValue) {
@@ -1838,11 +1838,11 @@ static int dwc2_hsotg_process_req_feature(struct dwc2_hsotg *hsotg,
 			break;
 
 		default:
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return 1;
 }
diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c
index 490d353d5..a47ccf09d 100644
--- a/drivers/usb/gadget/function/f_fs.c
+++ b/drivers/usb/gadget/function/f_fs.c
@@ -2784,7 +2784,7 @@ static int ffs_ep_addr2idx(struct ffs_data *ffs, u8 endpoint_address)
 	for (i = 1; i < ARRAY_SIZE(ffs->eps_addrmap); ++i)
 		if (ffs->eps_addrmap[i] == endpoint_address)
 			return i;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int __ffs_func_bind_do_descs(enum ffs_entity_type type, u8 *valuep,
diff --git a/drivers/usb/gadget/udc/s3c-hsudc.c b/drivers/usb/gadget/udc/s3c-hsudc.c
index aaca1b0a2..ae3919f85 100644
--- a/drivers/usb/gadget/udc/s3c-hsudc.c
+++ b/drivers/usb/gadget/udc/s3c-hsudc.c
@@ -572,7 +572,7 @@ static int s3c_hsudc_handle_reqfeat(struct s3c_hsudc *hsudc,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/drivers/usb/host/bcma-hcd.c b/drivers/usb/host/bcma-hcd.c
index 652fa29be..9989c7f02 100644
--- a/drivers/usb/host/bcma-hcd.c
+++ b/drivers/usb/host/bcma-hcd.c
@@ -189,7 +189,7 @@ static int bcma_hcd_usb20_old_arm_init(struct bcma_hcd_device *usb_dev)
 	pmu_core = bcma_find_core(core->bus, BCMA_CORE_PMU);
 	if (!pmu_core) {
 		dev_err(dev, "Could not find PMU core\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Take USB core out of reset */
diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 8f75cb7b1..eb9fb4fab 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -50,7 +50,7 @@ static ssize_t companion_store(struct device *dev,
 		new_owner = 0;		/* Owned by EHCI */
 	}
 	if (portnum <= 0 || portnum > HCS_N_PORTS(ehci->hcs_params))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	portnum--;
 	if (new_owner)
 		set_bit(portnum, &ehci->companion_ports);
diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index e077b2ca5..b0f74fed4 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -59,7 +59,7 @@ static int tegra_reset_usb_controller(struct platform_device *pdev)
 
 	phy_np = of_parse_phandle(pdev->dev.of_node, "nvidia,phy", 0);
 	if (!phy_np)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * The 1st USB controller contains some UTMI pad registers that are
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 2c255d062..e3f251c2b 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2954,7 +2954,7 @@ static int prepare_ring(struct xhci_hcd *xhci, struct xhci_ring *ep_ring,
 		 * or hardware is reporting the wrong state.
 		 */
 		xhci_warn(xhci, "WARN urb submitted to disabled ep\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case EP_STATE_ERROR:
 		xhci_warn(xhci, "WARN waiting for error on ep to be cleared\n");
 		/* FIXME event handling code for error needs to clear it */
diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c
index aa3dbce22..7b5c7e600 100644
--- a/drivers/usb/serial/keyspan.c
+++ b/drivers/usb/serial/keyspan.c
@@ -1692,7 +1692,7 @@ static int keyspan_fake_startup(struct usb_serial *serial)
 	if (ezusb_fx1_ihex_firmware_download(serial->dev, fw_name) < 0) {
 		dev_err(&serial->dev->dev, "failed to load firmware \"%s\"\n",
 			fw_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* after downloading firmware Renumeration will occur in a
diff --git a/drivers/usb/serial/keyspan_pda.c b/drivers/usb/serial/keyspan_pda.c
index bf988f77d..e9a267d65 100644
--- a/drivers/usb/serial/keyspan_pda.c
+++ b/drivers/usb/serial/keyspan_pda.c
@@ -689,7 +689,7 @@ static int keyspan_pda_fake_startup(struct usb_serial *serial)
 	if (ezusb_fx1_ihex_firmware_download(serial->dev, fw_name) < 0) {
 		dev_err(&serial->dev->dev, "failed to load firmware \"%s\"\n",
 			fw_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* after downloading firmware Renumeration will occur in a
diff --git a/drivers/usb/serial/ti_usb_3410_5052.c b/drivers/usb/serial/ti_usb_3410_5052.c
index 73075b935..fc1941b75 100644
--- a/drivers/usb/serial/ti_usb_3410_5052.c
+++ b/drivers/usb/serial/ti_usb_3410_5052.c
@@ -1665,12 +1665,12 @@ static int ti_download_firmware(struct ti_device *tdev)
 check_firmware:
 	if (status) {
 		dev_err(&dev->dev, "%s - firmware not found\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (fw_p->size > TI_FIRMWARE_BUF_SIZE) {
 		dev_err(&dev->dev, "%s - firmware too large %zu\n", __func__, fw_p->size);
 		release_firmware(fw_p);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	buffer_size = TI_FIRMWARE_BUF_SIZE + sizeof(struct ti_firmware_header);
diff --git a/drivers/usb/serial/whiteheat.c b/drivers/usb/serial/whiteheat.c
index ca3bd58f2..3a54d504b 100644
--- a/drivers/usb/serial/whiteheat.c
+++ b/drivers/usb/serial/whiteheat.c
@@ -201,7 +201,7 @@ static int whiteheat_firmware_download(struct usb_serial *serial,
 		if (response >= 0)
 			return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 
diff --git a/drivers/usb/typec/ucsi/ucsi.c b/drivers/usb/typec/ucsi/ucsi.c
index d0c63afaf..43475a815 100644
--- a/drivers/usb/typec/ucsi/ucsi.c
+++ b/drivers/usb/typec/ucsi/ucsi.c
@@ -243,7 +243,7 @@ static int ucsi_next_altmode(struct typec_altmode **alt)
 		if (!alt[i])
 			return i;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int ucsi_register_altmode(struct ucsi_connector *con,
diff --git a/drivers/vfio/pci/vfio_pci.c b/drivers/vfio/pci/vfio_pci.c
index de881a6cf..f1bf0c979 100644
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@ -2029,7 +2029,7 @@ static int vfio_pci_sriov_configure(struct pci_dev *pdev, int nr_virtfn)
 	might_sleep();
 
 	if (!enable_sriov)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	device = vfio_device_get_from_dev(&pdev->dev);
 	if (!device)
diff --git a/drivers/vfio/platform/vfio_platform_common.c b/drivers/vfio/platform/vfio_platform_common.c
index c0771a956..458d1decf 100644
--- a/drivers/vfio/platform/vfio_platform_common.c
+++ b/drivers/vfio/platform/vfio_platform_common.c
@@ -53,7 +53,7 @@ static int vfio_platform_acpi_probe(struct vfio_platform_device *vdev,
 	struct acpi_device *adev;
 
 	if (acpi_disabled)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	adev = ACPI_COMPANION(dev);
 	if (!adev) {
@@ -86,7 +86,7 @@ static int vfio_platform_acpi_call_reset(struct vfio_platform_device *vdev,
 
 	return 0;
 #else
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 #endif
 }
 
diff --git a/drivers/vfio/vfio_iommu_spapr_tce.c b/drivers/vfio/vfio_iommu_spapr_tce.c
index 16b3adc50..802a2506c 100644
--- a/drivers/vfio/vfio_iommu_spapr_tce.c
+++ b/drivers/vfio/vfio_iommu_spapr_tce.c
@@ -112,7 +112,7 @@ static long tce_iommu_unregister_pages(struct tce_container *container,
 
 	mem = mm_iommu_get(container->mm, vaddr, size >> PAGE_SHIFT);
 	if (!mem)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_for_each_entry(tcemem, &container->prereg_list, next) {
 		if (tcemem->mem == mem) {
diff --git a/drivers/video/fbdev/amba-clcd.c b/drivers/video/fbdev/amba-clcd.c
index c3d55fc6c..bffeaee61 100644
--- a/drivers/video/fbdev/amba-clcd.c
+++ b/drivers/video/fbdev/amba-clcd.c
@@ -753,7 +753,7 @@ static int clcdfb_of_init_display(struct clcd_fb *fb)
 	if (of_property_read_u32_array(endpoint,
 			"arm,pl11x,tft-r0g0b0-pads",
 			tft_r0b0g0, ARRAY_SIZE(tft_r0b0g0)) != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return clcdfb_of_init_tft_panel(fb, tft_r0b0g0[0],
 					tft_r0b0g0[1],  tft_r0b0g0[2]);
diff --git a/drivers/video/fbdev/atmel_lcdfb.c b/drivers/video/fbdev/atmel_lcdfb.c
index 1e2521925..9f1d52a6e 100644
--- a/drivers/video/fbdev/atmel_lcdfb.c
+++ b/drivers/video/fbdev/atmel_lcdfb.c
@@ -959,7 +959,7 @@ static int atmel_lcdfb_of_init(struct atmel_lcdfb_info *sinfo)
 	display_np = of_parse_phandle(np, "display", 0);
 	if (!display_np) {
 		dev_err(dev, "failed to find display phandle\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = of_property_read_u32(display_np, "bits-per-pixel", &var->bits_per_pixel);
diff --git a/drivers/video/fbdev/core/fbcon.c b/drivers/video/fbdev/core/fbcon.c
index e2a490c5a..9698a9a85 100644
--- a/drivers/video/fbdev/core/fbcon.c
+++ b/drivers/video/fbdev/core/fbcon.c
@@ -2715,7 +2715,7 @@ static int fbcon_set_def_font(struct vc_data *vc, struct console_font *font, cha
 		f = get_default_font(info->var.xres, info->var.yres,
 				     info->pixmap.blit_x, info->pixmap.blit_y);
 	else if (!(f = find_font(name)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	font->width = f->width;
 	font->height = f->height;
diff --git a/drivers/video/fbdev/da8xx-fb.c b/drivers/video/fbdev/da8xx-fb.c
index 73c3c4c8c..3ae43eddb 100644
--- a/drivers/video/fbdev/da8xx-fb.c
+++ b/drivers/video/fbdev/da8xx-fb.c
@@ -1342,7 +1342,7 @@ static int fb_probe(struct platform_device *device)
 
 	if (fb_pdata == NULL) {
 		dev_err(&device->dev, "Can not get platform data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	lcdc_info = da8xx_fb_get_videomode(device);
diff --git a/drivers/video/fbdev/fb-puv3.c b/drivers/video/fbdev/fb-puv3.c
index 030e85c11..c847a247d 100644
--- a/drivers/video/fbdev/fb-puv3.c
+++ b/drivers/video/fbdev/fb-puv3.c
@@ -488,7 +488,7 @@ static int unifb_set_par(struct fb_info *info)
 	/* set clock rate */
 	clk_vga = clk_get(info->device, "VGA_CLK");
 	if (clk_vga == ERR_PTR(-ENOENT))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (pixclk != 0) {
 		if (clk_set_rate(clk_vga, pixclk)) { /* set clock failed */
diff --git a/drivers/video/fbdev/matrox/matroxfb_g450.c b/drivers/video/fbdev/matrox/matroxfb_g450.c
index df3309fd1..6c8c3bc58 100644
--- a/drivers/video/fbdev/matrox/matroxfb_g450.c
+++ b/drivers/video/fbdev/matrox/matroxfb_g450.c
@@ -72,7 +72,7 @@ static int get_ctrl_id(__u32 v4l2_id) {
 			if (g450_controls[i].desc.id == 0x08000000) {
 				return -EINVAL;
 			}
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (v4l2_id == g450_controls[i].desc.id) {
 			return i;
diff --git a/drivers/video/fbdev/matrox/matroxfb_maven.c b/drivers/video/fbdev/matrox/matroxfb_maven.c
index eda893b7a..0e66d6ce9 100644
--- a/drivers/video/fbdev/matrox/matroxfb_maven.c
+++ b/drivers/video/fbdev/matrox/matroxfb_maven.c
@@ -117,7 +117,7 @@ static int get_ctrl_id(__u32 v4l2_id) {
 			if (maven_controls[i].desc.id == 0x08000000) {
 				return -EINVAL;
 			}
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (v4l2_id == maven_controls[i].desc.id) {
 			return i;
diff --git a/drivers/video/fbdev/omap/lcd_mipid.c b/drivers/video/fbdev/omap/lcd_mipid.c
index a75ae0c9b..42f2aacc5 100644
--- a/drivers/video/fbdev/omap/lcd_mipid.c
+++ b/drivers/video/fbdev/omap/lcd_mipid.c
@@ -516,7 +516,7 @@ static int mipid_detect(struct mipid_device *md)
 	pdata = md->spi->dev.platform_data;
 	if (pdata == NULL) {
 		dev_err(&md->spi->dev, "missing platform data\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mipid_read(md, MIPID_CMD_READ_DISP_ID, display_id, 3);
diff --git a/drivers/video/fbdev/omap2/omapfb/dss/core.c b/drivers/video/fbdev/omap2/omapfb/dss/core.c
index 37858be8b..57213a0a2 100644
--- a/drivers/video/fbdev/omap2/omapfb/dss/core.c
+++ b/drivers/video/fbdev/omap2/omapfb/dss/core.c
@@ -62,7 +62,7 @@ int dss_dsi_enable_pads(int dsi_id, unsigned lane_mask)
 	struct omap_dss_board_info *board_data = core.pdev->dev.platform_data;
 
 	if (!board_data->dsi_enable_pads)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return board_data->dsi_enable_pads(dsi_id, lane_mask);
 }
diff --git a/drivers/video/fbdev/omap2/omapfb/dss/display-sysfs.c b/drivers/video/fbdev/omap2/omapfb/dss/display-sysfs.c
index 6dbe265b3..a814ca374 100644
--- a/drivers/video/fbdev/omap2/omapfb/dss/display-sysfs.c
+++ b/drivers/video/fbdev/omap2/omapfb/dss/display-sysfs.c
@@ -71,7 +71,7 @@ static ssize_t display_tear_store(struct omap_dss_device *dssdev,
 	bool te;
 
 	if (!dssdev->driver->enable_te || !dssdev->driver->get_te)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	r = strtobool(buf, &te);
 	if (r)
@@ -89,7 +89,7 @@ static ssize_t display_timings_show(struct omap_dss_device *dssdev, char *buf)
 	struct omap_video_timings t;
 
 	if (!dssdev->driver->get_timings)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dssdev->driver->get_timings(dssdev, &t);
 
@@ -106,7 +106,7 @@ static ssize_t display_timings_store(struct omap_dss_device *dssdev,
 	int r, found;
 
 	if (!dssdev->driver->set_timings || !dssdev->driver->check_timings)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	found = 0;
 #ifdef CONFIG_FB_OMAP2_DSS_VENC
@@ -141,7 +141,7 @@ static ssize_t display_rotate_show(struct omap_dss_device *dssdev, char *buf)
 {
 	int rotate;
 	if (!dssdev->driver->get_rotate)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	rotate = dssdev->driver->get_rotate(dssdev);
 	return snprintf(buf, PAGE_SIZE, "%u\n", rotate);
 }
@@ -152,7 +152,7 @@ static ssize_t display_rotate_store(struct omap_dss_device *dssdev,
 	int rot, r;
 
 	if (!dssdev->driver->set_rotate || !dssdev->driver->get_rotate)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	r = kstrtoint(buf, 0, &rot);
 	if (r)
@@ -169,7 +169,7 @@ static ssize_t display_mirror_show(struct omap_dss_device *dssdev, char *buf)
 {
 	int mirror;
 	if (!dssdev->driver->get_mirror)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	mirror = dssdev->driver->get_mirror(dssdev);
 	return snprintf(buf, PAGE_SIZE, "%u\n", mirror);
 }
@@ -181,7 +181,7 @@ static ssize_t display_mirror_store(struct omap_dss_device *dssdev,
 	bool mirror;
 
 	if (!dssdev->driver->set_mirror || !dssdev->driver->get_mirror)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	r = strtobool(buf, &mirror);
 	if (r)
@@ -199,7 +199,7 @@ static ssize_t display_wss_show(struct omap_dss_device *dssdev, char *buf)
 	unsigned int wss;
 
 	if (!dssdev->driver->get_wss)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	wss = dssdev->driver->get_wss(dssdev);
 
@@ -213,7 +213,7 @@ static ssize_t display_wss_store(struct omap_dss_device *dssdev,
 	int r;
 
 	if (!dssdev->driver->get_wss || !dssdev->driver->set_wss)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	r = kstrtou32(buf, 0, &wss);
 	if (r)
@@ -276,7 +276,7 @@ static ssize_t display_attr_show(struct kobject *kobj, struct attribute *attr,
 	display_attr = container_of(attr, struct display_attribute, attr);
 
 	if (!display_attr->show)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return display_attr->show(dssdev, buf);
 }
@@ -291,7 +291,7 @@ static ssize_t display_attr_store(struct kobject *kobj, struct attribute *attr,
 	display_attr = container_of(attr, struct display_attribute, attr);
 
 	if (!display_attr->store)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return display_attr->store(dssdev, buf, size);
 }
diff --git a/drivers/video/fbdev/omap2/omapfb/dss/manager-sysfs.c b/drivers/video/fbdev/omap2/omapfb/dss/manager-sysfs.c
index b52cc1af0..c4388cc60 100644
--- a/drivers/video/fbdev/omap2/omapfb/dss/manager-sysfs.c
+++ b/drivers/video/fbdev/omap2/omapfb/dss/manager-sysfs.c
@@ -468,7 +468,7 @@ static ssize_t manager_attr_show(struct kobject *kobj, struct attribute *attr,
 	manager_attr = container_of(attr, struct manager_attribute, attr);
 
 	if (!manager_attr->show)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return manager_attr->show(manager, buf);
 }
@@ -483,7 +483,7 @@ static ssize_t manager_attr_store(struct kobject *kobj, struct attribute *attr,
 	manager_attr = container_of(attr, struct manager_attribute, attr);
 
 	if (!manager_attr->store)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return manager_attr->store(manager, buf, size);
 }
diff --git a/drivers/video/fbdev/omap2/omapfb/dss/overlay-sysfs.c b/drivers/video/fbdev/omap2/omapfb/dss/overlay-sysfs.c
index 36acf3662..ace0aa158 100644
--- a/drivers/video/fbdev/omap2/omapfb/dss/overlay-sysfs.c
+++ b/drivers/video/fbdev/omap2/omapfb/dss/overlay-sysfs.c
@@ -401,7 +401,7 @@ static ssize_t overlay_attr_show(struct kobject *kobj, struct attribute *attr,
 	overlay_attr = container_of(attr, struct overlay_attribute, attr);
 
 	if (!overlay_attr->show)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return overlay_attr->show(overlay, buf);
 }
@@ -416,7 +416,7 @@ static ssize_t overlay_attr_store(struct kobject *kobj, struct attribute *attr,
 	overlay_attr = container_of(attr, struct overlay_attribute, attr);
 
 	if (!overlay_attr->store)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return overlay_attr->store(overlay, buf, size);
 }
diff --git a/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c b/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c
index f40be68d5..7c3463f00 100644
--- a/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c
+++ b/drivers/video/fbdev/omap2/omapfb/omapfb-ioctl.c
@@ -480,7 +480,7 @@ static int omapfb_memory_read(struct fb_info *fbi,
 	int r;
 
 	if (!display || !display->driver->memory_read)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (mr->w > 4096 || mr->h > 4096)
 		return -EINVAL;
@@ -541,7 +541,7 @@ static int omapfb_get_ovl_colormode(struct omapfb2_device *fbdev,
 	}
 
 	if (i == sizeof(supported_modes) * 8)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mode->bits_per_pixel = var.bits_per_pixel;
 	mode->nonstd = var.nonstd;
diff --git a/drivers/video/fbdev/omap2/omapfb/omapfb-main.c b/drivers/video/fbdev/omap2/omapfb/omapfb-main.c
index 836e7b163..f8da2f5fd 100644
--- a/drivers/video/fbdev/omap2/omapfb/omapfb-main.c
+++ b/drivers/video/fbdev/omap2/omapfb/omapfb-main.c
@@ -584,7 +584,7 @@ int dss_mode_to_fb_mode(enum omap_color_mode dssmode,
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void set_fb_fix(struct fb_info *fbi)
diff --git a/drivers/video/fbdev/pxa168fb.c b/drivers/video/fbdev/pxa168fb.c
index eedfbd357..cdec293db 100644
--- a/drivers/video/fbdev/pxa168fb.c
+++ b/drivers/video/fbdev/pxa168fb.c
@@ -618,13 +618,13 @@ static int pxa168fb_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "no IO memory defined\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "no IRQ defined\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	info = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);
diff --git a/drivers/video/fbdev/s3c2410fb.c b/drivers/video/fbdev/s3c2410fb.c
index 2fb15a540..01190c07f 100644
--- a/drivers/video/fbdev/s3c2410fb.c
+++ b/drivers/video/fbdev/s3c2410fb.c
@@ -851,7 +851,7 @@ static int s3c24xxfb_probe(struct platform_device *pdev,
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "no irq for device\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fbinfo = framebuffer_alloc(sizeof(struct s3c2410fb_info), &pdev->dev);
diff --git a/drivers/video/fbdev/sh_mobile_lcdcfb.c b/drivers/video/fbdev/sh_mobile_lcdcfb.c
index 8a27d12e6..0bd1161b4 100644
--- a/drivers/video/fbdev/sh_mobile_lcdcfb.c
+++ b/drivers/video/fbdev/sh_mobile_lcdcfb.c
@@ -2523,7 +2523,7 @@ static int sh_mobile_lcdc_probe(struct platform_device *pdev)
 	irq = platform_get_irq(pdev, 0);
 	if (!res || irq < 0) {
 		dev_err(&pdev->dev, "cannot get platform resources\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index abc9ada79..b4d4dcd21 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -126,7 +126,7 @@ int of_get_display_timing(const struct device_node *np, const char *name,
 
 	timing_np = of_get_child_by_name(np, name);
 	if (!timing_np)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = of_parse_display_timing(timing_np, dt);
 
diff --git a/drivers/visorbus/visorbus_main.c b/drivers/visorbus/visorbus_main.c
index 152fd29f0..2478fd7bf 100644
--- a/drivers/visorbus/visorbus_main.c
+++ b/drivers/visorbus/visorbus_main.c
@@ -605,7 +605,7 @@ int visorbus_enable_channel_interrupts(struct visor_device *dev)
 
 	if (!drv->channel_interrupt) {
 		dev_err(&dev->device, "%s no interrupt function!\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return dev_start_periodic_work(dev);
diff --git a/drivers/watchdog/pika_wdt.c b/drivers/watchdog/pika_wdt.c
index a98abd0d3..bc4ff042d 100644
--- a/drivers/watchdog/pika_wdt.c
+++ b/drivers/watchdog/pika_wdt.c
@@ -233,7 +233,7 @@ static int __init pikawdt_init(void)
 	np = of_find_compatible_node(NULL, NULL, "pika,fpga");
 	if (np == NULL) {
 		pr_err("Unable to find fpga\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pikawdt_private.fpga = of_iomap(np, 0);
diff --git a/drivers/watchdog/rza_wdt.c b/drivers/watchdog/rza_wdt.c
index 7b6c365f7..6281e2602 100644
--- a/drivers/watchdog/rza_wdt.c
+++ b/drivers/watchdog/rza_wdt.c
@@ -186,7 +186,7 @@ static int rza_wdt_probe(struct platform_device *pdev)
 	rate = clk_get_rate(priv->clk);
 	if (rate < 16384) {
 		dev_err(dev, "invalid clock rate (%ld)\n", rate);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	priv->wdev.info = &rza_wdt_ident,
diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c
index 140c7bf33..f4dd4b638 100644
--- a/drivers/xen/events/events_base.c
+++ b/drivers/xen/events/events_base.c
@@ -1140,12 +1140,12 @@ int evtchn_make_refcounted(evtchn_port_t evtchn)
 	struct irq_info *info;
 
 	if (irq == -1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	info = irq_get_handler_data(irq);
 
 	if (!info)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	WARN_ON(info->refcnt != -1);
 
@@ -1547,7 +1547,7 @@ int xen_test_irq_shared(int irq)
 	struct physdev_irq_status_query irq_status;
 
 	if (WARN_ON(!info))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	irq_status.irq = info->u.pirq.pirq;
 
diff --git a/drivers/xen/xenbus/xenbus_client.c b/drivers/xen/xenbus/xenbus_client.c
index 786fbb7d8..baec7e808 100644
--- a/drivers/xen/xenbus/xenbus_client.c
+++ b/drivers/xen/xenbus/xenbus_client.c
@@ -544,7 +544,7 @@ static int __xenbus_map_ring(struct xenbus_device *dev,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/drivers/xen/xenbus/xenbus_dev_frontend.c b/drivers/xen/xenbus/xenbus_dev_frontend.c
index 597af455a..f8bd9f4e0 100644
--- a/drivers/xen/xenbus/xenbus_dev_frontend.c
+++ b/drivers/xen/xenbus/xenbus_dev_frontend.c
@@ -651,7 +651,7 @@ static int xenbus_file_open(struct inode *inode, struct file *filp)
 	struct xenbus_file_priv *u;
 
 	if (xen_store_evtchn == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	stream_open(inode, filp);
 
diff --git a/drivers/xen/xenbus/xenbus_probe.c b/drivers/xen/xenbus/xenbus_probe.c
index 38725d97d..92a995b3a 100644
--- a/drivers/xen/xenbus/xenbus_probe.c
+++ b/drivers/xen/xenbus/xenbus_probe.c
@@ -161,7 +161,7 @@ int xenbus_read_otherend_details(struct xenbus_device *xendev,
 				 "missing or inaccessible.",
 				 xendev->nodename);
 		free_otherend_details(xendev);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/fs/adfs/dir_f.c b/fs/adfs/dir_f.c
index 30d526fec..c946f2aa3 100644
--- a/fs/adfs/dir_f.c
+++ b/fs/adfs/dir_f.c
@@ -222,7 +222,7 @@ __adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)
 		return ret;
 
 	if (!de.dirobname[0])
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	adfs_dir2obj(dir, obj, &de);
 
@@ -233,7 +233,7 @@ static int
 adfs_f_setpos(struct adfs_dir *dir, unsigned int fpos)
 {
 	if (fpos >= ADFS_NUM_DIR_ENTRIES)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dir->pos = 5 + fpos * 26;
 	return 0;
@@ -280,11 +280,11 @@ static int adfs_f_update(struct adfs_dir *dir, struct object_info *obj)
 		ret = adfs_dir_copyfrom(&de, dir, offset, sizeof(de));
 		if (ret) {
 			adfs_error(dir->sb, "error reading directory entry");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (!de.dirobname[0]) {
 			adfs_error(dir->sb, "unable to locate entry to update");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} while (adfs_readval(de.dirinddiscadd, 3) != obj->indaddr);
 
diff --git a/fs/adfs/dir_fplus.c b/fs/adfs/dir_fplus.c
index 4a1592401..9c996977c 100644
--- a/fs/adfs/dir_fplus.c
+++ b/fs/adfs/dir_fplus.c
@@ -177,7 +177,7 @@ adfs_fplus_getnext(struct adfs_dir *dir, struct object_info *obj)
 	int ret;
 
 	if (dir->pos >= le32_to_cpu(h->bigdirentries))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	offset = adfs_fplus_offset(h, dir->pos);
 
@@ -240,12 +240,12 @@ static int adfs_fplus_update(struct adfs_dir *dir, struct object_info *obj)
 		offset += sizeof(bde);
 		if (offset >= end) {
 			adfs_error(dir->sb, "unable to locate entry to update");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		ret = adfs_dir_copyfrom(&bde, dir, offset, sizeof(bde));
 		if (ret) {
 			adfs_error(dir->sb, "error reading directory entry");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	} while (le32_to_cpu(bde.bigdirindaddr) != obj->indaddr);
 
diff --git a/fs/afs/dir.c b/fs/afs/dir.c
index 96757f3ab..5e01797e5 100644
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@ -199,7 +199,7 @@ static int afs_dir_open(struct inode *inode, struct file *file)
 	BUILD_BUG_ON(sizeof(union afs_xdr_dirent) != 32);
 
 	if (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(inode)->flags))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return afs_open(inode, file);
 }
@@ -580,7 +580,7 @@ static int afs_do_lookup_one(struct inode *dir, struct dentry *dentry,
 	ret = -ENOENT;
 	if (!cookie.found) {
 		_leave(" = -ENOENT [not found]");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	*fid = cookie.fid;
diff --git a/fs/afs/flock.c b/fs/afs/flock.c
index ffb857534..48f2ae7ee 100644
--- a/fs/afs/flock.c
+++ b/fs/afs/flock.c
@@ -729,7 +729,7 @@ static int afs_do_getlk(struct file *file, struct file_lock *fl)
 	_enter("");
 
 	if (vnode->lock_state == AFS_VNODE_LOCK_DELETED)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	fl->fl_type = F_UNLCK;
 
diff --git a/fs/afs/misc.c b/fs/afs/misc.c
index 5334f1bd2..f2901ab3f 100644
--- a/fs/afs/misc.c
+++ b/fs/afs/misc.c
@@ -25,11 +25,11 @@ int afs_abort_to_error(u32 abort_code)
 
 		/* VICE "special error" codes; 101 - 111 */
 	case VSALVAGE:		return -EIO;
-	case VNOVNODE:		return -ENOENT;
+	case VNOVNODE:		ENOENT_DUMPER(stackdump_tuneable);
 	case VNOVOL:		return -ENOMEDIUM;
 	case VVOLEXISTS:	return -EEXIST;
 	case VNOSERVICE:	return -EIO;
-	case VOFFLINE:		return -ENOENT;
+	case VOFFLINE:		ENOENT_DUMPER(stackdump_tuneable);
 	case VONLINE:		return -EEXIST;
 	case VDISKFULL:		return -ENOSPC;
 	case VOVERQUOTA:	return -EDQUOT;
@@ -50,9 +50,9 @@ int afs_abort_to_error(u32 abort_code)
 	case AFSVL_BADSERVER:		return -EINVAL;
 	case AFSVL_BADPARTITION:	return -EINVAL;
 	case AFSVL_REPSFULL:		return -EFBIG;
-	case AFSVL_NOREPSERVER:		return -ENOENT;
+	case AFSVL_NOREPSERVER:		ENOENT_DUMPER(stackdump_tuneable);
 	case AFSVL_DUPREPSERVER:	return -EEXIST;
-	case AFSVL_RWNOTFOUND:		return -ENOENT;
+	case AFSVL_RWNOTFOUND:		ENOENT_DUMPER(stackdump_tuneable);
 	case AFSVL_BADREFCOUNT:		return -EINVAL;
 	case AFSVL_SIZEEXCEEDED:	return -EINVAL;
 	case AFSVL_BADENTRY:		return -EINVAL;
@@ -68,7 +68,7 @@ int afs_abort_to_error(u32 abort_code)
 
 		/* Unified AFS error table */
 	case UAEPERM:			return -EPERM;
-	case UAENOENT:			return -ENOENT;
+	case UAENOENT:			ENOENT_DUMPER(stackdump_tuneable);
 	case UAEACCES:			return -EACCES;
 	case UAEBUSY:			return -EBUSY;
 	case UAEEXIST:			return -EEXIST;
diff --git a/fs/afs/mntpt.c b/fs/afs/mntpt.c
index 79bc5f133..bc989c952 100644
--- a/fs/afs/mntpt.c
+++ b/fs/afs/mntpt.c
@@ -96,7 +96,7 @@ static int afs_mntpt_set_params(struct fs_context *fc, struct dentry *mntpt)
 		unsigned size = mntpt->d_name.len;
 
 		if (size < 2)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		p = mntpt->d_name.name;
 		if (mntpt->d_name.name[0] == '.') {
diff --git a/fs/autofs/root.c b/fs/autofs/root.c
index 5aaa1732b..a50203ecc 100644
--- a/fs/autofs/root.c
+++ b/fs/autofs/root.c
@@ -93,7 +93,7 @@ static int autofs_dir_open(struct inode *inode, struct file *file)
 	spin_lock(&sbi->lookup_lock);
 	if (!path_is_mountpoint(&file->f_path) && simple_empty(dentry)) {
 		spin_unlock(&sbi->lookup_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	spin_unlock(&sbi->lookup_lock);
 
diff --git a/fs/autofs/waitq.c b/fs/autofs/waitq.c
index 74c886f7c..69f4e8872 100644
--- a/fs/autofs/waitq.c
+++ b/fs/autofs/waitq.c
@@ -253,7 +253,7 @@ static int validate_request(struct autofs_wait_queue **wait,
 	struct autofs_info *ino;
 
 	if (sbi->flags & AUTOFS_SBI_CATATONIC)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Wait in progress, continue; */
 	wq = autofs_find_wait(sbi, qstr);
@@ -288,7 +288,7 @@ static int validate_request(struct autofs_wait_queue **wait,
 				return -EINTR;
 
 			if (sbi->flags & AUTOFS_SBI_CATATONIC)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 
 			wq = autofs_find_wait(sbi, qstr);
 			if (wq) {
@@ -357,7 +357,7 @@ int autofs_wait(struct autofs_sb_info *sbi,
 
 	/* In catatonic mode, we don't wait for nobody */
 	if (sbi->flags & AUTOFS_SBI_CATATONIC)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Try translating pids to the namespace of the daemon.
@@ -367,7 +367,7 @@ int autofs_wait(struct autofs_sb_info *sbi,
 	pid = task_pid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));
 	tgid = task_tgid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));
 	if (pid == 0 || tgid == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (d_really_is_negative(dentry)) {
 		/*
@@ -379,9 +379,9 @@ int autofs_wait(struct autofs_sb_info *sbi,
 		 * in the root of the autofs file system may be negative.
 		 */
 		if (autofs_type_trigger(sbi->type))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		else if (!IS_ROOT(dentry->d_parent))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	name = kmalloc(NAME_MAX + 1, GFP_KERNEL);
@@ -395,7 +395,7 @@ int autofs_wait(struct autofs_sb_info *sbi,
 		qstr.len = autofs_getpath(sbi, dentry, name);
 		if (!qstr.len) {
 			kfree(name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	qstr.name = name;
diff --git a/fs/bfs/dir.c b/fs/bfs/dir.c
index d8dfe3a0c..d96cdf18a 100644
--- a/fs/bfs/dir.c
+++ b/fs/bfs/dir.c
@@ -276,7 +276,7 @@ static int bfs_add_entry(struct inode *dir, const struct qstr *child, int ino)
 	dprintf("name=%s, namelen=%d\n", name, namelen);
 
 	if (!namelen)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (namelen > BFS_NAMELEN)
 		return -ENAMETOOLONG;
 
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 9fe3b51c1..165823355 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -697,7 +697,7 @@ static int parse_elf_property(const char *data, size_t *off, size_t datasz,
 	int ret;
 
 	if (*off == datasz)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (WARN_ON_ONCE(*off > datasz || *off % ELF_GNU_PROPERTY_ALIGN))
 		return -EIO;
diff --git a/fs/binfmt_em86.c b/fs/binfmt_em86.c
index 06b9b9fdd..539b89d6a 100644
--- a/fs/binfmt_em86.c
+++ b/fs/binfmt_em86.c
@@ -46,7 +46,7 @@ static int load_em86(struct linux_binprm *bprm)
 
 	/* Need to be able to load the file after exec */
 	if (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Unlike in the script case, we don't have to do any hairy
 	 * parsing to find our interpreter... it's hardcoded!
diff --git a/fs/binfmt_script.c b/fs/binfmt_script.c
index 1b6625e95..70cbcd5c1 100644
--- a/fs/binfmt_script.c
+++ b/fs/binfmt_script.c
@@ -91,7 +91,7 @@ static int load_script(struct linux_binprm *bprm)
 	 * this file).
 	 */
 	if (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * OK, we've parsed out the interpreter name and
diff --git a/fs/btrfs/backref.c b/fs/btrfs/backref.c
index ea10f7bc9..5acb6643d 100644
--- a/fs/btrfs/backref.c
+++ b/fs/btrfs/backref.c
@@ -1764,7 +1764,7 @@ int extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,
 	    found_key->objectid + size <= logical) {
 		btrfs_debug(fs_info,
 			"logical %llu is not within any extent", logical);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	eb = path->nodes[0];
@@ -1832,7 +1832,7 @@ static int get_extent_inline_ref(unsigned long *ptr,
 		}
 		*ptr = (unsigned long)*out_eiref;
 		if ((unsigned long)(*ptr) >= (unsigned long)ei + item_size)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	end = (unsigned long)ei + item_size;
@@ -2621,7 +2621,7 @@ static int handle_direct_tree_backref(struct btrfs_backref_cache *cache,
 		if (cache->is_reloc) {
 			root = find_reloc_root(cache->fs_info, cur->bytenr);
 			if (WARN_ON(!root))
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			cur->root = root;
 		} else {
 			/*
diff --git a/fs/btrfs/delayed-inode.c b/fs/btrfs/delayed-inode.c
index bf1595a42..dae54e04a 100644
--- a/fs/btrfs/delayed-inode.c
+++ b/fs/btrfs/delayed-inode.c
@@ -889,7 +889,7 @@ static int btrfs_batch_delete_items(struct btrfs_trans_handle *trans,
 	i = path->slots[0];
 	last_item = btrfs_header_nritems(leaf) - 1;
 	if (i > last_item)
-		return -ENOENT;	/* FIXME: Is errno suitable? */
+		ENOENT_DUMPER(stackdump_tuneable);	/* FIXME: Is errno suitable? */
 
 	next = item;
 	INIT_LIST_HEAD(&head);
@@ -1035,7 +1035,7 @@ static int __btrfs_update_delayed_inode(struct btrfs_trans_handle *trans,
 	memalloc_nofs_restore(nofs_flag);
 	if (ret > 0) {
 		btrfs_release_path(path);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (ret < 0) {
 		return ret;
 	}
@@ -1569,7 +1569,7 @@ int btrfs_inode_delayed_dir_index_count(struct btrfs_inode *inode)
 	struct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);
 
 	if (!delayed_node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Since we have held i_mutex of this directory, it is impossible that
@@ -1777,13 +1777,13 @@ int btrfs_fill_inode(struct inode *inode, u32 *rdev)
 
 	delayed_node = btrfs_get_delayed_node(BTRFS_I(inode));
 	if (!delayed_node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&delayed_node->mutex);
 	if (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {
 		mutex_unlock(&delayed_node->mutex);
 		btrfs_release_delayed_node(delayed_node);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	inode_item = &delayed_node->inode_item;
diff --git a/fs/btrfs/export.c b/fs/btrfs/export.c
index 1a8d419d9..3e8e25d38 100644
--- a/fs/btrfs/export.c
+++ b/fs/btrfs/export.c
@@ -244,7 +244,7 @@ static int btrfs_get_name(struct dentry *parent, char *name,
 			path->slots[0]--;
 		} else {
 			btrfs_free_path(path);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	leaf = path->nodes[0];
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index c0bc35f93..a1eb9ebcc 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -3517,7 +3517,7 @@ static int find_free_extent_clustered(struct btrfs_block_group *bg,
 	if (ffe_ctl->loop >= LOOP_NO_EMPTY_SIZE && cluster_bg != bg) {
 		spin_unlock(&last_ptr->refill_lock);
 		btrfs_release_block_group(cluster_bg, ffe_ctl->delalloc);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* This cluster didn't work out, free it and start over */
@@ -3529,7 +3529,7 @@ static int find_free_extent_clustered(struct btrfs_block_group *bg,
 refill_cluster:
 	if (ffe_ctl->loop >= LOOP_NO_EMPTY_SIZE) {
 		spin_unlock(&last_ptr->refill_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	aligned_cluster = max_t(u64,
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 6862cd7e2..038db1dac 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -7209,7 +7209,7 @@ static int btrfs_get_blocks_direct_read(struct extent_map *em,
 
 	if (em->block_start == EXTENT_MAP_HOLE ||
 			test_bit(EXTENT_FLAG_PREALLOC, &em->flags))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	len = min(len, em->len - (start - em->start));
 
diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index e8f7c5f00..55c2792c4 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -859,7 +859,7 @@ static int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)
 	int error;
 
 	if (d_really_is_negative(victim))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	BUG_ON(d_inode(victim->d_parent) != dir);
 	audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);
@@ -880,7 +880,7 @@ static int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)
 	} else if (d_is_dir(victim))
 		return -EISDIR;
 	if (IS_DEADDIR(dir))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
 		return -EBUSY;
 	return 0;
@@ -892,7 +892,7 @@ static inline int btrfs_may_create(struct inode *dir, struct dentry *child)
 	if (d_really_is_positive(child))
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
 }
 
@@ -1092,7 +1092,7 @@ static int find_new_extents(struct btrfs_root *root,
 	}
 none:
 	btrfs_free_path(path);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct extent_map *defrag_lookup_extent(struct inode *inode, u64 start)
diff --git a/fs/btrfs/qgroup.c b/fs/btrfs/qgroup.c
index 5bd4089ad..d0d77653a 100644
--- a/fs/btrfs/qgroup.c
+++ b/fs/btrfs/qgroup.c
@@ -249,7 +249,7 @@ static int del_qgroup_rb(struct btrfs_fs_info *fs_info, u64 qgroupid)
 	struct btrfs_qgroup *qgroup = find_qgroup_rb(fs_info, qgroupid);
 
 	if (!qgroup)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rb_erase(&qgroup->node, &fs_info->qgroup_tree);
 	__del_qgroup_rb(qgroup);
@@ -267,7 +267,7 @@ static int add_relation_rb(struct btrfs_fs_info *fs_info,
 	member = find_qgroup_rb(fs_info, memberid);
 	parent = find_qgroup_rb(fs_info, parentid);
 	if (!member || !parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list = kzalloc(sizeof(*list), GFP_ATOMIC);
 	if (!list)
@@ -292,7 +292,7 @@ static int del_relation_rb(struct btrfs_fs_info *fs_info,
 	member = find_qgroup_rb(fs_info, memberid);
 	parent = find_qgroup_rb(fs_info, parentid);
 	if (!member || !parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_for_each_entry(list, &member->groups, next_group) {
 		if (list->group == parent) {
@@ -302,7 +302,7 @@ static int del_relation_rb(struct btrfs_fs_info *fs_info,
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 3bbae80c7..2d8dc3779 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -2979,7 +2979,7 @@ static int delete_block_group_cache(struct btrfs_fs_info *fs_info,
 
 	inode = btrfs_iget(fs_info->sb, ino, root);
 	if (IS_ERR(inode))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 truncate:
 	ret = btrfs_check_trunc_cache_free_space(fs_info,
@@ -3033,7 +3033,7 @@ static int delete_v1_space_cache(struct extent_buffer *leaf,
 		}
 	}
 	if (!found)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ret = delete_block_group_cache(leaf->fs_info, block_group, NULL,
 					space_cache_ino);
 	return ret;
@@ -3568,7 +3568,7 @@ int btrfs_relocate_block_group(struct btrfs_fs_info *fs_info, u64 group_start)
 
 	bg = btrfs_lookup_block_group(fs_info, group_start);
 	if (!bg)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (btrfs_pinned_by_swapfile(fs_info, bg)) {
 		btrfs_put_block_group(bg);
diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index 016a025e3..77c483d53 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -433,7 +433,7 @@ static int lock_full_stripe(struct btrfs_fs_info *fs_info, u64 bytenr,
 	bg_cache = btrfs_lookup_block_group(fs_info, bytenr);
 	if (!bg_cache) {
 		ASSERT(0);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Profiles not based on parity don't need full stripe lock */
@@ -484,7 +484,7 @@ static int unlock_full_stripe(struct btrfs_fs_info *fs_info, u64 bytenr,
 	bg_cache = btrfs_lookup_block_group(fs_info, bytenr);
 	if (!bg_cache) {
 		ASSERT(0);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (!(bg_cache->flags & BTRFS_BLOCK_GROUP_RAID56_MASK))
 		goto out;
diff --git a/fs/btrfs/send.c b/fs/btrfs/send.c
index d9813a5b0..eaf5483d2 100644
--- a/fs/btrfs/send.c
+++ b/fs/btrfs/send.c
@@ -4346,7 +4346,7 @@ static int find_iref(struct btrfs_root *root,
 		return ret;
 
 	if (ctx.found_idx == -1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return ctx.found_idx;
 }
@@ -4668,7 +4668,7 @@ static int find_xattr(struct btrfs_root *root,
 		return ret;
 
 	if (ctx.found_idx == -1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (data) {
 		*data = ctx.found_data;
 		*data_len = ctx.found_data_len;
diff --git a/fs/btrfs/tests/free-space-tests.c b/fs/btrfs/tests/free-space-tests.c
index aebdf23f0..60ca313ff 100644
--- a/fs/btrfs/tests/free-space-tests.c
+++ b/fs/btrfs/tests/free-space-tests.c
@@ -466,11 +466,11 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	/* Confirm that only those 2 ranges are marked as free. */
 	if (!test_check_exists(cache, SZ_128M - SZ_256K, SZ_128K)) {
 		test_err("free space range missing");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (!test_check_exists(cache, SZ_128M + SZ_512K, SZ_256K)) {
 		test_err("free space range missing");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -514,7 +514,7 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	/* Confirm the region is marked as free. */
 	if (!test_check_exists(cache, SZ_128M, SZ_512K)) {
 		test_err("bitmap region not marked as free");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -558,7 +558,7 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	/* Confirm the region is marked as free. */
 	if (!test_check_exists(cache, SZ_128M - SZ_128K, SZ_128K)) {
 		test_err("extent region not marked as free");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -586,7 +586,7 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	 */
 	if (!test_check_exists(cache, SZ_128M - SZ_256K, SZ_1M)) {
 		test_err("expected region not marked as free");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (cache->free_space_ctl->free_space != (SZ_1M + sectorsize)) {
@@ -674,11 +674,11 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	/* Confirm that only those 2 ranges are marked as free. */
 	if (!test_check_exists(cache, SZ_128M + SZ_128K, SZ_128K)) {
 		test_err("free space range missing");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (!test_check_exists(cache, SZ_128M - 768 * SZ_1K, SZ_256K)) {
 		test_err("free space range missing");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -712,7 +712,7 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	/* Confirm the region is marked as free. */
 	if (!test_check_exists(cache, SZ_128M - SZ_512K, SZ_512K)) {
 		test_err("bitmap region not marked as free");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -748,7 +748,7 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	/* Confirm the region is marked as free. */
 	if (!test_check_exists(cache, SZ_128M, SZ_128K)) {
 		test_err("extent region not marked as free");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -776,7 +776,7 @@ test_steal_space_from_bitmap_to_extent(struct btrfs_block_group *cache,
 	 */
 	if (!test_check_exists(cache, SZ_128M - 768 * SZ_1K, SZ_1M)) {
 		test_err("expected region not marked as free");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (cache->free_space_ctl->free_space != (SZ_1M + 2 * sectorsize)) {
diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c
index b359d4b17..1360ae1ca 100644
--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@ -265,7 +265,7 @@ static noinline int join_transaction(struct btrfs_fs_info *fs_info,
 	 * and commit it. If there is no transaction, just return ENOENT.
 	 */
 	if (type == TRANS_ATTACH)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * JOIN_NOLOCK only happens during the transaction commit, so
diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c
index cd5348f35..1dc8e7ea1 100644
--- a/fs/btrfs/tree-log.c
+++ b/fs/btrfs/tree-log.c
@@ -1852,7 +1852,7 @@ static noinline int insert_one_name(struct btrfs_trans_handle *trans,
 
 	inode = read_one_inode(root, location->objectid);
 	if (!inode)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dir = read_one_inode(root, dirid);
 	if (!dir) {
@@ -4633,7 +4633,7 @@ static int btrfs_log_holes(struct btrfs_trans_handle *trans,
 			if (ret < 0)
 				return ret;
 			if (WARN_ON(ret > 0))
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			leaf = path->nodes[0];
 		}
 
@@ -5811,7 +5811,7 @@ static int log_new_ancestors(struct btrfs_trans_handle *trans,
 			if (ret < 0)
 				return ret;
 			else if (ret > 0)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			leaf = path->nodes[0];
 			slot = path->slots[0];
 		}
@@ -5819,7 +5819,7 @@ static int log_new_ancestors(struct btrfs_trans_handle *trans,
 		btrfs_item_key_to_cpu(leaf, &found_key, slot);
 		if (found_key.objectid != search_key.objectid ||
 		    found_key.type != BTRFS_INODE_REF_KEY)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return 0;
 }
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index f403fb1e6..90a31e6fb 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -3028,7 +3028,7 @@ static int btrfs_relocate_chunk(struct btrfs_fs_info *fs_info, u64 chunk_offset)
 
 	block_group = btrfs_lookup_block_group(fs_info, chunk_offset);
 	if (!block_group)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	btrfs_discard_cancel_work(&fs_info->discard_ctl, block_group);
 	btrfs_put_block_group(block_group);
 
@@ -6634,7 +6634,7 @@ static int read_one_chunk(struct btrfs_key *key, struct extent_buffer *leaf,
 		    !btrfs_test_opt(fs_info, DEGRADED)) {
 			free_extent_map(em);
 			btrfs_report_missing_device(fs_info, devid, uuid, true);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (!map->stripes[i].dev) {
 			map->stripes[i].dev =
@@ -6774,7 +6774,7 @@ static int read_one_dev(struct extent_buffer *leaf,
 		if (!btrfs_test_opt(fs_info, DEGRADED)) {
 			btrfs_report_missing_device(fs_info, devid,
 							dev_uuid, true);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		device = add_missing_dev(fs_devices, devid, dev_uuid);
@@ -6790,7 +6790,7 @@ static int read_one_dev(struct extent_buffer *leaf,
 			if (!btrfs_test_opt(fs_info, DEGRADED)) {
 				btrfs_report_missing_device(fs_info,
 						devid, dev_uuid, true);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			btrfs_report_missing_device(fs_info, devid,
 							dev_uuid, false);
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index 160644dda..ff2505c40 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -690,7 +690,7 @@ int ceph_atomic_open(struct inode *dir, struct dentry *dentry,
 			goto out_ctx;
 	} else if (!d_in_lookup(dentry)) {
 		/* If it's not being looked up, it's negative */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 retry:
 	/* do the open */
diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c
index a50497142..6f0345571 100644
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@ -689,7 +689,7 @@ static int __verify_registered_session(struct ceph_mds_client *mdsc,
 {
 	if (s->s_mds >= mdsc->max_sessions ||
 	    mdsc->sessions[s->s_mds] != s)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return 0;
 }
 
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index bf41ee048..e292af5ad 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -4705,7 +4705,7 @@ int CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,
 	cifs_dbg(FYI, "In FindNext\n");
 
 	if (psrch_inf->endOfSearch)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,
 		(void **) &pSMBr);
diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c
index 398c1eef7..3e798bca3 100644
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -491,7 +491,7 @@ cifs_atomic_open(struct inode *inode, struct dentry *direntry,
 		 * the dentry and it is fine. No need to perform another lookup.
 		 */
 		if (!d_in_lookup(direntry))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		res = cifs_lookup(inode, direntry, 0);
 		if (IS_ERR(res))
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index be46fab4c..742f4f46c 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -2090,7 +2090,7 @@ cifs_get_writable_path(struct cifs_tcon *tcon, const char *name,
 	}
 
 	spin_unlock(&tcon->open_file_lock);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int
@@ -2126,7 +2126,7 @@ cifs_get_readable_path(struct cifs_tcon *tcon, const char *name,
 	}
 
 	spin_unlock(&tcon->open_file_lock);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index ce95801e9..a353885e4 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -2271,7 +2271,7 @@ int cifs_revalidate_dentry_attr(struct dentry *dentry)
 	int count = 0;
 
 	if (inode == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!cifs_inode_needs_reval(inode))
 		return rc;
diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c
index 6df0922e7..f793e1773 100644
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@ -704,7 +704,7 @@ find_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,
 		return -ENOSYS;
 
 	if ((cfile == NULL) || (current_entry == NULL) || (num_to_ret == NULL))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*current_entry = NULL;
 	first_entry_in_buffer = cfile->srch_inf.index_of_last_entry -
@@ -766,7 +766,7 @@ find_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,
 		if (cfile->srch_inf.last_entry)
 			cifs_save_resume_key(cfile->srch_inf.last_entry, cfile);
 		if (rc)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (index_to_find < cfile->srch_inf.index_of_last_entry) {
 		/* we found the buffer that contains the entry */
diff --git a/fs/cifs/smb2misc.c b/fs/cifs/smb2misc.c
index 157992864..51be15738 100644
--- a/fs/cifs/smb2misc.c
+++ b/fs/cifs/smb2misc.c
@@ -810,7 +810,7 @@ smb2_handle_cancelled_mid(char *buffer, struct TCP_Server_Info *server)
 	tcon = smb2_find_smb_tcon(server, sync_hdr->SessionId,
 				  sync_hdr->TreeId);
 	if (!tcon)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rc = __smb2_handle_cancelled_cmd(tcon,
 					 le16_to_cpu(sync_hdr->Command),
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index 32f90dc82..9dd782a3f 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -178,7 +178,7 @@ smb2_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,
 		} else {
 			if (server->tcpStatus == CifsExiting) {
 				spin_unlock(&server->req_lock);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 
 			scredits = server->credits;
diff --git a/fs/cifs/smb2transport.c b/fs/cifs/smb2transport.c
index c0348e3b1..62f4806d2 100644
--- a/fs/cifs/smb2transport.c
+++ b/fs/cifs/smb2transport.c
@@ -726,7 +726,7 @@ smb2_get_mid_entry(struct cifs_ses *ses, struct TCP_Server_Info *server,
 		   struct smb2_sync_hdr *shdr, struct mid_q_entry **mid)
 {
 	if (server->tcpStatus == CifsExiting)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (server->tcpStatus == CifsNeedReconnect) {
 		cifs_dbg(FYI, "tcp session dead - return to caller to retry\n");
diff --git a/fs/cifs/smbencrypt.c b/fs/cifs/smbencrypt.c
index 39a938443..a30952889 100644
--- a/fs/cifs/smbencrypt.c
+++ b/fs/cifs/smbencrypt.c
@@ -65,7 +65,7 @@ smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)
 
 	if (fips_enabled) {
 		cifs_dbg(VFS, "FIPS compliance enabled: DES not permitted\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	des_expand_key(&ctx, key2, DES_KEY_SIZE);
diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index 84433d065..13787b782 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -574,7 +574,7 @@ wait_for_free_credits(struct TCP_Server_Info *server, const int num_credits,
 		} else {
 			if (server->tcpStatus == CifsExiting) {
 				spin_unlock(&server->req_lock);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 
 			/*
@@ -682,7 +682,7 @@ static int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,
 			struct mid_q_entry **ppmidQ)
 {
 	if (ses->server->tcpStatus == CifsExiting) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (ses->server->tcpStatus == CifsNeedReconnect) {
@@ -1040,7 +1040,7 @@ compound_send_recv(const unsigned int xid, struct cifs_ses *ses,
 	}
 
 	if (server->tcpStatus == CifsExiting)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Wait for all the requests to become available.
@@ -1304,7 +1304,7 @@ SendReceive(const unsigned int xid, struct cifs_ses *ses,
 	}
 
 	if (server->tcpStatus == CifsExiting)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Ensure that we do not send more than 50 overlapping requests
 	   to the same server. We may make this configurable later or
@@ -1445,7 +1445,7 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,
 	}
 
 	if (server->tcpStatus == CifsExiting)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Ensure that we do not send more than 50 overlapping requests
 	   to the same server. We may make this configurable later or
diff --git a/fs/configfs/symlink.c b/fs/configfs/symlink.c
index cb6146747..ad5b1f106 100644
--- a/fs/configfs/symlink.c
+++ b/fs/configfs/symlink.c
@@ -85,7 +85,7 @@ static int create_link(struct config_item *parent_item,
 	int ret;
 
 	if (!configfs_dirent_is_ready(target_sd))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	body = kzalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!body)
@@ -97,7 +97,7 @@ static int create_link(struct config_item *parent_item,
 		spin_unlock(&configfs_dirent_lock);
 		configfs_put(target_sd);
 		kfree(body);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	target_sd->s_links++;
 	spin_unlock(&configfs_dirent_lock);
@@ -154,7 +154,7 @@ int configfs_symlink(struct inode *dir, struct dentry *dentry, const char *symna
 	 * being attached
 	 */
 	if (!configfs_dirent_is_ready(sd))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	parent_item = configfs_get_config_item(dentry->d_parent);
 	type = parent_item->ci_type;
diff --git a/fs/crypto/fname.c b/fs/crypto/fname.c
index 83ca5f1e7..3fece029b 100644
--- a/fs/crypto/fname.c
+++ b/fs/crypto/fname.c
@@ -468,7 +468,7 @@ int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,
 	 */
 
 	if (iname->len > BASE64_CHARS(FSCRYPT_NOKEY_NAME_MAX))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	fname->crypto_buf.name = kmalloc(FSCRYPT_NOKEY_NAME_MAX, GFP_KERNEL);
 	if (fname->crypto_buf.name == NULL)
diff --git a/fs/dlm/lowcomms.c b/fs/dlm/lowcomms.c
index 3543a8fec..f65bae9ba 100644
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@ -320,7 +320,7 @@ static int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,
 		return -EEXIST;
 
 	if (!na->addr_count)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (sas_out)
 		memcpy(sas_out, &sas, sizeof(struct sockaddr_storage));
diff --git a/fs/dlm/user.c b/fs/dlm/user.c
index e5cefa90b..dbce374e6 100644
--- a/fs/dlm/user.c
+++ b/fs/dlm/user.c
@@ -243,7 +243,7 @@ static int device_user_lock(struct dlm_user_proc *proc,
 
 	ls = dlm_find_lockspace_local(proc->lockspace);
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!params->castaddr || !params->lksb) {
 		error = -EINVAL;
@@ -296,7 +296,7 @@ static int device_user_unlock(struct dlm_user_proc *proc,
 
 	ls = dlm_find_lockspace_local(proc->lockspace);
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);
 	if (!ua)
@@ -324,7 +324,7 @@ static int device_user_deadlock(struct dlm_user_proc *proc,
 
 	ls = dlm_find_lockspace_local(proc->lockspace);
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = dlm_user_deadlock(ls, params->flags, params->lkid);
 
@@ -385,7 +385,7 @@ static int device_user_purge(struct dlm_user_proc *proc,
 
 	ls = dlm_find_lockspace_local(proc->lockspace);
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = dlm_user_purge(ls, proc, params->nodeid, params->pid);
 
@@ -410,7 +410,7 @@ static int device_create_lockspace(struct dlm_lspace_params *params)
 
 	ls = dlm_find_lockspace_local(lockspace);
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = dlm_device_register(ls, params->name);
 	dlm_put_lockspace(ls);
@@ -434,7 +434,7 @@ static int device_remove_lockspace(struct dlm_lspace_params *params)
 
 	ls = dlm_find_lockspace_device(params->minor);
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (params->flags & DLM_USER_LSFLG_FORCEFREE)
 		force = 2;
@@ -634,7 +634,7 @@ static int device_open(struct inode *inode, struct file *file)
 
 	ls = dlm_find_lockspace_device(iminor(inode));
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	proc = kzalloc(sizeof(struct dlm_user_proc), GFP_NOFS);
 	if (!proc) {
@@ -661,7 +661,7 @@ static int device_close(struct inode *inode, struct file *file)
 
 	ls = dlm_find_lockspace_local(proc->lockspace);
 	if (!ls)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	set_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags);
 
diff --git a/fs/erofs/namei.c b/fs/erofs/namei.c
index 52f201e03..6665fa0b1 100644
--- a/fs/erofs/namei.c
+++ b/fs/erofs/namei.c
@@ -176,7 +176,7 @@ int erofs_namei(struct inode *dir,
 	struct erofs_qstr qn;
 
 	if (!dir->i_size)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	qn.name = name->name;
 	qn.end = name->name + name->len;
diff --git a/fs/exfat/dir.c b/fs/exfat/dir.c
index 119abf0d8..0c54cc529 100644
--- a/fs/exfat/dir.c
+++ b/fs/exfat/dir.c
@@ -1096,7 +1096,7 @@ int exfat_find_dir_entry(struct super_block *sb, struct exfat_inode_info *ei,
 	/* initialized hint_stat */
 	hint_stat->clu = p_dir->dir;
 	hint_stat->eidx = 0;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 
 found:
 	/* next dentry we'll find is out of this cluster */
diff --git a/fs/exfat/namei.c b/fs/exfat/namei.c
index 2b9e21094..70e29e52f 100644
--- a/fs/exfat/namei.c
+++ b/fs/exfat/namei.c
@@ -422,7 +422,7 @@ static int __exfat_resolve_path(struct inode *inode, const unsigned char *path,
 	/* strip all trailing periods */
 	namelen = exfat_striptail_len(strlen(path), path);
 	if (!namelen)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (strlen(path) > (MAX_NAME_LENGTH * MAX_CHARSET_SIZE))
 		return -ENAMETOOLONG;
@@ -605,7 +605,7 @@ static int exfat_find(struct inode *dir, struct qstr *qname,
 	struct exfat_inode_info *ei = EXFAT_I(dir);
 
 	if (qname->len == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* check the validity of directory name in the given pathname */
 	ret = exfat_resolve_path_for_lookup(dir, qname->name, &cdir, &uni_name);
@@ -1242,7 +1242,7 @@ static int __exfat_rename(struct inode *old_parent_inode,
 
 	if (ei->dir.dir == DIR_DELETED) {
 		exfat_err(sb, "abnormal access to deleted source dentry");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	exfat_update_parent_info(ei, old_parent_inode);
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 56738b538..50b9b038f 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -2491,7 +2491,7 @@ int ext4_generic_delete_entry(handle_t *handle,
 		pde = de;
 		de = ext4_next_entry(de, blocksize);
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int ext4_delete_entry(handle_t *handle,
diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c
index 3268f8dd5..c9650bc45 100644
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@ -1116,7 +1116,7 @@ static int __read_out_blkaddrs(struct inode *inode, block_t *blkaddr,
 		return ret;
 	} else if (ret == -ENOENT) {
 		if (dn.max_level == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		done = min((pgoff_t)ADDRS_PER_BLOCK(inode) -
 						dn.ofs_in_node, len);
 		blkaddr += done;
diff --git a/fs/f2fs/node.c b/fs/f2fs/node.c
index 03e24df1c..44f4f7683 100644
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@ -1296,7 +1296,7 @@ static int read_node_page(struct page *page, int op_flags)
 	if (unlikely(ni.blk_addr == NULL_ADDR) ||
 			is_sbi_flag_set(sbi, SBI_IS_SHUTDOWN)) {
 		ClearPageUptodate(page);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fio.new_blkaddr = fio.old_blkaddr = ni.blk_addr;
diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index b4ddf48fa..e65bf6265 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -875,7 +875,7 @@ static int fat_get_short_entry(struct inode *dir, loff_t *pos,
 		if (!IS_FREE((*de)->name) && !((*de)->attr & ATTR_VOLUME))
 			return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
@@ -897,7 +897,7 @@ int fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,
 		if (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))
 			return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(fat_get_dotdot_entry);
 
@@ -964,7 +964,7 @@ int fat_scan(struct inode *dir, const unsigned char *name,
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(fat_scan);
 
@@ -988,7 +988,7 @@ int fat_scan_logstart(struct inode *dir, int i_logstart,
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int __fat_remove_entries(struct inode *dir, loff_t pos, int nr_slots)
diff --git a/fs/fat/namei_msdos.c b/fs/fat/namei_msdos.c
index 9d062886f..a43938861 100644
--- a/fs/fat/namei_msdos.c
+++ b/fs/fat/namei_msdos.c
@@ -125,7 +125,7 @@ static int msdos_find(struct inode *dir, const unsigned char *name, int len,
 
 	err = msdos_format_name(name, len, msdos_name, &sbi->options);
 	if (err)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = fat_scan(dir, msdos_name, sinfo);
 	if (!err && sbi->options.dotsOK) {
diff --git a/fs/fat/namei_vfat.c b/fs/fat/namei_vfat.c
index 0cdd0fb9f..4d81049c2 100644
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -238,7 +238,7 @@ static int vfat_find_form(struct inode *dir, unsigned char *name)
 	struct fat_slot_info sinfo;
 	int err = fat_scan(dir, name, &sinfo);
 	if (err)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	brelse(sinfo.bh);
 	return 0;
 }
@@ -663,7 +663,7 @@ static int vfat_add_entry(struct inode *dir, const struct qstr *qname,
 
 	len = vfat_striptail_len(qname);
 	if (len == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	slots = kmalloc_array(MSDOS_SLOTS, sizeof(*slots), GFP_NOFS);
 	if (slots == NULL)
@@ -694,7 +694,7 @@ static int vfat_find(struct inode *dir, const struct qstr *qname,
 {
 	unsigned int len = vfat_striptail_len(qname);
 	if (len == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return fat_search_long(dir, qname->name, len, sinfo);
 }
 
diff --git a/fs/file.c b/fs/file.c
index abb8b7081..46cfcafd5 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -674,7 +674,7 @@ int __close_fd_get_file(unsigned int fd, struct file **res)
 out_unlock:
 	spin_unlock(&files->file_lock);
 	*res = NULL;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void do_close_on_exec(struct files_struct *files)
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index a605c3ddd..75ec08a25 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -927,7 +927,7 @@ int cgroup_writeback_by_id(u64 bdi_id, int memcg_id, unsigned long nr,
 	/* lookup bdi and memcg */
 	bdi = bdi_get_by_id(bdi_id);
 	if (!bdi)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rcu_read_lock();
 	memcg_css = css_from_id(memcg_id, &memory_cgrp_subsys);
diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index 26f028bc7..d4d72a12a 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -1012,7 +1012,7 @@ int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
 
 	parent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);
 	if (!parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	inode_lock(parent);
 	if (!S_ISDIR(parent->i_mode))
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index bba747520..5341d3a4f 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -331,7 +331,7 @@ int fuse_reverse_inval_inode(struct super_block *sb, u64 nodeid,
 
 	inode = ilookup5(sb, nodeid, fuse_inode_eq, &nodeid);
 	if (!inode)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	fi = get_fuse_inode(inode);
 	spin_lock(&fi->lock);
diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index c0f2875c9..2b9cd5ac3 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -616,7 +616,7 @@ static int dirent_check_reclen(struct gfs2_inode *dip,
 	if (ptr < end_p)
 		return rec_len;
 	if (ptr == end_p)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 broken:
 	gfs2_consist_inode(dip);
 	return -EIO;
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index 8545024a1..331ec6be7 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -1007,7 +1007,7 @@ int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,
 		return 0;
 	}
 	if (!create)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (glops->go_flags & GLOF_ASPACE)
 		cachep = gfs2_glock_aspace_cachep;
diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c
index 6774865f5..8a19f3bd7 100644
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@ -356,7 +356,7 @@ static int create_ok(struct gfs2_inode *dip, const struct qstr *name,
 
 	/*  Don't create entries in an unlinked directory  */
 	if (!dip->i_inode.i_nlink)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (dip->i_entries == (u32)-1)
 		return -EFBIG;
@@ -1281,7 +1281,7 @@ static int gfs2_atomic_open(struct inode *dir, struct dentry *dentry,
 
 skip_lookup:
 	if (!(flags & O_CREAT))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return gfs2_create_inode(dir, dentry, file, S_IFREG | mode, 0, NULL, 0, excl);
 }
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index 6d18d2c91..be052220d 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -918,7 +918,7 @@ static int gfs2_lm_mount(struct gfs2_sbd *sdp, int silent)
 #endif
 	} else {
 		pr_info("can't find protocol %s\n", proto);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	fs_info(sdp, "Trying to join cluster \"%s\", \"%s\"\n", proto, table);
diff --git a/fs/hfs/bfind.c b/fs/hfs/bfind.c
index 4af318fbd..c32e6481f 100644
--- a/fs/hfs/bfind.c
+++ b/fs/hfs/bfind.c
@@ -106,7 +106,7 @@ int hfs_brec_find(struct hfs_find_data *fd)
 	fd->bnode = NULL;
 	nidx = tree->root;
 	if (!nidx)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	height = tree->depth;
 	res = 0;
 	parent = 0;
diff --git a/fs/hfs/brec.c b/fs/hfs/brec.c
index 896396554..c126f0ff3 100644
--- a/fs/hfs/brec.c
+++ b/fs/hfs/brec.c
@@ -369,7 +369,7 @@ static int hfs_brec_update_parent(struct hfs_find_data *fd)
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd);
 	if (fd->record < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	hfs_bnode_dump(parent);
 	rec = fd->record;
 
diff --git a/fs/hfs/extent.c b/fs/hfs/extent.c
index 263d5028d..01dd1ecd0 100644
--- a/fs/hfs/extent.c
+++ b/fs/hfs/extent.c
@@ -159,7 +159,7 @@ static inline int __hfs_ext_read_extent(struct hfs_find_data *fd, struct hfs_ext
 		return res;
 	if (fd->key->ext.FNum != fd->search_key->ext.FNum ||
 	    fd->key->ext.FkType != fd->search_key->ext.FkType)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (fd->entrylength != sizeof(hfs_extent_rec))
 		return -EIO;
 	hfs_bnode_read(fd->bnode, extent, fd->entryoffset, sizeof(hfs_extent_rec));
diff --git a/fs/hfsplus/attributes.c b/fs/hfsplus/attributes.c
index eeebe80c6..d77bf8246 100644
--- a/fs/hfsplus/attributes.c
+++ b/fs/hfsplus/attributes.c
@@ -274,7 +274,7 @@ static int __hfsplus_delete_attr(struct inode *inode, u32 cnid,
 			offsetof(struct hfsplus_attr_key, cnid),
 			sizeof(__be32));
 	if (cnid != be32_to_cpu(found_cnid))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hfs_bnode_read(fd->bnode, &record_type,
 			fd->entryoffset, sizeof(record_type));
@@ -289,7 +289,7 @@ static int __hfsplus_delete_attr(struct inode *inode, u32 cnid,
 		return -EOPNOTSUPP;
 	default:
 		pr_err("invalid extended attribute record\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Avoid btree corruption */
diff --git a/fs/hfsplus/bfind.c b/fs/hfsplus/bfind.c
index ca2ba8c9f..52f13e42e 100644
--- a/fs/hfsplus/bfind.c
+++ b/fs/hfsplus/bfind.c
@@ -175,7 +175,7 @@ int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)
 	fd->bnode = NULL;
 	nidx = tree->root;
 	if (!nidx)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	height = tree->depth;
 	res = 0;
 	parent = 0;
diff --git a/fs/hfsplus/bitmap.c b/fs/hfsplus/bitmap.c
index cebce0cfe..aada01583 100644
--- a/fs/hfsplus/bitmap.c
+++ b/fs/hfsplus/bitmap.c
@@ -177,7 +177,7 @@ int hfsplus_block_free(struct super_block *sb, u32 offset, u32 count)
 	hfs_dbg(BITMAP, "block_free: %u,%u\n", offset, count);
 	/* are all of the bits in range? */
 	if ((offset + count) > sbi->total_blocks)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&sbi->alloc_mutex);
 	mapping = sbi->alloc_file->i_mapping;
diff --git a/fs/hfsplus/brec.c b/fs/hfsplus/brec.c
index 1918544a7..786a73da2 100644
--- a/fs/hfsplus/brec.c
+++ b/fs/hfsplus/brec.c
@@ -373,7 +373,7 @@ static int hfs_brec_update_parent(struct hfs_find_data *fd)
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd, hfs_find_rec_by_key);
 	if (fd->record < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	hfs_bnode_dump(parent);
 	rec = fd->record;
 
diff --git a/fs/hfsplus/extents.c b/fs/hfsplus/extents.c
index a930ddd15..80ab6c3bd 100644
--- a/fs/hfsplus/extents.c
+++ b/fs/hfsplus/extents.c
@@ -166,7 +166,7 @@ static inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,
 		return res;
 	if (fd->key->ext.cnid != fd->search_key->ext.cnid ||
 	    fd->key->ext.fork_type != fd->search_key->ext.fork_type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (fd->entrylength != sizeof(hfsplus_extent_rec))
 		return -EIO;
 	hfs_bnode_read(fd->bnode, extent, fd->entryoffset,
diff --git a/fs/hfsplus/part_tbl.c b/fs/hfsplus/part_tbl.c
index 63164ebc5..bf1e4e55d 100644
--- a/fs/hfsplus/part_tbl.c
+++ b/fs/hfsplus/part_tbl.c
@@ -85,7 +85,7 @@ static int hfs_parse_old_pmap(struct super_block *sb, struct old_pmap *pm,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int hfs_parse_new_pmap(struct super_block *sb, void *buf,
@@ -106,7 +106,7 @@ static int hfs_parse_new_pmap(struct super_block *sb, void *buf,
 		}
 
 		if (++i >= size)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		pm = (struct new_pmap *)((u8 *)pm + HFSPLUS_SECTOR_SIZE);
 		if ((u8 *)pm - (u8 *)buf >= buf_size) {
@@ -119,7 +119,7 @@ static int hfs_parse_new_pmap(struct super_block *sb, void *buf,
 		}
 	} while (pm->pmSig == cpu_to_be16(HFS_NEW_PMAP_MAGIC));
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/fs/hpfs/dentry.c b/fs/hpfs/dentry.c
index 89a36fdc6..44614129b 100644
--- a/fs/hpfs/dentry.c
+++ b/fs/hpfs/dentry.c
@@ -24,7 +24,7 @@ static int hpfs_hash_dentry(const struct dentry *dentry, struct qstr *qstr)
 	hpfs_adjust_length(qstr->name, &l);
 	/*if (hpfs_chk_name(qstr->name,&l))*/
 		/*return -ENAMETOOLONG;*/
-		/*return -ENOENT;*/
+		/*ENOENT_DUMPER(stackdump_tuneable);*/
 	x:
 
 	hash = init_name_hash(dentry);
diff --git a/fs/hpfs/ea.c b/fs/hpfs/ea.c
index 102ba18e5..12db67763 100644
--- a/fs/hpfs/ea.c
+++ b/fs/hpfs/ea.c
@@ -116,7 +116,7 @@ int hpfs_read_ea(struct super_block *s, struct fnode *fnode, char *key,
 		}
 		pos += ea->namelen + ea_valuelen(ea) + 5;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 indirect:
 	if (ea_len(ea) >= size)
 		return -EINVAL;
diff --git a/fs/io_uring.c b/fs/io_uring.c
index 32b0064f8..61f5a4b21 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -4577,7 +4577,7 @@ static int io_poll_cancel(struct io_ring_ctx *ctx, __u64 sqe_addr)
 		return -EALREADY;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int io_poll_remove_prep(struct io_kiocb *req,
diff --git a/fs/iomap/seek.c b/fs/iomap/seek.c
index 89f61d93c..2114e149e 100644
--- a/fs/iomap/seek.c
+++ b/fs/iomap/seek.c
@@ -80,7 +80,7 @@ page_cache_seek_hole_data(struct inode *inode, loff_t offset, loff_t length,
 	struct pagevec pvec;
 
 	if (length <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pagevec_init(&pvec);
 
diff --git a/fs/jffs2/readinode.c b/fs/jffs2/readinode.c
index bccfc40b3..e81d5cfe3 100644
--- a/fs/jffs2/readinode.c
+++ b/fs/jffs2/readinode.c
@@ -1367,7 +1367,7 @@ int jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
 	}
 	if (!f->inocache) {
 		JFFS2_ERROR("requested to read a nonexistent ino %u\n", ino);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return jffs2_do_read_inode_internal(c, f, latest_node);
diff --git a/fs/jfs/jfs_xtree.c b/fs/jfs/jfs_xtree.c
index 16ad920f6..b849e91da 100644
--- a/fs/jfs/jfs_xtree.c
+++ b/fs/jfs/jfs_xtree.c
@@ -2345,7 +2345,7 @@ int xtDelete(tid_t tid, struct inode *ip, s64 xoff, s32 xlen, int flag)
 	if (cmp) {
 		/* unpin the leaf page */
 		XT_PUTPAGE(mp);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c
index 9aec80b9d..24b912496 100644
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@ -1506,7 +1506,7 @@ int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 	if (!parent) {
 		WARN(1, KERN_WARNING "kernfs: can not remove '%s', no directory\n",
 			name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mutex_lock(&kernfs_mutex);
@@ -1520,7 +1520,7 @@ int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 	if (kn)
 		return 0;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/fs/namei.c b/fs/namei.c
index 72d4219c9..7af20e690 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1266,7 +1266,7 @@ static inline int traverse_mounts(struct path *path, bool *jumped,
 	if (likely(!(flags & DCACHE_MANAGED_DENTRY))) {
 		*jumped = false;
 		if (unlikely(d_flags_negative(flags)))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		return 0;
 	}
 	return __traverse_mounts(path, flags, jumped, count, lookup_flags);
@@ -1369,7 +1369,7 @@ static inline int handle_mounts(struct nameidata *nd, struct dentry *dentry,
 	if (nd->flags & LOOKUP_RCU) {
 		unsigned int seq = *seqp;
 		if (unlikely(!*inode))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (likely(__follow_mount_rcu(nd, path, inode, seqp)))
 			return 0;
 		if (unlazy_child(nd, dentry, seq))
@@ -2625,13 +2625,13 @@ int path_pts(struct path *path)
 
 	if (unlikely(!path_connected(path->mnt, parent))) {
 		dput(parent);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	dput(path->dentry);
 	path->dentry = parent;
 	child = d_hash_and_lookup(parent, &this);
 	if (!child)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	path->dentry = child;
 	dput(parent);
@@ -2686,7 +2686,7 @@ static int may_delete(struct inode *dir, struct dentry *victim, bool isdir)
 	int error;
 
 	if (d_is_negative(victim))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	BUG_ON(!inode);
 
 	BUG_ON(victim->d_parent->d_inode != dir);
@@ -2714,7 +2714,7 @@ static int may_delete(struct inode *dir, struct dentry *victim, bool isdir)
 	} else if (d_is_dir(victim))
 		return -EISDIR;
 	if (IS_DEADDIR(dir))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
 		return -EBUSY;
 	return 0;
@@ -2736,7 +2736,7 @@ static inline int may_create(struct inode *dir, struct dentry *child)
 	if (child->d_inode)
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	s_user_ns = dir->i_sb->s_user_ns;
 	if (!kuid_has_mapping(s_user_ns, current_fsuid()) ||
 	    !kgid_has_mapping(s_user_ns, current_fsgid()))
@@ -2843,7 +2843,7 @@ static int may_open(const struct path *path, int acc_mode, int flag)
 	int error;
 
 	if (!inode)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (inode->i_mode & S_IFMT) {
 	case S_IFLNK:
@@ -4025,7 +4025,7 @@ int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_de
 	int error;
 
 	if (!inode)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = may_create(dir, new_dentry);
 	if (error)
@@ -4106,7 +4106,7 @@ int do_linkat(int olddfd, const char __user *oldname, int newdfd,
 	 */
 	if (flags & AT_EMPTY_PATH) {
 		if (!capable(CAP_DAC_READ_SEARCH))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		how = LOOKUP_EMPTY;
 	}
 
diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c
index 816e1427f..7e036c31b 100644
--- a/fs/nfs/delegation.c
+++ b/fs/nfs/delegation.c
@@ -1003,7 +1003,7 @@ int nfs_async_inode_return_delegation(struct inode *inode,
 	return 0;
 out_enoent:
 	rcu_read_unlock();
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct inode *
diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c
index 5a331da5f..448853e09 100644
--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -1690,7 +1690,7 @@ int nfs_atomic_open(struct inode *dir, struct dentry *dentry,
 			 * revalidated and is fine, no need to perform lookup
 			 * again
 			 */
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		lookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY;
 		goto no_open;
@@ -2500,7 +2500,7 @@ static int nfs_access_get_cached(struct inode *inode, const struct cred *cred, s
 out_zap:
 	spin_unlock(&inode->i_lock);
 	nfs_access_zap_cache(inode);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int nfs_access_get_cached_rcu(struct inode *inode, const struct cred *cred, struct nfs_access_entry *res)
diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c
index de03e440b..e41c4ab4f 100644
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@ -2435,7 +2435,7 @@ ff_layout_prepare_layoutstats(struct nfs42_layoutstat_args *args)
 	if (!args->num_dev) {
 		kfree(args->devinfo);
 		args->devinfo = NULL;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
diff --git a/fs/nfs/nfs4namespace.c b/fs/nfs/nfs4namespace.c
index 873342308..20bfb8cc0 100644
--- a/fs/nfs/nfs4namespace.c
+++ b/fs/nfs/nfs4namespace.c
@@ -158,7 +158,7 @@ static int nfs4_validate_fspath(struct dentry *dentry,
 	if (n != 0) {
 		dprintk("%s: path %s does not begin with fsroot %s\n",
 			__func__, path, ctx->nfs_server.export_path);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -366,7 +366,7 @@ static int nfs_follow_referral(struct fs_context *fc,
 	int loc, error;
 
 	if (locations == NULL || locations->nlocations <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dprintk("%s: referral at %pd2\n", __func__, ctx->clone_data.dentry);
 
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 2e2dac29a..2e1ec3ca3 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -2640,7 +2640,7 @@ static int _nfs4_proc_open(struct nfs4_opendata *data,
 	if (status != 0) {
 		if (status == -NFS4ERR_BADNAME &&
 				!(o_arg->open_flags & O_CREAT))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		return status;
 	}
 
@@ -5844,7 +5844,7 @@ static int _nfs4_get_security_label(struct inode *inode, void *buf,
 	if (ret)
 		return ret;
 	if (!(fattr.valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (buflen < label.len)
 		return -ERANGE;
 	return 0;
diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
index a8dc25ce4..800949f35 100644
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -2025,7 +2025,7 @@ static int nfs4_establish_lease(struct nfs_client *clp)
 		return status;
 	cred = nfs4_get_clid_cred(clp);
 	if (cred == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	status = ops->establish_clid(clp, cred);
 	put_cred(cred);
 	if (status != 0)
diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
index dd2e14f58..be15f6657 100644
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@ -2454,7 +2454,7 @@ pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void
diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index 9e40dfecf..b06eead42 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -707,7 +707,7 @@ nfsd4_check_legacy_client(struct nfs4_client *clp)
 	}
 
 out_enoent:
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {
@@ -1299,13 +1299,13 @@ nfsd4_cld_check(struct nfs4_client *clp)
 	if (cn->cn_has_legacy) {
 		status = nfs4_make_rec_clidname(dname, &clp->cl_name);
 		if (status)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		name.data = kmemdup(dname, HEXDIR_LEN, GFP_KERNEL);
 		if (!name.data) {
 			dprintk("%s: failed to allocate memory for name.data!\n",
 				__func__);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		name.len = HEXDIR_LEN;
 		crp = nfsd4_find_reclaim_client(name, nn);
@@ -1314,7 +1314,7 @@ nfsd4_cld_check(struct nfs4_client *clp)
 			goto found;
 
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 found:
 	crp->cr_clp = clp;
 	return 0;
@@ -1345,13 +1345,13 @@ nfsd4_cld_check_v2(struct nfs4_client *clp)
 	if (cn->cn_has_legacy) {
 		status = nfs4_make_rec_clidname(dname, &clp->cl_name);
 		if (status)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		name.data = kmemdup(dname, HEXDIR_LEN, GFP_KERNEL);
 		if (!name.data) {
 			dprintk("%s: failed to allocate memory for name.data\n",
 					__func__);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		name.len = HEXDIR_LEN;
 		crp = nfsd4_find_reclaim_client(name, nn);
@@ -1360,7 +1360,7 @@ nfsd4_cld_check_v2(struct nfs4_client *clp)
 			goto found;
 
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 found:
 	if (crp->cr_princhash.len) {
 		if (clp->cl_cred.cr_raw_principal)
@@ -1368,21 +1368,21 @@ nfsd4_cld_check_v2(struct nfs4_client *clp)
 		else if (clp->cl_cred.cr_principal)
 			principal = clp->cl_cred.cr_principal;
 		if (principal == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		cksum.len = crypto_shash_digestsize(tfm);
 		cksum.data = kmalloc(cksum.len, GFP_KERNEL);
 		if (cksum.data == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		status = crypto_shash_tfm_digest(tfm, principal,
 						 strlen(principal), cksum.data);
 		if (status) {
 			kfree(cksum.data);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (memcmp(crp->cr_princhash.data, cksum.data,
 				crp->cr_princhash.len)) {
 			kfree(cksum.data);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		kfree(cksum.data);
 	}
diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c
index 23e043eca..7b560e1be 100644
--- a/fs/nilfs2/btree.c
+++ b/fs/nilfs2/btree.c
@@ -545,7 +545,7 @@ static int nilfs_btree_do_lookup(const struct nilfs_bmap *btree,
 	node = nilfs_btree_get_root(btree);
 	level = nilfs_btree_node_get_level(node);
 	if (level < minlevel || nilfs_btree_node_get_nchildren(node) <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	found = nilfs_btree_node_lookup(node, key, &index);
 	ptr = nilfs_btree_node_get_ptr(node, index,
@@ -586,7 +586,7 @@ static int nilfs_btree_do_lookup(const struct nilfs_bmap *btree,
 		path[level].bp_index = index;
 	}
 	if (!found)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ptrp != NULL)
 		*ptrp = ptr;
@@ -605,7 +605,7 @@ static int nilfs_btree_do_lookup_last(const struct nilfs_bmap *btree,
 	node = nilfs_btree_get_root(btree);
 	index = nilfs_btree_node_get_nchildren(node) - 1;
 	if (index < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	level = nilfs_btree_node_get_level(node);
 	ptr = nilfs_btree_node_get_ptr(node, index,
 				       NILFS_BTREE_ROOT_NCHILDREN_MAX);
@@ -668,7 +668,7 @@ static int nilfs_btree_get_next_key(const struct nilfs_bmap *btree,
 		/* For non-leaf nodes, next index is stored at bp_index + 1. */
 		next_adj = 1;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int nilfs_btree_lookup(const struct nilfs_bmap *btree,
diff --git a/fs/nilfs2/cpfile.c b/fs/nilfs2/cpfile.c
index 8d41311b5..244dcb7b4 100644
--- a/fs/nilfs2/cpfile.c
+++ b/fs/nilfs2/cpfile.c
@@ -167,7 +167,7 @@ static int nilfs_cpfile_find_checkpoint_block(struct inode *cpfile,
 	int ret;
 
 	if (unlikely(start_cno > end_cno))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	start = nilfs_cpfile_get_blkoff(cpfile, start_cno);
 	end = nilfs_cpfile_get_blkoff(cpfile, end_cno);
@@ -434,7 +434,7 @@ static ssize_t nilfs_cpfile_do_get_cpinfo(struct inode *cpfile, __u64 *cnop,
 	int ncps, i;
 
 	if (cno == 0)
-		return -ENOENT; /* checkpoint number 0 is invalid */
+		ENOENT_DUMPER(stackdump_tuneable); /* checkpoint number 0 is invalid */
 	down_read(&NILFS_MDT(cpfile)->mi_sem);
 
 	for (n = 0; n < nci; cno += ncps) {
@@ -587,7 +587,7 @@ int nilfs_cpfile_delete_checkpoint(struct inode *cpfile, __u64 cno)
 	if (nci < 0)
 		return nci;
 	else if (nci == 0 || ci.ci_cno != cno)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	else if (nilfs_cpinfo_snapshot(&ci))
 		return -EBUSY;
 
@@ -626,7 +626,7 @@ static int nilfs_cpfile_set_snapshot(struct inode *cpfile, __u64 cno)
 	int ret;
 
 	if (cno == 0)
-		return -ENOENT; /* checkpoint number 0 is invalid */
+		ENOENT_DUMPER(stackdump_tuneable); /* checkpoint number 0 is invalid */
 	down_write(&NILFS_MDT(cpfile)->mi_sem);
 
 	ret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);
@@ -744,7 +744,7 @@ static int nilfs_cpfile_clear_snapshot(struct inode *cpfile, __u64 cno)
 	int ret;
 
 	if (cno == 0)
-		return -ENOENT; /* checkpoint number 0 is invalid */
+		ENOENT_DUMPER(stackdump_tuneable); /* checkpoint number 0 is invalid */
 	down_write(&NILFS_MDT(cpfile)->mi_sem);
 
 	ret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &cp_bh);
@@ -865,7 +865,7 @@ int nilfs_cpfile_is_snapshot(struct inode *cpfile, __u64 cno)
 	 * largest existing one.
 	 */
 	if (cno == 0 || cno >= nilfs_mdt_cno(cpfile))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	down_read(&NILFS_MDT(cpfile)->mi_sem);
 
 	ret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, 0, &bh);
diff --git a/fs/nilfs2/direct.c b/fs/nilfs2/direct.c
index 533e24ea3..75325efd9 100644
--- a/fs/nilfs2/direct.c
+++ b/fs/nilfs2/direct.c
@@ -38,10 +38,10 @@ static int nilfs_direct_lookup(const struct nilfs_bmap *direct,
 	__u64 ptr;
 
 	if (key > NILFS_DIRECT_KEY_MAX || level != 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ptr = nilfs_direct_get_ptr(direct, key);
 	if (ptr == NILFS_BMAP_INVALID_PTR)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*ptrp = ptr;
 	return 0;
@@ -57,10 +57,10 @@ static int nilfs_direct_lookup_contig(const struct nilfs_bmap *direct,
 	int ret, cnt;
 
 	if (key > NILFS_DIRECT_KEY_MAX)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ptr = nilfs_direct_get_ptr(direct, key);
 	if (ptr == NILFS_BMAP_INVALID_PTR)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (NILFS_BMAP_USE_VBN(direct)) {
 		dat = nilfs_bmap_get_dat(direct);
@@ -111,7 +111,7 @@ static int nilfs_direct_insert(struct nilfs_bmap *bmap, __u64 key, __u64 ptr)
 	int ret;
 
 	if (key > NILFS_DIRECT_KEY_MAX)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (nilfs_direct_get_ptr(bmap, key) != NILFS_BMAP_INVALID_PTR)
 		return -EEXIST;
 
@@ -147,7 +147,7 @@ static int nilfs_direct_delete(struct nilfs_bmap *bmap, __u64 key)
 
 	if (key > NILFS_DIRECT_KEY_MAX ||
 	    nilfs_direct_get_ptr(bmap, key) == NILFS_BMAP_INVALID_PTR)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dat = NILFS_BMAP_USE_VBN(bmap) ? nilfs_bmap_get_dat(bmap) : NULL;
 	req.bpr_ptr = nilfs_direct_get_ptr(bmap, key);
@@ -173,7 +173,7 @@ static int nilfs_direct_seek_key(const struct nilfs_bmap *direct, __u64 start,
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int nilfs_direct_last_key(const struct nilfs_bmap *direct, __u64 *keyp)
@@ -187,7 +187,7 @@ static int nilfs_direct_last_key(const struct nilfs_bmap *direct, __u64 *keyp)
 			lastkey = key;
 
 	if (lastkey == NILFS_DIRECT_KEY_MAX + 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*keyp = lastkey;
 
diff --git a/fs/nilfs2/mdt.c b/fs/nilfs2/mdt.c
index 700870a92..cc25d2c7d 100644
--- a/fs/nilfs2/mdt.c
+++ b/fs/nilfs2/mdt.c
@@ -289,7 +289,7 @@ int nilfs_mdt_find_block(struct inode *inode, unsigned long start,
 	int ret;
 
 	if (unlikely(start > end))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = nilfs_mdt_read_block(inode, start, true, out_bh);
 	if (!ret) {
@@ -364,7 +364,7 @@ int nilfs_mdt_forget_block(struct inode *inode, unsigned long block)
 
 	page = find_lock_page(inode->i_mapping, index);
 	if (!page)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	wait_on_page_writeback(page);
 
diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 63b5dffdc..34e8fac35 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -214,7 +214,7 @@ static int process_access_response(struct fsnotify_group *group,
 	}
 	spin_unlock(&group->notification_lock);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int copy_info_to_user(__kernel_fsid_t *fsid, struct fanotify_fh *fh,
@@ -682,7 +682,7 @@ static int fanotify_remove_mark(struct fsnotify_group *group,
 	fsn_mark = fsnotify_find_mark(connp, group);
 	if (!fsn_mark) {
 		mutex_unlock(&group->mark_mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	removed = fanotify_mark_remove_from_mask(fsn_mark, mask, flags,
diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index f88bbcc9e..78523f9d1 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -516,7 +516,7 @@ static int inotify_update_existing_watch(struct fsnotify_group *group,
 
 	fsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);
 	if (!fsn_mark)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	else if (create) {
 		ret = -EEXIST;
 		goto out;
diff --git a/fs/nsfs.c b/fs/nsfs.c
index 800c1d0eb..375961f75 100644
--- a/fs/nsfs.c
+++ b/fs/nsfs.c
@@ -114,7 +114,7 @@ int ns_get_path_cb(struct path *path, ns_get_path_helper_t *ns_get_cb,
 	do {
 		struct ns_common *ns = ns_get_cb(private_data);
 		if (!ns)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		ret = __ns_get_path(path, ns);
 	} while (ret == -EAGAIN);
 
diff --git a/fs/ntfs/attrib.c b/fs/ntfs/attrib.c
index d563abc3e..ff1a3cf2a 100644
--- a/fs/ntfs/attrib.c
+++ b/fs/ntfs/attrib.c
@@ -598,7 +598,7 @@ static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,
 		ctx->attr = a;
 		if (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||
 				a->type == AT_END))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (unlikely(!a->length))
 			break;
 		if (a->type != type)
@@ -610,7 +610,7 @@ static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,
 		if (!name) {
 			/* The search failed if the found attribute is named. */
 			if (a->name_length)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 		} else if (!ntfs_are_names_equal(name, name_len,
 			    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),
 			    a->name_length, ic, upcase, upcase_len)) {
@@ -626,7 +626,7 @@ static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,
 			 * matching attribute.
 			 */
 			if (rc == -1)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			/* If the strings are not equal, continue search. */
 			if (rc)
 				continue;
@@ -636,7 +636,7 @@ static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,
 					a->name_length, 1, CASE_SENSITIVE,
 					upcase, upcase_len);
 			if (rc == -1)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			if (rc)
 				continue;
 		}
@@ -667,9 +667,9 @@ static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,
 				if (val_len == avl)
 					return 0;
 				if (val_len < avl)
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 			} else if (rc < 0)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	ntfs_error(vol->sb, "Inode is corrupt.  Run chkdsk.");
@@ -1340,7 +1340,7 @@ int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,
 	/* Get the $AttrDef entry for the attribute @type. */
 	ad = ntfs_attr_find_in_attrdef(vol, type);
 	if (unlikely(!ad))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/* Do the bounds check. */
 	if (((sle64_to_cpu(ad->min_size) > 0) &&
 			size < sle64_to_cpu(ad->min_size)) ||
@@ -1368,7 +1368,7 @@ int ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)
 	/* Find the attribute definition record in $AttrDef. */
 	ad = ntfs_attr_find_in_attrdef(vol, type);
 	if (unlikely(!ad))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/* Check the flags and return the result. */
 	if (ad->flags & ATTR_DEF_RESIDENT)
 		return -EPERM;
diff --git a/fs/ntfs/mft.c b/fs/ntfs/mft.c
index fbb9f1bc6..113ecaf37 100644
--- a/fs/ntfs/mft.c
+++ b/fs/ntfs/mft.c
@@ -2108,7 +2108,7 @@ static int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)
 				(i_size & ~PAGE_MASK))) {
 			ntfs_error(vol->sb, "Tried to format non-existing mft "
 					"record 0x%llx.", (long long)mft_no);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	/* Read, map, and pin the page containing the mft record. */
diff --git a/fs/ntfs/runlist.c b/fs/ntfs/runlist.c
index 97932fb51..abfbfa5b7 100644
--- a/fs/ntfs/runlist.c
+++ b/fs/ntfs/runlist.c
@@ -1646,7 +1646,7 @@ int ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,
 	if (unlikely(!rl)) {
 		if (likely(!start && !length))
 			return 0;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	/* Find @start in the runlist. */
 	while (likely(rl->length && start >= rl[1].vcn))
@@ -1664,11 +1664,11 @@ int ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,
 		return -EINVAL;
 	/* This covers @start being out of bounds, too. */
 	if (!rl_end->length && end > rl_end->vcn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (!length)
 		return 0;
 	if (!rl->length)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	rl_real_end = rl_end;
 	/* Determine the runlist size. */
 	while (likely(rl_real_end->length))
diff --git a/fs/ocfs2/dir.c b/fs/ocfs2/dir.c
index 5761060d2..3ad5e4749 100644
--- a/fs/ocfs2/dir.c
+++ b/fs/ocfs2/dir.c
@@ -1076,7 +1076,7 @@ int ocfs2_find_entry(const char *name, int namelen,
 		bh = ocfs2_find_entry_el(name, namelen, dir, &res_dir);
 
 	if (bh == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	lookup->dl_leaf_bh = bh;
 	lookup->dl_entry = res_dir;
diff --git a/fs/ocfs2/dlm/dlmcommon.h b/fs/ocfs2/dlm/dlmcommon.h
index c8a444622..485678cd5 100644
--- a/fs/ocfs2/dlm/dlmcommon.h
+++ b/fs/ocfs2/dlm/dlmcommon.h
@@ -1110,7 +1110,7 @@ static inline int dlm_node_iter_next(struct dlm_node_iter *iter)
 	bit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);
 	if (bit >= O2NM_MAX_NODES) {
 		iter->curnode = O2NM_MAX_NODES;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	iter->curnode = bit;
 	return bit;
diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c
index f10574606..e81ef9112 100644
--- a/fs/ocfs2/dlm/dlmmaster.c
+++ b/fs/ocfs2/dlm/dlmmaster.c
@@ -1185,13 +1185,13 @@ static int dlm_bitmap_diff_iter_next(struct dlm_bitmap_diff_iter *iter,
 	int bit;
 
 	if (iter->curnode >= O2NM_MAX_NODES)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bit = find_next_bit(iter->diff_bm, O2NM_MAX_NODES,
 			    iter->curnode+1);
 	if (bit >= O2NM_MAX_NODES) {
 		iter->curnode = O2NM_MAX_NODES;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* if it was there in the original then this node died */
diff --git a/fs/ocfs2/extent_map.c b/fs/ocfs2/extent_map.c
index a94852af5..de8b479e1 100644
--- a/fs/ocfs2/extent_map.c
+++ b/fs/ocfs2/extent_map.c
@@ -91,7 +91,7 @@ static int ocfs2_extent_map_lookup(struct inode *inode, unsigned int cpos,
 	spin_unlock(&oi->ip_lock);
 
 	if (emi == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/fs/ocfs2/refcounttree.c b/fs/ocfs2/refcounttree.c
index cfb77f70c..3a123e335 100644
--- a/fs/ocfs2/refcounttree.c
+++ b/fs/ocfs2/refcounttree.c
@@ -4345,7 +4345,7 @@ static inline int ocfs2_may_create(struct inode *dir, struct dentry *child)
 	if (d_really_is_positive(child))
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return inode_permission(dir, MAY_WRITE | MAY_EXEC);
 }
 
@@ -4364,7 +4364,7 @@ static int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,
 	int error;
 
 	if (!inode)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = ocfs2_may_create(dir, new_dentry);
 	if (error)
diff --git a/fs/ocfs2/slot_map.c b/fs/ocfs2/slot_map.c
index 4da0e4b1e..93b92925e 100644
--- a/fs/ocfs2/slot_map.c
+++ b/fs/ocfs2/slot_map.c
@@ -295,7 +295,7 @@ int ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,
 	BUG_ON(slot_num >= osb->max_slots);
 
 	if (!si->si_slots[slot_num].sl_valid)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*node_num = si->si_slots[slot_num].sl_node_num;
 	return 0;
diff --git a/fs/ocfs2/stack_o2cb.c b/fs/ocfs2/stack_o2cb.c
index dbf8b5735..291cc5191 100644
--- a/fs/ocfs2/stack_o2cb.c
+++ b/fs/ocfs2/stack_o2cb.c
@@ -397,7 +397,7 @@ static int o2cb_cluster_this_node(struct ocfs2_cluster_connection *conn,
 
 	node_num = o2nm_this_node();
 	if (node_num == O2NM_INVALID_NODE_NUM)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (node_num >= O2NM_MAX_NODES)
 		return -EOVERFLOW;
diff --git a/fs/overlayfs/util.c b/fs/overlayfs/util.c
index 56c1f89f2..121d60ded 100644
--- a/fs/overlayfs/util.c
+++ b/fs/overlayfs/util.c
@@ -764,7 +764,7 @@ int ovl_nlink_start(struct dentry *dentry)
 	int err;
 
 	if (WARN_ON(!inode))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * With inodes index is enabled, we store the union overlay nlink
diff --git a/fs/proc/base.c b/fs/proc/base.c
index d86c0afc8..59e9ba680 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -737,7 +737,7 @@ static int proc_pid_permission(struct inode *inode, int mask)
 			 * may not stat() a file, it shouldn't be seen
 			 * in procfs at all.
 			 */
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		return -EPERM;
@@ -1708,7 +1708,7 @@ static int proc_exe_link(struct dentry *dentry, struct path *exe_path)
 
 	task = get_proc_task(d_inode(dentry));
 	if (!task)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	exe_file = get_task_exe_file(task);
 	put_task_struct(task);
 	if (exe_file) {
@@ -1717,7 +1717,7 @@ static int proc_exe_link(struct dentry *dentry, struct path *exe_path)
 		fput(exe_file);
 		return 0;
 	} else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const char *proc_pid_get_link(struct dentry *dentry,
@@ -1933,7 +1933,7 @@ int pid_getattr(const struct path *path, struct kstat *stat,
 			 * This doesn't prevent learning whether PID exists,
 			 * it only makes getattr() consistent with readdir().
 			 */
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		task_dump_owner(task, inode->i_mode, &stat->uid, &stat->gid);
 	}
@@ -2641,7 +2641,7 @@ static int proc_pident_readdir(struct file *file, struct dir_context *ctx,
 	const struct pid_entry *p;
 
 	if (!task)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!dir_emit_dots(file, ctx))
 		goto out;
@@ -3747,7 +3747,7 @@ static int proc_task_readdir(struct file *file, struct dir_context *ctx)
 	int tid;
 
 	if (proc_inode_is_dead(inode))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!dir_emit_dots(file, ctx))
 		return 0;
diff --git a/fs/proc/fd.c b/fs/proc/fd.c
index 81882a132..9a8aa98a3 100644
--- a/fs/proc/fd.c
+++ b/fs/proc/fd.c
@@ -26,7 +26,7 @@ static int seq_show(struct seq_file *m, void *v)
 
 	task = get_proc_task(m->private);
 	if (!task)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	files = get_files_struct(task);
 	put_task_struct(task);
@@ -233,7 +233,7 @@ static int proc_readfd_common(struct file *file, struct dir_context *ctx,
 	unsigned int fd;
 
 	if (!p)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!dir_emit_dots(file, ctx))
 		goto out;
diff --git a/fs/proc/generic.c b/fs/proc/generic.c
index 2f9fa1791..844001ae6 100644
--- a/fs/proc/generic.c
+++ b/fs/proc/generic.c
@@ -176,7 +176,7 @@ static int __xlate_proc_name(const char *name, struct proc_dir_entry **ret,
 		de = pde_subdir_find(de, cp, next - cp);
 		if (!de) {
 			WARN(1, "name '%s'\n", name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		cp = next + 1;
 	}
@@ -713,14 +713,14 @@ int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)
 	write_lock(&proc_subdir_lock);
 	if (__xlate_proc_name(name, &parent, &fn) != 0) {
 		write_unlock(&proc_subdir_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	len = strlen(fn);
 
 	root = pde_subdir_find(parent, fn, len);
 	if (!root) {
 		write_unlock(&proc_subdir_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (unlikely(pde_is_permanent(root))) {
 		write_unlock(&proc_subdir_lock);
diff --git a/fs/proc/inode.c b/fs/proc/inode.c
index 28d6105e9..db0a8f096 100644
--- a/fs/proc/inode.c
+++ b/fs/proc/inode.c
@@ -493,7 +493,7 @@ static int proc_reg_open(struct inode *inode, struct file *file)
 	}
 
 	if (fs_info->pidonly == PROC_PIDONLY_ON)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * Ensure that
@@ -507,7 +507,7 @@ static int proc_reg_open(struct inode *inode, struct file *file)
 	 * Save every "struct file" with custom ->release hook.
 	 */
 	if (!use_pde(pde))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	release = pde->proc_ops->proc_release;
 	if (release) {
diff --git a/fs/proc/namespaces.c b/fs/proc/namespaces.c
index 8e159fc78..812953abb 100644
--- a/fs/proc/namespaces.c
+++ b/fs/proc/namespaces.c
@@ -121,7 +121,7 @@ static int proc_ns_dir_readdir(struct file *file, struct dir_context *ctx)
 	const struct proc_ns_operations **entry, **last;
 
 	if (!task)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!dir_emit_dots(file, ctx))
 		goto out;
diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c
index 1509775da..ee540c45e 100644
--- a/fs/reiserfs/inode.c
+++ b/fs/reiserfs/inode.c
@@ -316,7 +316,7 @@ static int _get_block_create_0(struct inode *inode, sector_t block,
 		 */
 		if ((args & GET_BLOCK_NO_HOLE)
 		    && !PageUptodate(bh_result->b_page)) {
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		return 0;
 	}
@@ -365,7 +365,7 @@ static int _get_block_create_0(struct inode *inode, sector_t block,
 		pathrelse(&path);
 		if (p)
 			kunmap(bh_result->b_page);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -2207,7 +2207,7 @@ static int grab_tail_page(struct inode *inode,
 	 * and it won't need converting or zeroing after a truncate.
 	 */
 	if ((offset & (blocksize - 1)) == 0) {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	page = grab_cache_page(inode->i_mapping, index);
 	error = -ENOMEM;
diff --git a/fs/reiserfs/namei.c b/fs/reiserfs/namei.c
index 159468758..1214f77a8 100644
--- a/fs/reiserfs/namei.c
+++ b/fs/reiserfs/namei.c
@@ -1366,7 +1366,7 @@ static int reiserfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 
 	if (retval != NAME_FOUND || old_de.de_objectid != old_inode->i_ino) {
 		reiserfs_write_unlock(old_dir->i_sb);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	old_inode_mode = old_inode->i_mode;
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 59dffd5ca..b1cc134e6 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -52,7 +52,7 @@ int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
 		parent = sysfs_root_kn;
 
 	if (!parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kobject_get_ownership(kobj, &uid, &gid);
 
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index eb6897ab7..58c9f5a33 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -370,7 +370,7 @@ int sysfs_add_file_to_group(struct kobject *kobj,
 	}
 
 	if (!parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kobject_get_ownership(kobj, &uid, &gid);
 	error = sysfs_add_file_mode_ns(parent, attr, false,
@@ -397,7 +397,7 @@ int sysfs_chmod_file(struct kobject *kobj, const struct attribute *attr,
 
 	kn = kernfs_find_and_get(kobj->sd, attr->name);
 	if (!kn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	newattrs.ia_mode = (mode & S_IALLUGO) | (kn->mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE;
@@ -638,7 +638,7 @@ int sysfs_file_change_owner(struct kobject *kobj, const char *name, kuid_t kuid,
 
 	kn = kernfs_find_and_get(kobj->sd, name);
 	if (!kn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = internal_change_owner(kn, kuid, kgid);
 
diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 64e6a6698..daa089885 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -335,7 +335,7 @@ int sysfs_merge_group(struct kobject *kobj,
 
 	parent = kernfs_find_and_get(kobj->sd, grp->name);
 	if (!parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kobject_get_ownership(kobj, &uid, &gid);
 
@@ -387,7 +387,7 @@ int sysfs_add_link_to_group(struct kobject *kobj, const char *group_name,
 
 	parent = kernfs_find_and_get(kobj->sd, group_name);
 	if (!parent)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = sysfs_create_link_sd(parent, target, link_name);
 	kernfs_put(parent);
@@ -444,12 +444,12 @@ int compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
 		kernfs_get(target);
 	spin_unlock(&sysfs_symlink_target_lock);
 	if (!target)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	entry = kernfs_find_and_get(target_kobj->sd, target_name);
 	if (!entry) {
 		kernfs_put(target);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!symlink_name)
@@ -478,7 +478,7 @@ static int sysfs_group_attrs_change_owner(struct kernfs_node *grp_kn,
 		for (attr = grp->attrs; *attr; attr++) {
 			kn = kernfs_find_and_get(grp_kn, (*attr)->name);
 			if (!kn)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 
 			error = kernfs_setattr(kn, newattrs);
 			kernfs_put(kn);
@@ -493,7 +493,7 @@ static int sysfs_group_attrs_change_owner(struct kernfs_node *grp_kn,
 		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++) {
 			kn = kernfs_find_and_get(grp_kn, (*bin_attr)->attr.name);
 			if (!kn)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 
 			error = kernfs_setattr(kn, newattrs);
 			kernfs_put(kn);
@@ -536,7 +536,7 @@ int sysfs_group_change_owner(struct kobject *kobj,
 		grp_kn = kobj->sd;
 	}
 	if (!grp_kn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = kernfs_setattr(grp_kn, &newattrs);
 	if (!error)
diff --git a/fs/sysfs/symlink.c b/fs/sysfs/symlink.c
index 5603530a1..f16c06f3b 100644
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@ -39,7 +39,7 @@ static int sysfs_do_create_link_sd(struct kernfs_node *parent,
 	spin_unlock(&sysfs_symlink_target_lock);
 
 	if (!target)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kn = kernfs_create_link(parent, name, target);
 	kernfs_put(target);
diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
index 31288d8fa..8a13dee89 100644
--- a/fs/ubifs/debug.c
+++ b/fs/ubifs/debug.c
@@ -2220,7 +2220,7 @@ static int check_inodes(struct ubifs_info *c, struct fsck_data *fsckd)
 	if (!err) {
 		ubifs_err(c, "inode %lu not found in index",
 			  (unsigned long)fscki->inum);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (err < 0) {
 		ubifs_err(c, "error %d while looking up inode %lu",
 			  err, (unsigned long)fscki->inum);
diff --git a/fs/ubifs/tnc.c b/fs/ubifs/tnc.c
index e8e7b0e95..ab842b34a 100644
--- a/fs/ubifs/tnc.c
+++ b/fs/ubifs/tnc.c
@@ -615,7 +615,7 @@ static int tnc_next(struct ubifs_info *c, struct ubifs_znode **zn, int *n)
 
 		zp = znode->parent;
 		if (!zp)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		nn = znode->iip + 1;
 		znode = zp;
 		if (nn < znode->child_cnt) {
@@ -659,7 +659,7 @@ static int tnc_prev(struct ubifs_info *c, struct ubifs_znode **zn, int *n)
 
 		zp = znode->parent;
 		if (!zp)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		nn = znode->iip - 1;
 		znode = zp;
 		if (nn >= 0) {
@@ -1901,7 +1901,7 @@ static int search_dh_cookie(struct ubifs_info *c, const union ubifs_key *key,
 
 		if (key_inum(c, dkey) != key_inum(c, key) ||
 		    key_type(c, dkey) != key_type(c, key)) {
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		err = tnc_read_hashed_node(c, zbr, dent);
diff --git a/fs/vboxsf/utils.c b/fs/vboxsf/utils.c
index 96bd160da..dd492f8e9 100644
--- a/fs/vboxsf/utils.c
+++ b/fs/vboxsf/utils.c
@@ -149,7 +149,7 @@ int vboxsf_stat(struct vboxsf_sbi *sbi, struct shfl_string *path,
 		return err;
 
 	if (params.result != SHFL_FILE_EXISTS)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (info)
 		*info = params.info;
diff --git a/fs/xfs/libxfs/xfs_btree.c b/fs/xfs/libxfs/xfs_btree.c
index 2d25bab68..2bc1268c9 100644
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@ -4260,7 +4260,7 @@ xfs_btree_visit_block(
 	/* now read rh sibling block for next iteration */
 	xfs_btree_get_sibling(cur, block, &rptr, XFS_BB_RIGHTSIB);
 	if (xfs_btree_ptr_is_null(cur, &rptr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return xfs_btree_lookup_get_block(cur, level, &rptr, &block);
 }
diff --git a/fs/xfs/libxfs/xfs_dir2.c b/fs/xfs/libxfs/xfs_dir2.c
index 612a9c5e4..527e7c866 100644
--- a/fs/xfs/libxfs/xfs_dir2.c
+++ b/fs/xfs/libxfs/xfs_dir2.c
@@ -315,7 +315,7 @@ xfs_dir_cilookup_result(
 	int		len)
 {
 	if (args->cmpresult == XFS_CMP_DIFFERENT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (args->cmpresult != XFS_CMP_CASE ||
 					!(args->op_flags & XFS_DA_OP_CILOOKUP))
 		return -EEXIST;
diff --git a/fs/xfs/libxfs/xfs_dir2_block.c b/fs/xfs/libxfs/xfs_dir2_block.c
index 5b59d3f77..b8b5a7154 100644
--- a/fs/xfs/libxfs/xfs_dir2_block.c
+++ b/fs/xfs/libxfs/xfs_dir2_block.c
@@ -719,7 +719,7 @@ xfs_dir2_block_lookup_int(
 		if (low > high) {
 			ASSERT(args->op_flags & XFS_DA_OP_OKNOENT);
 			xfs_trans_brelse(tp, bp);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	/*
@@ -767,7 +767,7 @@ xfs_dir2_block_lookup_int(
 	 * No match, release the buffer and return ENOENT.
 	 */
 	xfs_trans_brelse(tp, bp);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/fs/xfs/libxfs/xfs_dir2_leaf.c b/fs/xfs/libxfs/xfs_dir2_leaf.c
index 95d2a3f92..39ad06f58 100644
--- a/fs/xfs/libxfs/xfs_dir2_leaf.c
+++ b/fs/xfs/libxfs/xfs_dir2_leaf.c
@@ -1326,7 +1326,7 @@ xfs_dir2_leaf_lookup_int(
 	if (dbp)
 		xfs_trans_brelse(tp, dbp);
 	xfs_trans_brelse(tp, lbp);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/fs/xfs/libxfs/xfs_dir2_node.c b/fs/xfs/libxfs/xfs_dir2_node.c
index 6ac4aad98..8cd723518 100644
--- a/fs/xfs/libxfs/xfs_dir2_node.c
+++ b/fs/xfs/libxfs/xfs_dir2_node.c
@@ -767,7 +767,7 @@ xfs_dir2_leafn_lookup_for_addname(
 	 * Return the index, that will be the insertion point.
 	 */
 	*indexp = index;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
@@ -920,7 +920,7 @@ xfs_dir2_leafn_lookup_for_entry(
 		state->extravalid = 0;
 	}
 	*indexp = index;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/fs/xfs/libxfs/xfs_dir2_sf.c b/fs/xfs/libxfs/xfs_dir2_sf.c
index 2463b5d73..482903d4a 100644
--- a/fs/xfs/libxfs/xfs_dir2_sf.c
+++ b/fs/xfs/libxfs/xfs_dir2_sf.c
@@ -929,7 +929,7 @@ xfs_dir2_sf_lookup(
 	 * If a case-insensitive match was not found, return -ENOENT.
 	 */
 	if (!ci_sfep)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/* otherwise process the CI match as required by the caller */
 	error = xfs_dir_cilookup_result(args, ci_sfep->name, ci_sfep->namelen);
 	return error;
@@ -978,7 +978,7 @@ xfs_dir2_sf_removename(
 	 * Didn't find it.
 	 */
 	if (i == sfp->count)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/*
 	 * Calculate sizes.
 	 */
@@ -1117,7 +1117,7 @@ xfs_dir2_sf_replace(
 			ASSERT(args->op_flags & XFS_DA_OP_OKNOENT);
 			if (i8elevated)
 				xfs_dir2_sf_toino4(args);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	/*
diff --git a/fs/xfs/scrub/attr.c b/fs/xfs/scrub/attr.c
index 9faddb334..31299c67f 100644
--- a/fs/xfs/scrub/attr.c
+++ b/fs/xfs/scrub/attr.c
@@ -478,7 +478,7 @@ xchk_xattr(
 	int				error = 0;
 
 	if (!xfs_inode_hasattr(sc->ip))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memset(&sx, 0, sizeof(sx));
 	/* Check attribute tree structure */
diff --git a/fs/xfs/scrub/bmap.c b/fs/xfs/scrub/bmap.c
index 7badd6dfe..73323e3df 100644
--- a/fs/xfs/scrub/bmap.c
+++ b/fs/xfs/scrub/bmap.c
@@ -741,7 +741,7 @@ xchk_bmap_cow(
 	struct xfs_scrub	*sc)
 {
 	if (!xfs_is_reflink_inode(sc->ip))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return xchk_bmap(sc, XFS_COW_FORK);
 }
diff --git a/fs/xfs/scrub/common.c b/fs/xfs/scrub/common.c
index 18876056e..3a24d50c5 100644
--- a/fs/xfs/scrub/common.c
+++ b/fs/xfs/scrub/common.c
@@ -685,7 +685,7 @@ xchk_get_inode(
 
 	/* Look up the inode, see if the generation number matches. */
 	if (xfs_internal_inum(mp, sc->sm->sm_ino))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	error = xfs_iget(mp, NULL, sc->sm->sm_ino,
 			XFS_IGET_UNTRUSTED | XFS_IGET_DONTCACHE, 0, &ip);
 	switch (error) {
@@ -711,7 +711,7 @@ xchk_get_inode(
 		error = xfs_imap(sc->mp, sc->tp, sc->sm->sm_ino, &imap,
 				XFS_IGET_UNTRUSTED | XFS_IGET_DONTCACHE);
 		if (error)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		error = -EFSCORRUPTED;
 		/* fall through */
 	default:
@@ -723,7 +723,7 @@ xchk_get_inode(
 	}
 	if (VFS_I(ip)->i_generation != sc->sm->sm_gen) {
 		xfs_irele(ip);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	sc->ip = ip;
diff --git a/fs/xfs/scrub/common.h b/fs/xfs/scrub/common.h
index 2e50d1461..93714ef42 100644
--- a/fs/xfs/scrub/common.h
+++ b/fs/xfs/scrub/common.h
@@ -101,7 +101,7 @@ int xchk_setup_rt(struct xfs_scrub *sc, struct xfs_inode *ip);
 static inline int
 xchk_setup_rt(struct xfs_scrub *sc, struct xfs_inode *ip)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 #ifdef CONFIG_XFS_QUOTA
@@ -110,7 +110,7 @@ int xchk_setup_quota(struct xfs_scrub *sc, struct xfs_inode *ip);
 static inline int
 xchk_setup_quota(struct xfs_scrub *sc, struct xfs_inode *ip)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 int xchk_setup_fscounters(struct xfs_scrub *sc, struct xfs_inode *ip);
diff --git a/fs/xfs/scrub/dir.c b/fs/xfs/scrub/dir.c
index 7c432997e..13acd83c7 100644
--- a/fs/xfs/scrub/dir.c
+++ b/fs/xfs/scrub/dir.c
@@ -786,7 +786,7 @@ xchk_directory(
 	int			error = 0;
 
 	if (!S_ISDIR(VFS_I(sc->ip)->i_mode))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Plausible size? */
 	if (sc->ip->i_d.di_size < xfs_dir2_sf_hdr_size(0)) {
diff --git a/fs/xfs/scrub/parent.c b/fs/xfs/scrub/parent.c
index 855aa8bca..2733ee956 100644
--- a/fs/xfs/scrub/parent.c
+++ b/fs/xfs/scrub/parent.c
@@ -275,7 +275,7 @@ xchk_parent(
 	 * a directory that has one entry pointing to us.
 	 */
 	if (!S_ISDIR(VFS_I(sc->ip)->i_mode))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* We're not a special inode, are we? */
 	if (!xfs_verify_dir_ino(mp, sc->ip->i_ino)) {
diff --git a/fs/xfs/scrub/quota.c b/fs/xfs/scrub/quota.c
index 905a34558..2b7096244 100644
--- a/fs/xfs/scrub/quota.c
+++ b/fs/xfs/scrub/quota.c
@@ -44,7 +44,7 @@ xchk_setup_quota(
 	int			error;
 
 	if (!XFS_IS_QUOTA_RUNNING(sc->mp) || !XFS_IS_QUOTA_ON(sc->mp))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dqtype = xchk_quota_to_dqtype(sc);
 	if (dqtype == 0)
@@ -52,7 +52,7 @@ xchk_setup_quota(
 	sc->flags |= XCHK_HAS_QUOTAOFFLOCK;
 	mutex_lock(&sc->mp->m_quotainfo->qi_quotaofflock);
 	if (!xfs_this_quota_on(sc->mp, dqtype))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	error = xchk_setup_fs(sc, ip);
 	if (error)
 		return error;
diff --git a/fs/xfs/scrub/scrub.h b/fs/xfs/scrub/scrub.h
index ad1ceb44a..e85c9edce 100644
--- a/fs/xfs/scrub/scrub.h
+++ b/fs/xfs/scrub/scrub.h
@@ -110,12 +110,12 @@ int xchk_rtsummary(struct xfs_scrub *sc);
 static inline int
 xchk_rtbitmap(struct xfs_scrub *sc)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 static inline int
 xchk_rtsummary(struct xfs_scrub *sc)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 #ifdef CONFIG_XFS_QUOTA
@@ -124,7 +124,7 @@ int xchk_quota(struct xfs_scrub *sc);
 static inline int
 xchk_quota(struct xfs_scrub *sc)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 int xchk_fscounters(struct xfs_scrub *sc);
diff --git a/fs/xfs/scrub/symlink.c b/fs/xfs/scrub/symlink.c
index 5641ae512..c104d6ea0 100644
--- a/fs/xfs/scrub/symlink.c
+++ b/fs/xfs/scrub/symlink.c
@@ -41,7 +41,7 @@ xchk_symlink(
 	int			error = 0;
 
 	if (!S_ISLNK(VFS_I(ip)->i_mode))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);
 	len = ip->i_d.di_size;
 
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index 20b748f7e..75416ab40 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -623,7 +623,7 @@ xfs_buf_find(
 		XFS_STATS_INC(btp->bt_mount, xb_miss_locked);
 		spin_unlock(&pag->pag_buf_lock);
 		xfs_perag_put(pag);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* the buffer keeps the perag reference until it is freed */
diff --git a/fs/xfs/xfs_dquot.c b/fs/xfs/xfs_dquot.c
index d5b7f03e9..a8994dde5 100644
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@ -441,7 +441,7 @@ xfs_dquot_disk_read(
 	ASSERT(map.br_blockcount >= 1);
 	ASSERT(map.br_startblock != DELAYSTARTBLOCK);
 	if (map.br_startblock == HOLESTARTBLOCK)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	trace_xfs_dqtobp_read(dqp);
 
@@ -651,7 +651,7 @@ xfs_dq_get_next_id(
 
 	/* If we'd wrap past the max ID, stop */
 	if (next_id < *id)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* If new ID is within the current chunk, advancing it sufficed */
 	if (next_id % mp->m_quotainfo->qi_dqperchunk) {
diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c
index 5daef6549..939896c17 100644
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@ -341,7 +341,7 @@ xfs_iget_check_free_state(
 
 	/* should be an allocated inode */
 	if (VFS_I(ip)->i_mode == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 517a5231c..ececd9475 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -124,7 +124,7 @@ static inline void *acpi_hest_get_next(struct acpi_hest_generic_data *gdata)
 #ifdef CONFIG_ACPI_APEI_SEA
 int ghes_notify_sea(void);
 #else
-static inline int ghes_notify_sea(void) { return -ENOENT; }
+static inline int ghes_notify_sea(void) { ENOENT_DUMPER(stackdump_tuneable); }
 #endif
 
 #endif /* GHES_H */
diff --git a/include/linux/errno.h b/include/linux/errno.h
index 1738ba062..6b4e44c74 100644
--- a/include/linux/errno.h
+++ b/include/linux/errno.h
@@ -8,6 +8,7 @@
 do{											\
 	if(stackdump_tuneable != 0){							\
 		printk(KERN_INFO "ENOENT_DUMPER linux/include/linux/errno.h\n");	\
+		dump_stack();								\
 		return -ENOENT;								\
 	}										\
 	else{										\
diff --git a/include/linux/fs.h b/include/linux/fs.h
index f5abba861..ac0a8f6f4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1266,7 +1266,7 @@ static inline int posix_lock_file(struct file *filp, struct file_lock *fl,
 
 static inline int locks_delete_block(struct file_lock *waiter)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int vfs_test_lock(struct file *filp, struct file_lock *fl)
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 34c1c4f45..d41e366fb 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -700,7 +700,7 @@ static inline int pcibios_err_to_errno(int err)
 
 	switch (err) {
 	case PCIBIOS_FUNC_NOT_SUPPORTED:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case PCIBIOS_BAD_VENDOR_ID:
 		return -ENOTTY;
 	case PCIBIOS_DEVICE_NOT_FOUND:
diff --git a/include/linux/reset.h b/include/linux/reset.h
index 05aa9f440..6cab6c2f4 100644
--- a/include/linux/reset.h
+++ b/include/linux/reset.h
@@ -118,7 +118,7 @@ of_reset_control_array_get(struct device_node *np, bool shared, bool optional,
 
 static inline int reset_control_get_count(struct device *dev)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #endif /* CONFIG_RESET_CONTROLLER */
diff --git a/include/linux/rhashtable.h b/include/linux/rhashtable.h
index d3432ee65..8e602605a 100644
--- a/include/linux/rhashtable.h
+++ b/include/linux/rhashtable.h
@@ -1004,7 +1004,7 @@ static inline int __rhashtable_remove_fast_one(
 	hash = rht_head_hashfn(ht, tbl, obj, params);
 	bkt = rht_bucket_var(tbl, hash);
 	if (!bkt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	pprev = NULL;
 	rht_lock(tbl, bkt);
 
@@ -1162,7 +1162,7 @@ static inline int __rhashtable_replace_fast(
 
 	bkt = rht_bucket_var(tbl, hash);
 	if (!bkt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pprev = NULL;
 	rht_lock(tbl, bkt);
diff --git a/include/linux/skmsg.h b/include/linux/skmsg.h
index 1e9ed840b..8cf716c9c 100644
--- a/include/linux/skmsg.h
+++ b/include/linux/skmsg.h
@@ -435,7 +435,7 @@ static inline int psock_replace_prog(struct bpf_prog **pprog,
 				     struct bpf_prog *old)
 {
 	if (cmpxchg(pprog, old, prog) != old)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (old)
 		bpf_prog_put(old);
diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 10891b70f..0aa9f8029 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -254,7 +254,7 @@ static inline int get_int(char **bpp, int *anint)
 	if (len < 0)
 		return -EINVAL;
 	if (len == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rv = simple_strtol(buf, &ep, 0);
 	if (*ep)
@@ -272,7 +272,7 @@ static inline int get_uint(char **bpp, unsigned int *anint)
 	if (len < 0)
 		return -EINVAL;
 	if (len == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (kstrtouint(buf, 0, anint))
 		return -EINVAL;
@@ -289,7 +289,7 @@ static inline int get_time(char **bpp, time64_t *time)
 	if (len < 0)
 		return -EINVAL;
 	if (len == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (kstrtoll(buf, 0, &ll))
 		return -EINVAL;
diff --git a/include/linux/thermal.h b/include/linux/thermal.h
index 216185bb3..de16cd91b 100644
--- a/include/linux/thermal.h
+++ b/include/linux/thermal.h
@@ -353,7 +353,7 @@ static inline int thermal_zone_of_get_sensor_id(struct device_node *tz_np,
 					 struct device_node *sensor_np,
 					 u32 *id)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 static inline struct thermal_zone_device *
 thermal_zone_of_sensor_register(struct device *dev, int id, void *data,
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index fc7e88078..95d19b858 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -1658,7 +1658,7 @@ static inline int cfg80211_get_station(struct net_device *dev,
 				       const u8 *mac_addr,
 				       struct station_info *sinfo)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
diff --git a/include/net/netlabel.h b/include/net/netlabel.h
index 43ae50337..75f316f6a 100644
--- a/include/net/netlabel.h
+++ b/include/net/netlabel.h
@@ -576,12 +576,12 @@ static inline int netlbl_cfg_calipso_map_add(u32 doi,
 static inline int netlbl_catmap_walk(struct netlbl_lsm_catmap *catmap,
 				     u32 offset)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 static inline int netlbl_catmap_walkrng(struct netlbl_lsm_catmap *catmap,
 					u32 offset)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 static inline int netlbl_catmap_getlong(struct netlbl_lsm_catmap *catmap,
 					u32 *offset,
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index 3a41627cb..36e4b45b0 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -441,7 +441,7 @@ static inline int
 vxlan_fdb_find_uc(struct net_device *dev, const u8 *mac, __be32 vni,
 		  struct switchdev_notifier_vxlan_fdb_info *fdb_info)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline int vxlan_fdb_replay(const struct net_device *dev, __be32 vni,
diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index beff0cfcd..e06928c5d 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -859,7 +859,7 @@ static int prepare_open(struct dentry *dentry, int oflag, int ro,
 
 	if (d_really_is_negative(dentry)) {
 		if (!(oflag & O_CREAT))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (ro)
 			return ro;
 		audit_inode_parent_hidden(name, dentry->d_parent);
diff --git a/kernel/audit_tree.c b/kernel/audit_tree.c
index e49c912f8..2652ca4b0 100644
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@ -855,7 +855,7 @@ int audit_add_tree_rule(struct audit_krule *rule)
 	mutex_lock(&audit_filter_mutex);
 	if (list_empty(&rule->rlist)) {
 		put_tree(tree);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	rule->tree = tree;
 	put_tree(tree);
diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c
index 11584618e..fc48819e9 100644
--- a/kernel/bpf/arraymap.c
+++ b/kernel/bpf/arraymap.c
@@ -201,7 +201,7 @@ static int array_map_direct_value_meta(const struct bpf_map *map, u64 imm,
 	if (map->max_entries != 1)
 		return -ENOTSUPP;
 	if (imm < base || imm >= base + range)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*off = imm - base;
 	return 0;
@@ -258,7 +258,7 @@ int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)
 	u32 size;
 
 	if (unlikely(index >= array->map.max_entries))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* per_cpu areas are zero-filled and bpf programs can only
 	 * access 'value_size' of them, so copying rounded areas
@@ -288,7 +288,7 @@ static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key
 	}
 
 	if (index == array->map.max_entries - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*next = index + 1;
 	return 0;
@@ -629,7 +629,7 @@ static int fd_array_map_delete_elem(struct bpf_map *map, void *key)
 		map->ops->map_fd_put_ptr(old_ptr);
 		return 0;
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/kernel/bpf/bpf_iter.c b/kernel/bpf/bpf_iter.c
index dd612b80b..b6c778d93 100644
--- a/kernel/bpf/bpf_iter.c
+++ b/kernel/bpf/bpf_iter.c
@@ -388,7 +388,7 @@ int bpf_iter_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
 	}
 	mutex_unlock(&targets_mutex);
 	if (!existed)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	link = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);
 	if (!link)
diff --git a/kernel/bpf/bpf_struct_ops.c b/kernel/bpf/bpf_struct_ops.c
index c6b0decaa..11904cf23 100644
--- a/kernel/bpf/bpf_struct_ops.c
+++ b/kernel/bpf/bpf_struct_ops.c
@@ -232,7 +232,7 @@ static int bpf_struct_ops_map_get_next_key(struct bpf_map *map, void *key,
 					   void *next_key)
 {
 	if (key && *(u32 *)key == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*(u32 *)next_key = 0;
 	return 0;
@@ -246,7 +246,7 @@ int bpf_struct_ops_map_sys_lookup_elem(struct bpf_map *map, void *key,
 	enum bpf_struct_ops_state state;
 
 	if (unlikely(*(u32 *)key != 0))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kvalue = &st_map->kvalue;
 	/* Pair with smp_store_release() during map_update */
@@ -499,11 +499,11 @@ static int bpf_struct_ops_map_delete_elem(struct bpf_map *map, void *key)
 	case BPF_STRUCT_OPS_STATE_TOBEFREE:
 		return -EINPROGRESS;
 	case BPF_STRUCT_OPS_STATE_INIT:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	default:
 		WARN_ON_ONCE(1);
 		/* Should never happen.  Treat it as not found. */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c
index 9a1a98dd9..770bd431a 100644
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@ -398,7 +398,7 @@ s32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 const struct btf_type *btf_type_skip_modifiers(const struct btf *btf,
@@ -3581,7 +3581,7 @@ static int btf_translate_to_vmlinux(struct bpf_verifier_log *log,
 
 	prog_ctx_type = btf_get_prog_ctx_type(log, btf, t, prog_type, arg);
 	if (!prog_ctx_type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	kern_ctx_type = prog_ctx_type + 1;
 	return kern_ctx_type->type;
 }
@@ -4079,7 +4079,7 @@ static int __btf_resolve_helper_id(struct bpf_verifier_log *log, void *fn,
 	}
 	if (i > btf_vmlinux->nr_types) {
 		bpf_log(log, "helper %s type is not found\n", fnname);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	t = btf_type_by_id(btf_vmlinux, t->type);
diff --git a/kernel/bpf/cgroup.c b/kernel/bpf/cgroup.c
index ac53102e2..cf45aed8f 100644
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@ -576,7 +576,7 @@ static int __cgroup_bpf_replace(struct cgroup *cgrp,
 		}
 	}
 	if (!found)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	old_prog = xchg(&link->link.prog, new_prog);
 	replace_effective_prog(cgrp, link->type, link);
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 9df4cc9a2..3f12e8907 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -1987,7 +1987,7 @@ int bpf_prog_array_copy(struct bpf_prog_array *old_array,
 	}
 
 	if (exclude_prog && !found_exclude)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* How many progs (not NULL) will be in the new array? */
 	new_prog_cnt = carry_prog_cnt;
diff --git a/kernel/bpf/cpumap.c b/kernel/bpf/cpumap.c
index 27595fc6d..fbfc9bc57 100644
--- a/kernel/bpf/cpumap.c
+++ b/kernel/bpf/cpumap.c
@@ -538,7 +538,7 @@ static int cpu_map_get_next_key(struct bpf_map *map, void *key, void *next_key)
 	}
 
 	if (index == cmap->map.max_entries - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*next = index + 1;
 	return 0;
 }
diff --git a/kernel/bpf/devmap.c b/kernel/bpf/devmap.c
index 5fdbc776a..f56f06a96 100644
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
@@ -267,7 +267,7 @@ static int dev_map_get_next_key(struct bpf_map *map, void *key, void *next_key)
 	}
 
 	if (index == dtab->map.max_entries - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*next = index + 1;
 	return 0;
 }
@@ -328,7 +328,7 @@ static int dev_map_hash_get_next_key(struct bpf_map *map, void *key,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 bool dev_map_can_have_prog(struct bpf_map *map)
diff --git a/kernel/bpf/hashtab.c b/kernel/bpf/hashtab.c
index b4b288a3c..3c174712d 100644
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@ -761,7 +761,7 @@ static int htab_map_get_next_key(struct bpf_map *map, void *key, void *next_key)
 	}
 
 	/* iterated over all buckets and all elements */
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void htab_elem_free(struct bpf_htab *htab, struct htab_elem *l)
@@ -914,7 +914,7 @@ static int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,
 
 	if (!l_old && (map_flags & ~BPF_F_LOCK) == BPF_EXIST)
 		/* elem doesn't exist, cannot update it */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -1377,7 +1377,7 @@ __htab_map_lookup_and_delete_batch(struct bpf_map *map,
 		return -EFAULT;
 
 	if (batch >= htab->n_buckets)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	key_size = htab->map.key_size;
 	roundup_key_size = round_up(htab->map.key_size, 8);
diff --git a/kernel/bpf/inode.c b/kernel/bpf/inode.c
index fb878ba3f..e8cd17bc2 100644
--- a/kernel/bpf/inode.c
+++ b/kernel/bpf/inode.c
@@ -523,7 +523,7 @@ int bpf_obj_get_user(const char __user *pathname, int flags)
 	else if (type == BPF_TYPE_LINK)
 		ret = bpf_link_new_fd(raw);
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (ret < 0)
 		bpf_any_put(raw, type);
diff --git a/kernel/bpf/local_storage.c b/kernel/bpf/local_storage.c
index 33d01866b..d61749f48 100644
--- a/kernel/bpf/local_storage.c
+++ b/kernel/bpf/local_storage.c
@@ -144,7 +144,7 @@ static int cgroup_storage_update_elem(struct bpf_map *map, void *_key,
 	storage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,
 					key, false);
 	if (!storage)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (flags & BPF_F_LOCK) {
 		copy_map_value_locked(map, storage->buf->data, value, false);
@@ -180,7 +180,7 @@ int bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *_key,
 	storage = cgroup_storage_lookup(map, key, false);
 	if (!storage) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* per_cpu areas are zero-filled and bpf programs can only
@@ -213,7 +213,7 @@ int bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *_key,
 	storage = cgroup_storage_lookup(map, key, false);
 	if (!storage) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* the user space will provide round_up(value_size, 8) bytes that
@@ -265,7 +265,7 @@ static int cgroup_storage_get_next_key(struct bpf_map *_map, void *_key,
 
 enoent:
 	spin_unlock_bh(&map->lock);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct bpf_map *cgroup_storage_map_alloc(union bpf_attr *attr)
diff --git a/kernel/bpf/lpm_trie.c b/kernel/bpf/lpm_trie.c
index c8cc4e4cf..5b2e80986 100644
--- a/kernel/bpf/lpm_trie.c
+++ b/kernel/bpf/lpm_trie.c
@@ -651,7 +651,7 @@ static int trie_get_next_key(struct bpf_map *map, void *_key, void *_next_key)
 	/* Empty trie */
 	search_root = rcu_dereference(trie->root);
 	if (!search_root)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* For invalid key, find the leftmost node in the trie */
 	if (!key || key->prefixlen > trie->max_prefixlen)
diff --git a/kernel/bpf/net_namespace.c b/kernel/bpf/net_namespace.c
index 310241ca7..6fd0e1aba 100644
--- a/kernel/bpf/net_namespace.c
+++ b/kernel/bpf/net_namespace.c
@@ -276,7 +276,7 @@ static int __netns_bpf_prog_detach(struct net *net,
 
 	attached = net->bpf.progs[type];
 	if (!attached || attached != old)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	netns_bpf_run_array_detach(net, type);
 	net->bpf.progs[type] = NULL;
 	bpf_prog_put(attached);
diff --git a/kernel/bpf/reuseport_array.c b/kernel/bpf/reuseport_array.c
index cae9d505e..83b3d2378 100644
--- a/kernel/bpf/reuseport_array.c
+++ b/kernel/bpf/reuseport_array.c
@@ -72,7 +72,7 @@ static int reuseport_array_delete_elem(struct bpf_map *map, void *key)
 		return -E2BIG;
 
 	if (!rcu_access_pointer(array->ptrs[index]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock_bh(&reuseport_lock);
 
@@ -214,7 +214,7 @@ reuseport_array_update_check(const struct reuseport_array *array,
 		return -EEXIST;
 
 	if (!osk && map_flags == BPF_EXIST)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (nsk->sk_protocol != IPPROTO_UDP && nsk->sk_protocol != IPPROTO_TCP)
 		return -ENOTSUPP;
@@ -345,7 +345,7 @@ static int reuseport_array_get_next_key(struct bpf_map *map, void *key,
 	}
 
 	if (index == array->map.max_entries - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*next = index + 1;
 	return 0;
diff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c
index 599488f25..f8ed482fa 100644
--- a/kernel/bpf/stackmap.c
+++ b/kernel/bpf/stackmap.c
@@ -529,11 +529,11 @@ int bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)
 	u32 id = *(u32 *)key, trace_len;
 
 	if (unlikely(id >= smap->n_buckets))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bucket = xchg(&smap->buckets[id], NULL);
 	if (!bucket)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	trace_len = bucket->nr * stack_map_data_size(map);
 	memcpy(value, bucket->data, trace_len);
@@ -568,7 +568,7 @@ static int stack_map_get_next_key(struct bpf_map *map, void *key,
 		id++;
 
 	if (id >= smap->n_buckets)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*(u32 *)next_key = id;
 	return 0;
@@ -595,7 +595,7 @@ static int stack_map_delete_elem(struct bpf_map *map, void *key)
 		pcpu_freelist_push(&smap->freelist, &old_bucket->fnode);
 		return 0;
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
index 0fd80ac81..8fe623112 100644
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@ -3725,12 +3725,12 @@ static int bpf_task_fd_query(const union bpf_attr *attr,
 
 	task = get_pid_task(find_vpid(pid), PIDTYPE_PID);
 	if (!task)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	files = get_files_struct(task);
 	put_task_struct(task);
 	if (!files)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = 0;
 	spin_lock(&files->file_lock);
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 94cead5a4..7d6922e9a 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -908,7 +908,7 @@ static int pop_stack(struct bpf_verifier_env *env, int *prev_insn_idx,
 	int err;
 
 	if (env->head == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (cur) {
 		err = copy_verifier_state(cur, &head->st);
@@ -1400,7 +1400,7 @@ static int find_subprog(struct bpf_verifier_env *env, int off)
 	p = bsearch(&off, env->subprog_info, env->subprog_cnt,
 		    sizeof(env->subprog_info[0]), cmp_subprogs);
 	if (!p)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return p - env->subprog_info;
 
 }
diff --git a/kernel/cgroup/cgroup-v1.c b/kernel/cgroup/cgroup-v1.c
index 191c329e4..1a3b3c03b 100644
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@ -707,7 +707,7 @@ int cgroupstats_build(struct cgroupstats *stats, struct dentry *dentry)
 	if (!cgrp || cgroup_is_dead(cgrp)) {
 		rcu_read_unlock();
 		mutex_unlock(&cgroup_mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	rcu_read_unlock();
 
@@ -953,7 +953,7 @@ int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)
 	case Opt_name:
 		/* blocked by boot param? */
 		if (cgroup_no_v1_named)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		/* Can't specify an empty name */
 		if (!param->size)
 			return invalfc(fc, "Empty name");
diff --git a/kernel/cgroup/cgroup.c b/kernel/cgroup/cgroup.c
index dd247747e..cb0d7ea98 100644
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@ -3392,7 +3392,7 @@ static ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,
 	/* drain dying csses before we re-apply (threaded) subtree control */
 	cgrp = cgroup_kn_lock_live(of->kn, true);
 	if (!cgrp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* threaded can only be enabled */
 	ret = cgroup_enable_threaded(cgrp);
@@ -3435,7 +3435,7 @@ static ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,
 
 	cgrp = cgroup_kn_lock_live(of->kn, false);
 	if (!cgrp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cgrp->max_descendants = descendants;
 
@@ -3478,7 +3478,7 @@ static ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,
 
 	cgrp = cgroup_kn_lock_live(of->kn, false);
 	if (!cgrp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cgrp->max_depth = depth;
 
@@ -3647,7 +3647,7 @@ static ssize_t cgroup_freeze_write(struct kernfs_open_file *of,
 
 	cgrp = cgroup_kn_lock_live(of->kn, false);
 	if (!cgrp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cgroup_freeze(cgrp, freeze);
 
@@ -3974,7 +3974,7 @@ static int cgroup_rm_cftypes_locked(struct cftype *cfts)
 	lockdep_assert_held(&cgroup_mutex);
 
 	if (!cfts || !cfts[0].ss)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_del(&cfts->node);
 	cgroup_apply_cftypes(cfts, false);
@@ -4702,7 +4702,7 @@ static int cgroup_procs_write_permission(struct cgroup *src_cgrp,
 	if ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&
 	    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||
 	     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/kernel/debug/debug_core.c b/kernel/debug/debug_core.c
index 9e5934780..8846e6788 100644
--- a/kernel/debug/debug_core.c
+++ b/kernel/debug/debug_core.c
@@ -400,7 +400,7 @@ int dbg_remove_sw_break(unsigned long addr)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int kgdb_isremovedbreak(unsigned long addr)
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 856d98c36..71d47a04c 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -9156,7 +9156,7 @@ static int perf_swevent_init(struct perf_event *event)
 	u64 event_id = event->attr.config;
 
 	if (event->attr.type != PERF_TYPE_SOFTWARE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * no branch sampling for software events
@@ -9167,14 +9167,14 @@ static int perf_swevent_init(struct perf_event *event)
 	switch (event_id) {
 	case PERF_COUNT_SW_CPU_CLOCK:
 	case PERF_COUNT_SW_TASK_CLOCK:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	default:
 		break;
 	}
 
 	if (event_id >= PERF_COUNT_SW_MAX)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!event->parent) {
 		int err;
@@ -9319,7 +9319,7 @@ static int perf_tp_event_init(struct perf_event *event)
 	int err;
 
 	if (event->attr.type != PERF_TYPE_TRACEPOINT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * no branch sampling for tracepoint events
@@ -9405,7 +9405,7 @@ static int perf_kprobe_event_init(struct perf_event *event)
 	bool is_retprobe;
 
 	if (event->attr.type != perf_kprobe.type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!perfmon_capable())
 		return -EACCES;
@@ -9465,7 +9465,7 @@ static int perf_uprobe_event_init(struct perf_event *event)
 	bool is_retprobe;
 
 	if (event->attr.type != perf_uprobe.type)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!perfmon_capable())
 		return -EACCES;
@@ -9661,7 +9661,7 @@ static void perf_event_free_filter(struct perf_event *event)
 
 static int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void perf_event_free_bpf_prog(struct perf_event *event)
@@ -10243,10 +10243,10 @@ static void cpu_clock_event_read(struct perf_event *event)
 static int cpu_clock_event_init(struct perf_event *event)
 {
 	if (event->attr.type != PERF_TYPE_SOFTWARE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (event->attr.config != PERF_COUNT_SW_CPU_CLOCK)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * no branch sampling for software events
@@ -10324,10 +10324,10 @@ static void task_clock_event_read(struct perf_event *event)
 static int task_clock_event_init(struct perf_event *event)
 {
 	if (event->attr.type != PERF_TYPE_SOFTWARE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (event->attr.config != PERF_COUNT_SW_TASK_CLOCK)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * no branch sampling for software events
diff --git a/kernel/events/hw_breakpoint.c b/kernel/events/hw_breakpoint.c
index b48d7039a..65c76ccf1 100644
--- a/kernel/events/hw_breakpoint.c
+++ b/kernel/events/hw_breakpoint.c
@@ -618,7 +618,7 @@ static int hw_breakpoint_event_init(struct perf_event *bp)
 	int err;
 
 	if (bp->attr.type != PERF_TYPE_BREAKPOINT)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * no branch sampling for breakpoint events
diff --git a/kernel/gcov/fs.c b/kernel/gcov/fs.c
index 82babf5aa..507864116 100644
--- a/kernel/gcov/fs.c
+++ b/kernel/gcov/fs.c
@@ -672,7 +672,7 @@ static int get_info_index(struct gcov_node *node, struct gcov_info *info)
 		if (node->loaded_info[i] == info)
 			return i;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/kernel/irq/irqdomain.c b/kernel/irq/irqdomain.c
index a4c2c9155..72e4cae79 100644
--- a/kernel/irq/irqdomain.c
+++ b/kernel/irq/irqdomain.c
@@ -1212,7 +1212,7 @@ int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,
 	struct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);
 
 	if (!irq_data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	irq_data->hwirq = hwirq;
 	irq_data->chip = chip ? chip : &no_irq_chip;
diff --git a/kernel/kcsan/debugfs.c b/kernel/kcsan/debugfs.c
index 023e49c58..243f76d55 100644
--- a/kernel/kcsan/debugfs.c
+++ b/kernel/kcsan/debugfs.c
@@ -221,7 +221,7 @@ static ssize_t insert_report_filterlist(const char *func)
 
 	if (!addr) {
 		pr_err("KCSAN: could not find function: '%s'\n", func);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	spin_lock_irqsave(&report_filterlist_lock, flags);
diff --git a/kernel/kmod.c b/kernel/kmod.c
index 37c3c4b97..3e8ae58dd 100644
--- a/kernel/kmod.c
+++ b/kernel/kmod.c
@@ -137,7 +137,7 @@ int __request_module(bool wait, const char *fmt, ...)
 	WARN_ON_ONCE(wait && current_is_async());
 
 	if (!modprobe_path[0])
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	va_start(args, fmt);
 	ret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);
diff --git a/kernel/ksysfs.c b/kernel/ksysfs.c
index 35859da8b..717415326 100644
--- a/kernel/ksysfs.c
+++ b/kernel/ksysfs.c
@@ -47,7 +47,7 @@ static ssize_t uevent_helper_store(struct kobject *kobj,
 				   const char *buf, size_t count)
 {
 	if (count+1 > UEVENT_HELPER_PATH_LEN)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	memcpy(uevent_helper, buf, count);
 	uevent_helper[count] = '\0';
 	if (count && uevent_helper[count-1] == '\n')
diff --git a/kernel/livepatch/core.c b/kernel/livepatch/core.c
index f76fdb925..b8d404980 100644
--- a/kernel/livepatch/core.c
+++ b/kernel/livepatch/core.c
@@ -799,7 +799,7 @@ static int klp_init_object_loaded(struct klp_patch *patch,
 		if (!ret) {
 			pr_err("kallsyms size lookup failed for '%s'\n",
 			       func->old_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (func->nop)
@@ -810,7 +810,7 @@ static int klp_init_object_loaded(struct klp_patch *patch,
 		if (!ret) {
 			pr_err("kallsyms size lookup failed for '%s' replacement\n",
 			       func->old_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/kernel/module.c b/kernel/module.c
index aa183c9ac..da0d4ba31 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -322,7 +322,7 @@ static inline int strong_try_module_get(struct module *mod)
 	if (try_module_get(mod))
 		return 0;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline void add_taint_module(struct module *mod, unsigned flag,
diff --git a/kernel/notifier.c b/kernel/notifier.c
index 84c987dfb..8fb2cc733 100644
--- a/kernel/notifier.c
+++ b/kernel/notifier.c
@@ -46,7 +46,7 @@ static int notifier_chain_unregister(struct notifier_block **nl,
 		}
 		nl = &((*nl)->next);
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/kernel/params.c b/kernel/params.c
index 8e56f8b12..e864946d5 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -154,7 +154,7 @@ static int parse_one(char *param,
 	}
 
 	pr_debug("Unknown argument '%s'\n", param);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Args looks like "foo=bar,bar2 baz=fuz wiz". */
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index b71eaf5f5..4b5f2e751 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2700,7 +2700,7 @@ static int try_enable_new_console(struct console *newcon, bool user_specified)
 	if (newcon->flags & CON_ENABLED && c->user_specified ==	user_specified)
 		return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/kernel/stop_machine.c b/kernel/stop_machine.c
index 865bb0228..e6131c0c6 100644
--- a/kernel/stop_machine.c
+++ b/kernel/stop_machine.c
@@ -127,7 +127,7 @@ int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)
 
 	cpu_stop_init_done(&done, 1);
 	if (!cpu_stop_queue_work(cpu, &work))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/*
 	 * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup
 	 * cycle by doing a preemption:
@@ -340,7 +340,7 @@ int stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *
 	if (cpu1 > cpu2)
 		swap(cpu1, cpu2);
 	if (cpu_stop_queue_two_works(cpu1, &work1, cpu2, &work2))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	wait_for_completion(&done.completion);
 	return done.ret;
@@ -409,7 +409,7 @@ static int __stop_cpus(const struct cpumask *cpumask,
 
 	cpu_stop_init_done(&done, cpumask_weight(cpumask));
 	if (!queue_stop_cpus_work(cpumask, fn, arg, &done))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	wait_for_completion(&done.completion);
 	return done.ret;
 }
diff --git a/kernel/sys.c b/kernel/sys.c
index d45293b42..fad7e25a0 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -2737,7 +2737,7 @@ SYSCALL_DEFINE2(pagecache_counter, int*, hits, int*, miss)
        if(fd0 < 0){
                if(sysctl_error_barf != 0)
                        dump_stack();
-               return -ENOENT;
+               ENOENT_DUMPER(stackdump_tuneable);
        }
        ksys_read(fd0, hitsbuf, 8);
        if(ksys_close(fd0) < 0);
@@ -2747,7 +2747,7 @@ SYSCALL_DEFINE2(pagecache_counter, int*, hits, int*, miss)
        if(fd1 < 0){
                if(sysctl_error_barf != 0)
                        dump_stack();
-               return -ENOENT;
+               ENOENT_DUMPER(stackdump_tuneable);
        }
        ksys_read(fd1, missbuf, 8);
        ksys_close(fd1);
diff --git a/kernel/trace/blktrace.c b/kernel/trace/blktrace.c
index 5ef048451..222487ece 100644
--- a/kernel/trace/blktrace.c
+++ b/kernel/trace/blktrace.c
@@ -487,7 +487,7 @@ static int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,
 		return -EINVAL;
 
 	if (!blk_debugfs_root)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	strncpy(buts->name, name, BLKTRACE_BDEV_SIZE);
 	buts->name[BLKTRACE_BDEV_SIZE - 1] = '\0';
diff --git a/kernel/trace/bpf_trace.c b/kernel/trace/bpf_trace.c
index 7bc3d6175..579b8a521 100644
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@ -750,7 +750,7 @@ get_map_perf_counter(struct bpf_map *map, u64 flags,
 
 	ee = READ_ONCE(array->ptrs[index]);
 	if (!ee)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return perf_event_read_local(ee->event, value, enabled, running);
 }
@@ -822,7 +822,7 @@ __bpf_perf_event_output(struct pt_regs *regs, struct bpf_map *map,
 
 	ee = READ_ONCE(array->ptrs[index]);
 	if (!ee)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	event = ee->event;
 	if (unlikely(event->attr.type != PERF_TYPE_SOFTWARE ||
@@ -1321,7 +1321,7 @@ BPF_CALL_4(bpf_read_branch_records, struct bpf_perf_event_data_kern *, ctx,
 	   void *, buf, u32, size, u64, flags)
 {
 #ifndef CONFIG_X86
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 #else
 	static const u32 br_entry_size = sizeof(struct perf_branch_entry);
 	struct perf_branch_stack *br_stack = ctx->data->br_stack;
@@ -1912,7 +1912,7 @@ int bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,
 
 	prog = event->prog;
 	if (!prog)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */
 	if (prog->type == BPF_PROG_TYPE_PERF_EVENT)
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 1903b80db..47088a0e5 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -4866,7 +4866,7 @@ ftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)
 	if (remove) {
 		entry = ftrace_lookup_ip(hash, ip);
 		if (!entry)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		free_hash_entry(hash, entry);
 		return 0;
 	}
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index bb6226972..f89cb9f4a 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -3350,7 +3350,7 @@ int trace_array_printk(struct trace_array *tr,
 		return 0;
 
 	if (!tr)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	va_start(ap, fmt);
 	ret = trace_array_vprintk(tr, ip, fmt, ap);
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index f6f55682d..41b4ed1f2 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -841,7 +841,7 @@ int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)
 	int ret;
 
 	if (!tr)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/*
 	 * The buf format can be <subsystem>:<event-name>
 	 *  *:<event-name> means any event by that name.
@@ -917,7 +917,7 @@ int trace_array_set_clr_event(struct trace_array *tr, const char *system,
 	int set;
 
 	if (!tr)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	set = (enable == true) ? 1 : 0;
 	return __ftrace_set_clr_event(tr, NULL, system, event, set);
diff --git a/kernel/trace/trace_events_hist.c b/kernel/trace/trace_events_hist.c
index 0b9335461..6120abf08 100644
--- a/kernel/trace/trace_events_hist.c
+++ b/kernel/trace/trace_events_hist.c
@@ -1787,7 +1787,7 @@ static int find_var_ref_idx(struct hist_trigger_data *hist_data,
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/kernel/trace/trace_events_inject.c b/kernel/trace/trace_events_inject.c
index 22bcf7c51..d159ae2f2 100644
--- a/kernel/trace/trace_events_inject.c
+++ b/kernel/trace/trace_events_inject.c
@@ -60,7 +60,7 @@ parse_field(char *str, struct trace_event_call *call,
 	field = trace_find_event_field(call, field_name);
 	kfree(field_name);
 	if (!field)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*pf = field;
 	while (isspace(str[i]))
diff --git a/kernel/trace/trace_events_synth.c b/kernel/trace/trace_events_synth.c
index c6cca0d1d..4d49c1d58 100644
--- a/kernel/trace/trace_events_synth.c
+++ b/kernel/trace/trace_events_synth.c
@@ -1174,7 +1174,7 @@ static int synth_event_run_command(struct dynevent_cmd *cmd)
 
 	se = find_synth_event(cmd->event_name);
 	if (WARN_ON(!se))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	se->mod = cmd->private_data;
 
diff --git a/kernel/trace/trace_kprobe.c b/kernel/trace/trace_kprobe.c
index aefb6065b..5eb8a0088 100644
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@ -409,7 +409,7 @@ static int disable_trace_kprobe(struct trace_event_call *call,
 
 	if (file) {
 		if (!trace_probe_get_file_link(tp, file))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (!trace_probe_has_single_file(tp))
 			goto out;
 		trace_probe_clear_flag(tp, TP_FLAG_TRACE);
@@ -1523,7 +1523,7 @@ static int kprobe_event_define_fields(struct trace_event_call *event_call)
 
 	tp = trace_probe_primary_from_call(event_call);
 	if (WARN_ON_ONCE(!tp))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	DEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);
 
@@ -1538,7 +1538,7 @@ static int kretprobe_event_define_fields(struct trace_event_call *event_call)
 
 	tp = trace_probe_primary_from_call(event_call);
 	if (WARN_ON_ONCE(!tp))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	DEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);
 	DEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);
diff --git a/kernel/trace/trace_probe.c b/kernel/trace/trace_probe.c
index d2867ccc6..144a06f4d 100644
--- a/kernel/trace/trace_probe.c
+++ b/kernel/trace/trace_probe.c
@@ -828,7 +828,7 @@ int traceprobe_update_arg(struct probe_arg *arg)
 			if (tmp)
 				*tmp = c;
 			if (!code[1].immediate)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			code[1].immediate += offset;
 		}
 		code++;
@@ -1080,7 +1080,7 @@ int trace_probe_remove_file(struct trace_probe *tp,
 
 	link = trace_probe_get_file_link(tp, file);
 	if (!link)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_del_rcu(&link->list);
 	synchronize_rcu();
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index c41c3c17b..2783139ab 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -1301,7 +1301,7 @@ static int try_to_grab_pending(struct work_struct *work, bool is_dwork,
 	rcu_read_unlock();
 	local_irq_restore(*flags);
 	if (work_is_canceling(work))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	cpu_relax();
 	return -EAGAIN;
 }
diff --git a/lib/bootconfig.c b/lib/bootconfig.c
index 912ef4921..cd3ec978e 100644
--- a/lib/bootconfig.c
+++ b/lib/bootconfig.c
@@ -674,7 +674,7 @@ static int __init xbc_verify_tree(void)
 	/* Empty tree */
 	if (xbc_node_num == 0) {
 		xbc_parse_error("Empty config", xbc_data);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 0; i < xbc_node_num; i++) {
diff --git a/lib/btree.c b/lib/btree.c
index b4cf08a5c..54f38550f 100644
--- a/lib/btree.c
+++ b/lib/btree.c
@@ -275,28 +275,28 @@ int btree_update(struct btree_head *head, struct btree_geo *geo,
 	unsigned long *node = head->node;
 
 	if (height == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for ( ; height > 1; height--) {
 		for (i = 0; i < geo->no_pairs; i++)
 			if (keycmp(geo, node, i, key) <= 0)
 				break;
 		if (i == geo->no_pairs)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		node = bval(geo, node, i);
 		if (!node)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < geo->no_pairs; i++)
 		if (keycmp(geo, node, i, key) == 0) {
 			setval(geo, node, i, val);
 			return 0;
 		}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL_GPL(btree_update);
 
diff --git a/lib/kobject.c b/lib/kobject.c
index 1e4b7382a..379f3e213 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -228,7 +228,7 @@ static int kobject_add_internal(struct kobject *kobj)
 	struct kobject *parent;
 
 	if (!kobj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!kobj->name || !kobj->name[0]) {
 		WARN(1,
diff --git a/lib/kunit/test.c b/lib/kunit/test.c
index ccb2ffad8..e017df52f 100644
--- a/lib/kunit/test.c
+++ b/lib/kunit/test.c
@@ -484,7 +484,7 @@ int kunit_resource_destroy(struct kunit *test,
 	resource = kunit_resource_remove(test, match, free, match_data);
 
 	if (!resource)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kunit_resource_free(test, resource);
 	return 0;
diff --git a/lib/objagg.c b/lib/objagg.c
index 5e1676ccd..6b55e6adf 100644
--- a/lib/objagg.c
+++ b/lib/objagg.c
@@ -202,7 +202,7 @@ static int objagg_obj_parent_lookup_assign(struct objagg *objagg,
 		if (!err)
 			return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void __objagg_obj_put(struct objagg *objagg,
diff --git a/lib/test_hmm.c b/lib/test_hmm.c
index a2a82262b..a2642edeb 100644
--- a/lib/test_hmm.c
+++ b/lib/test_hmm.c
@@ -319,7 +319,7 @@ static int dmirror_do_read(struct dmirror *dmirror, unsigned long start,
 		entry = xa_load(&dmirror->pt, pfn);
 		page = xa_untag_pointer(entry);
 		if (!page)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		tmp = kmap(page);
 		memcpy(ptr, tmp, PAGE_SIZE);
@@ -388,7 +388,7 @@ static int dmirror_do_write(struct dmirror *dmirror, unsigned long start,
 		entry = xa_load(&dmirror->pt, pfn);
 		page = xa_untag_pointer(entry);
 		if (!page || xa_pointer_tag(entry) != DPT_XA_TAG_WRITE)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		tmp = kmap(page);
 		memcpy(tmp, ptr, PAGE_SIZE);
diff --git a/lib/test_rhashtable.c b/lib/test_rhashtable.c
index c5a6fef7b..0b470dbce 100644
--- a/lib/test_rhashtable.c
+++ b/lib/test_rhashtable.c
@@ -153,7 +153,7 @@ static int __init test_rht_lookup(struct rhashtable *ht, struct test_obj *array,
 
 		if (expected && !obj) {
 			pr_warn("Test failed: Could not find key %u\n", key.id);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		} else if (!expected && obj) {
 			pr_warn("Test failed: Unexpected entry found for key %u\n",
 				key.id);
diff --git a/mm/gup.c b/mm/gup.c
index 0d01daf67..34ccb22a6 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -868,7 +868,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 
 	/* mlock all present pages, but do not fault in new pages */
 	if ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (*flags & FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (*flags & FOLL_REMOTE)
diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index da374cd3d..5433b99ff 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -1253,7 +1253,7 @@ static int scan_movable_pages(unsigned long start, unsigned long end,
 		skip = compound_nr(head) - (page - head);
 		pfn += skip - 1;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 found:
 	*movable_pfn = pfn;
 	return 0;
diff --git a/mm/shmem.c b/mm/shmem.c
index 8f4484199..f8f3c5ea9 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -359,7 +359,7 @@ static int shmem_replace_entry(struct address_space *mapping,
 	VM_BUG_ON(!replacement);
 	item = xas_load(&xas);
 	if (item != expected)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	xas_store(&xas, replacement);
 	return 0;
 }
@@ -703,7 +703,7 @@ static int shmem_free_swap(struct address_space *mapping,
 
 	old = xa_cmpxchg_irq(&mapping->i_pages, index, radswap, NULL, 0);
 	if (old != radswap)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	free_swap_and_cache(radix_to_swp_entry(radswap));
 	return 0;
 }
@@ -2324,7 +2324,7 @@ static int shmem_mfill_atomic_pte(struct mm_struct *dst_mm,
 				*pagep = page;
 				shmem_inode_unacct_blocks(inode, 1);
 				/* don't free the page */
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		} else {		/* mfill_zeropage_atomic */
 			clear_highpage(page);
diff --git a/mm/z3fold.c b/mm/z3fold.c
index 8da6733ad..73ecc261d 100644
--- a/mm/z3fold.c
+++ b/mm/z3fold.c
@@ -1707,7 +1707,7 @@ static int z3fold_zpool_evict(struct z3fold_pool *pool, unsigned long handle)
 	if (pool->zpool && pool->zpool_ops && pool->zpool_ops->evict)
 		return pool->zpool_ops->evict(pool->zpool, handle);
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct z3fold_ops z3fold_zpool_ops = {
diff --git a/mm/zbud.c b/mm/zbud.c
index 8bf19bcc5..ec62fbbe7 100644
--- a/mm/zbud.c
+++ b/mm/zbud.c
@@ -133,7 +133,7 @@ static int zbud_zpool_evict(struct zbud_pool *pool, unsigned long handle)
 	if (pool->zpool && pool->zpool_ops && pool->zpool_ops->evict)
 		return pool->zpool_ops->evict(pool->zpool, handle);
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct zbud_ops zbud_zpool_ops = {
diff --git a/mm/zswap.c b/mm/zswap.c
index 220d21791..8f6879f53 100644
--- a/mm/zswap.c
+++ b/mm/zswap.c
@@ -721,13 +721,13 @@ static int __zswap_param_set(const char *val, const struct kernel_param *kp,
 	if (!type) {
 		if (!zpool_has_pool(s)) {
 			pr_err("zpool %s not available\n", s);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		type = s;
 	} else if (!compressor) {
 		if (!crypto_has_comp(s, 0, 0)) {
 			pr_err("compressor %s not available\n", s);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		compressor = s;
 	} else {
diff --git a/net/6lowpan/nhc.c b/net/6lowpan/nhc.c
index d6bbbd4ab..5746befa5 100644
--- a/net/6lowpan/nhc.c
+++ b/net/6lowpan/nhc.c
@@ -176,7 +176,7 @@ int lowpan_nhc_do_uncompression(struct sk_buff *skb,
 	} else {
 		spin_unlock_bh(&lowpan_nhc_lock);
 		netdev_warn(dev, "received unknown nhc id which was not found.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	hdr->nexthdr = nhc->nexthdr;
diff --git a/net/atm/addr.c b/net/atm/addr.c
index 0530b63f5..42aaf7e1a 100644
--- a/net/atm/addr.c
+++ b/net/atm/addr.c
@@ -127,7 +127,7 @@ int atm_del_addr(struct atm_dev *dev, const struct sockaddr_atmsvc *addr,
 		}
 	}
 	spin_unlock_irqrestore(&dev->lock, flags);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int atm_get_addr(struct atm_dev *dev, struct sockaddr_atmsvc __user * buf,
diff --git a/net/ax25/ax25_uid.c b/net/ax25/ax25_uid.c
index 241e4680e..a0d5aa54d 100644
--- a/net/ax25/ax25_uid.c
+++ b/net/ax25/ax25_uid.c
@@ -126,7 +126,7 @@ int ax25_uid_ioctl(int cmd, struct sockaddr_ax25 *sax)
 		}
 		if (ax25_uid == NULL) {
 			write_unlock(&ax25_uid_lock);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		hlist_del_init(&ax25_uid->uid_node);
 		ax25_uid_put(ax25_uid);
diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
index 02ed073f9..3a2a4e2a5 100644
--- a/net/batman-adv/netlink.c
+++ b/net/batman-adv/netlink.c
@@ -205,7 +205,7 @@ static int batadv_netlink_set_mesh_ap_isolation(struct nlattr *attr,
 
 	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
 	if (!vlan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	atomic_set(&vlan->ap_isolation, !!nla_get_u8(attr));
 	batadv_softif_vlan_put(vlan);
diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f1f1c86f3..c14f1aaf7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -730,7 +730,7 @@ static int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,
 
 	vlan = batadv_softif_vlan_get(bat_priv, vid | BATADV_VLAN_HAS_TAG);
 	if (!vlan)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	batadv_softif_destroy_vlan(bat_priv, vlan);
 
diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
index 0f962dcd2..9474dc90f 100644
--- a/net/batman-adv/sysfs.c
+++ b/net/batman-adv/sysfs.c
@@ -463,7 +463,7 @@ static ssize_t batadv_show_gw_mode(struct kobject *kobj, struct attribute *attr,
 	 */
 	if (!bat_priv->algo_ops->gw.get_best_gw_node ||
 	    !bat_priv->algo_ops->gw.is_eligible)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (atomic_read(&bat_priv->gw.mode)) {
 	case BATADV_GW_MODE_CLIENT:
@@ -575,7 +575,7 @@ static ssize_t batadv_show_gw_sel_class(struct kobject *kobj,
 	 */
 	if (!bat_priv->algo_ops->gw.get_best_gw_node ||
 	    !bat_priv->algo_ops->gw.is_eligible)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (bat_priv->algo_ops->gw.show_sel_class)
 		return bat_priv->algo_ops->gw.show_sel_class(bat_priv, buff);
diff --git a/net/bluetooth/6lowpan.c b/net/bluetooth/6lowpan.c
index bb55d9269..943d96280 100644
--- a/net/bluetooth/6lowpan.c
+++ b/net/bluetooth/6lowpan.c
@@ -377,11 +377,11 @@ static int chan_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)
 
 	peer = lookup_peer(chan->conn);
 	if (!peer)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dev = lookup_dev(chan->conn);
 	if (!dev || !dev->netdev)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = recv_pkt(skb, dev->netdev, peer);
 	if (err) {
@@ -422,7 +422,7 @@ static int setup_header(struct sk_buff *skb, struct net_device *netdev,
 		peer = peer_lookup_dst(dev, &ipv6_daddr, skb);
 		if (!peer) {
 			BT_DBG("no such peer");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		daddr = peer->lladdr;
@@ -946,7 +946,7 @@ static int bt_6lowpan_disconnect(struct l2cap_conn *conn, u8 dst_type)
 
 	peer = lookup_peer(conn);
 	if (!peer)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	BT_DBG("peer %p chan %p", peer, peer->chan);
 
@@ -1004,14 +1004,14 @@ static int get_l2cap_conn(char *buf, bdaddr_t *addr, u8 *addr_type,
 	/* The LE_PUBLIC address type is ignored because of BDADDR_ANY */
 	hdev = hci_get_route(addr, BDADDR_ANY, BDADDR_LE_PUBLIC);
 	if (!hdev)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hci_dev_lock(hdev);
 	hcon = hci_conn_hash_lookup_le(hdev, addr, *addr_type);
 	hci_dev_unlock(hdev);
 
 	if (!hcon)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*conn = (struct l2cap_conn *)hcon->l2cap_data;
 
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 307800fd1..3552566bc 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1652,7 +1652,7 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
 	hci_dev_unlock(hdev);
 
 	if (!conn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;
 }
@@ -1672,7 +1672,7 @@ int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
 	hci_dev_unlock(hdev);
 
 	if (!conn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
 }
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index dbe2d79f2..59b64101b 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -2650,7 +2650,7 @@ int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
 
 	key = hci_find_link_key(hdev, bdaddr);
 	if (!key)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	BT_DBG("%s removing %pMR", hdev->name, bdaddr);
 
@@ -2775,7 +2775,7 @@ int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
 
 	data = hci_find_remote_oob_data(hdev, bdaddr, bdaddr_type);
 	if (!data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	BT_DBG("%s removing %pMR (%u)", hdev->name, bdaddr, bdaddr_type);
 
@@ -2878,7 +2878,7 @@ int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance)
 
 	adv_instance = hci_find_adv_instance(hdev, instance);
 	if (!adv_instance)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	BT_DBG("%s removing %dMR", hdev->name, instance);
 
@@ -3095,7 +3095,7 @@ int hci_bdaddr_list_del(struct list_head *list, bdaddr_t *bdaddr, u8 type)
 
 	entry = hci_bdaddr_list_lookup(list, bdaddr, type);
 	if (!entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_del(&entry->list);
 	kfree(entry);
@@ -3115,7 +3115,7 @@ int hci_bdaddr_list_del_with_irk(struct list_head *list, bdaddr_t *bdaddr,
 
 	entry = hci_bdaddr_list_lookup_with_irk(list, bdaddr, type);
 	if (!entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_del(&entry->list);
 	kfree(entry);
diff --git a/net/bluetooth/hci_request.c b/net/bluetooth/hci_request.c
index 1fc55685d..4f6ab9e1d 100644
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@ -1966,7 +1966,7 @@ int __hci_req_schedule_adv_instance(struct hci_request *req, u8 instance,
 
 	adv_instance = hci_find_adv_instance(hdev, instance);
 	if (!adv_instance)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* A zero timeout means unlimited advertising. As long as there is
 	 * only one instance, duration should be ignored. We still set a timeout
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index 3b4fa27a4..4630b1335 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -1399,7 +1399,7 @@ int hidp_connection_del(struct hidp_conndel_req *req)
 
 	session = hidp_session_find(&req->bdaddr);
 	if (!session)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (req->flags & BIT(HIDP_VIRTUAL_CABLE_UNPLUG))
 		hidp_send_ctrl_message(session,
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 9e8a3cccc..24b718279 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -7847,7 +7847,7 @@ static int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 
 	cmd = pending_find(opcode, hdev);
 	if (!cmd)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cmd->cmd_complete(cmd, mgmt_status(status));
 	mgmt_pending_remove(cmd);
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 4877a0db1..64ad65c1c 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -818,7 +818,7 @@ static int fdb_add_entry(struct net_bridge *br, struct net_bridge_port *source,
 	fdb = br_fdb_find(br, addr, vid);
 	if (fdb == NULL) {
 		if (!(flags & NLM_F_CREATE))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		fdb = fdb_create(br, source, addr, vid, 0);
 		if (!fdb)
@@ -978,7 +978,7 @@ static int fdb_delete_by_addr_and_port(struct net_bridge *br,
 
 	fdb = br_fdb_find(br, addr, vlan);
 	if (!fdb || fdb->dst != p)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	fdb_delete(br, fdb, true);
 
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index a0e9a7937..3f13b541a 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -176,7 +176,7 @@ int nbp_backup_change(struct net_bridge_port *p,
 
 	if (backup_dev) {
 		if (!netif_is_bridge_port(backup_dev))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		backup_p = br_port_get_rtnl(backup_dev);
 		if (backup_p->br != p->br)
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index 240e260e3..6460d68be 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -868,7 +868,7 @@ static int br_setport(struct net_bridge_port *p, struct nlattr *tb[])
 			backup_dev = __dev_get_by_index(dev_net(p->dev),
 							backup_ifindex);
 			if (!backup_dev)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		err = nbp_backup_change(p, backup_dev);
diff --git a/net/bridge/br_sysfs_if.c b/net/bridge/br_sysfs_if.c
index 7a59cdddd..4a1d67079 100644
--- a/net/bridge/br_sysfs_if.c
+++ b/net/bridge/br_sysfs_if.c
@@ -212,7 +212,7 @@ static int store_backup_port(struct net_bridge_port *p, char *buf)
 	if (strlen(buf) > 0) {
 		backup_dev = __dev_get_by_name(dev_net(p->dev), buf);
 		if (!backup_dev)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return nbp_backup_change(p, backup_dev);
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index f9092c712..055647f51 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -743,7 +743,7 @@ int br_vlan_delete(struct net_bridge *br, u16 vid)
 	vg = br_vlan_group(br);
 	v = br_vlan_find(vg, vid);
 	if (!v || !br_vlan_is_brentry(v))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	br_fdb_find_delete_local(br, NULL, br->dev->dev_addr, vid);
 	br_fdb_delete_by_port(br, NULL, vid, 0);
@@ -1241,7 +1241,7 @@ int nbp_vlan_delete(struct net_bridge_port *port, u16 vid)
 
 	v = br_vlan_find(nbp_vlan_group(port), vid);
 	if (!v)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	br_fdb_find_delete_local(port->br, port, port->dev->dev_addr, vid);
 	br_fdb_delete_by_port(port->br, port, vid, 0);
 
@@ -1336,7 +1336,7 @@ int br_vlan_get_info(const struct net_device *dev, u16 vid,
 
 	v = br_vlan_find(vg, vid);
 	if (!v)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	p_vinfo->vid = vid;
 	p_vinfo->flags = v->flags;
diff --git a/net/bridge/br_vlan_options.c b/net/bridge/br_vlan_options.c
index b4add9ea8..e4da2374a 100644
--- a/net/bridge/br_vlan_options.c
+++ b/net/bridge/br_vlan_options.c
@@ -128,14 +128,14 @@ static int br_vlan_modify_tunnel(const struct net_bridge_port *p,
 
 	if (!tun_tb[BRIDGE_VLANDB_TINFO_CMD]) {
 		NL_SET_ERR_MSG_MOD(extack, "Missing tunnel command attribute");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	cmd = nla_get_u32(tun_tb[BRIDGE_VLANDB_TINFO_CMD]);
 	switch (cmd) {
 	case RTM_SETLINK:
 		if (!tun_tb[BRIDGE_VLANDB_TINFO_ID]) {
 			NL_SET_ERR_MSG_MOD(extack, "Missing tunnel id attribute");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		/* when working on vlan ranges this is the starting tunnel id */
 		tun_id = nla_get_u32(tun_tb[BRIDGE_VLANDB_TINFO_ID]);
@@ -203,11 +203,11 @@ int br_vlan_process_options(const struct net_bridge *br,
 
 	if (!range_start || !br_vlan_should_use(range_start)) {
 		NL_SET_ERR_MSG_MOD(extack, "Vlan range start doesn't exist, can't process options");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (!range_end || !br_vlan_should_use(range_end)) {
 		NL_SET_ERR_MSG_MOD(extack, "Vlan range end doesn't exist, can't process options");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pvid = br_get_pvid(vg);
diff --git a/net/bridge/br_vlan_tunnel.c b/net/bridge/br_vlan_tunnel.c
index 169e005fb..b9ccd078a 100644
--- a/net/bridge/br_vlan_tunnel.c
+++ b/net/bridge/br_vlan_tunnel.c
@@ -118,7 +118,7 @@ int nbp_vlan_tunnel_info_delete(const struct net_bridge_port *port, u16 vid)
 	vg = nbp_vlan_group(port);
 	v = br_vlan_find(vg, vid);
 	if (!v)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	vlan_tunnel_info_del(vg, v);
 
diff --git a/net/bridge/netfilter/ebtables.c b/net/bridge/netfilter/ebtables.c
index c83ffe912..25b0a7534 100644
--- a/net/bridge/netfilter/ebtables.c
+++ b/net/bridge/netfilter/ebtables.c
@@ -406,7 +406,7 @@ ebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,
 
 	if (watcher->family != NFPROTO_BRIDGE) {
 		module_put(watcher->me);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	w->u.watcher = watcher;
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 9f99af5b0..fb0557ffa 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -863,7 +863,7 @@ static int j1939_session_tx_cts(struct j1939_session *session)
 	u8 dat[8];
 
 	if (!j1939_sk_recv_match(priv, &session->skcb))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	len = session->pkt.total - session->pkt.rx;
 	len = min3(len, session->pkt.block, j1939_tp_block ?: 255);
@@ -907,7 +907,7 @@ static int j1939_session_tx_eoma(struct j1939_session *session)
 	int ret;
 
 	if (!j1939_sk_recv_match(priv, &session->skcb))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memset(dat, 0xff, sizeof(dat));
 
diff --git a/net/ceph/auth.c b/net/ceph/auth.c
index fbeee068e..3e56a8017 100644
--- a/net/ceph/auth.c
+++ b/net/ceph/auth.c
@@ -29,7 +29,7 @@ static int ceph_auth_init_protocol(struct ceph_auth_client *ac, int protocol)
 	case CEPH_AUTH_CEPHX:
 		return ceph_x_init(ac);
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c
index 27d6ab11f..dab1b2b4a 100644
--- a/net/ceph/messenger.c
+++ b/net/ceph/messenger.c
@@ -2808,7 +2808,7 @@ static int queue_con_delay(struct ceph_connection *con, unsigned long delay)
 {
 	if (!con->ops->get(con)) {
 		dout("%s %p ref count 0\n", __func__, con);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!queue_delayed_work(ceph_msgr_wq, &con->work, delay)) {
diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c
index 96c25f5e0..3e36f3be9 100644
--- a/net/ceph/osdmap.c
+++ b/net/ceph/osdmap.c
@@ -749,7 +749,7 @@ int ceph_pg_poolid_by_name(struct ceph_osdmap *map, const char *name)
 		if (pi->name && strcmp(pi->name, name) == 0)
 			return pi->id;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(ceph_pg_poolid_by_name);
 
@@ -2262,7 +2262,7 @@ int ceph_object_locator_to_pg(struct ceph_osdmap *osdmap,
 
 	pi = ceph_pg_pool_by_id(osdmap, oloc->pool);
 	if (!pi)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	__ceph_object_locator_to_pg(pi, oid, oloc, raw_pgid);
 	return 0;
diff --git a/net/core/bpf_sk_storage.c b/net/core/bpf_sk_storage.c
index d2c4d16da..2dc791646 100644
--- a/net/core/bpf_sk_storage.c
+++ b/net/core/bpf_sk_storage.c
@@ -319,7 +319,7 @@ static int check_flags(const struct bpf_sk_storage_data *old_sdata,
 
 	if (!old_sdata && (map_flags & ~BPF_F_LOCK) == BPF_EXIST)
 		/* elem doesn't exist, cannot update it */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -505,7 +505,7 @@ static int sk_storage_delete(struct sock *sk, struct bpf_map *map)
 
 	sdata = sk_storage_lookup(sk, map, false);
 	if (!sdata)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	selem_unlink(SELEM(sdata));
 
@@ -883,7 +883,7 @@ BPF_CALL_2(bpf_sk_storage_delete, struct bpf_map *, map, struct sock *, sk)
 		return err;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 const struct bpf_map_ops sk_storage_map_ops = {
diff --git a/net/core/dev.c b/net/core/dev.c
index 7a774ebf6..09efafd1b 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -330,7 +330,7 @@ int netdev_name_node_alt_destroy(struct net_device *dev, const char *name)
 
 	name_node = netdev_name_node_lookup(net, name);
 	if (!name_node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/* lookup might have found our primary name or a name belonging
 	 * to another device.
 	 */
diff --git a/net/core/dev_addr_lists.c b/net/core/dev_addr_lists.c
index 54cd568e7..bfd323ff1 100644
--- a/net/core/dev_addr_lists.c
+++ b/net/core/dev_addr_lists.c
@@ -90,10 +90,10 @@ static int __hw_addr_del_entry(struct netdev_hw_addr_list *list,
 			       bool sync)
 {
 	if (global && !ha->global_use)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (sync && !ha->synced)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (global)
 		ha->global_use = false;
@@ -120,7 +120,7 @@ static int __hw_addr_del_ex(struct netdev_hw_addr_list *list,
 		    (ha->type == addr_type || !addr_type))
 			return __hw_addr_del_entry(list, ha, global, sync);
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int __hw_addr_del(struct netdev_hw_addr_list *list,
@@ -531,7 +531,7 @@ int dev_addr_del(struct net_device *dev, const unsigned char *addr,
 			      struct netdev_hw_addr, list);
 	if (!memcmp(ha->addr, addr, dev->addr_len) &&
 	    ha->type == addr_type && ha->refcount == 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = __hw_addr_del(&dev->dev_addrs, addr, dev->addr_len,
 			    addr_type);
diff --git a/net/core/devlink.c b/net/core/devlink.c
index 2cafbc808..75396a159 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -3019,7 +3019,7 @@ static int devlink_param_generic_verify(const struct devlink_param *param)
 	if (param->id > DEVLINK_PARAM_GENERIC_ID_MAX)
 		return -EINVAL;
 	if (strcmp(param->name, devlink_param_generic[param->id].name))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	WARN_ON(param->type != devlink_param_generic[param->id].type);
 
@@ -6022,7 +6022,7 @@ static int devlink_nl_cmd_trap_get_doit(struct sk_buff *skb,
 	trap_item = devlink_trap_item_get_from_info(devlink, info);
 	if (!trap_item) {
 		NL_SET_ERR_MSG_MOD(extack, "Device did not register this trap");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
@@ -6138,7 +6138,7 @@ static int devlink_nl_cmd_trap_set_doit(struct sk_buff *skb,
 	trap_item = devlink_trap_item_get_from_info(devlink, info);
 	if (!trap_item) {
 		NL_SET_ERR_MSG_MOD(extack, "Device did not register this trap");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = devlink_trap_action_set(devlink, trap_item, info);
@@ -6244,7 +6244,7 @@ static int devlink_nl_cmd_trap_group_get_doit(struct sk_buff *skb,
 	group_item = devlink_trap_group_item_get_from_info(devlink, info);
 	if (!group_item) {
 		NL_SET_ERR_MSG_MOD(extack, "Device did not register this trap group");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
@@ -6380,7 +6380,7 @@ static int devlink_trap_group_set(struct devlink *devlink,
 								policer_id);
 		if (policer_id && !policer_item) {
 			NL_SET_ERR_MSG_MOD(extack, "Device did not register this trap policer");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	policer = policer_item ? policer_item->policer : NULL;
@@ -6409,7 +6409,7 @@ static int devlink_nl_cmd_trap_group_set_doit(struct sk_buff *skb,
 	group_item = devlink_trap_group_item_get_from_info(devlink, info);
 	if (!group_item) {
 		NL_SET_ERR_MSG_MOD(extack, "Device did not register this trap group");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = devlink_trap_group_action_set(devlink, group_item, info,
@@ -6531,7 +6531,7 @@ static int devlink_nl_cmd_trap_policer_get_doit(struct sk_buff *skb,
 	policer_item = devlink_trap_policer_item_get_from_info(devlink, info);
 	if (!policer_item) {
 		NL_SET_ERR_MSG_MOD(extack, "Device did not register this trap policer");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
@@ -6659,7 +6659,7 @@ static int devlink_nl_cmd_trap_policer_set_doit(struct sk_buff *skb,
 	policer_item = devlink_trap_policer_item_get_from_info(devlink, info);
 	if (!policer_item) {
 		NL_SET_ERR_MSG_MOD(extack, "Device did not register this trap policer");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return devlink_trap_policer_set(devlink, policer_item, info);
diff --git a/net/core/filter.c b/net/core/filter.c
index 82e1b5b06..4910f5795 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -4033,7 +4033,7 @@ BPF_CALL_3(bpf_skb_under_cgroup, struct sk_buff *, skb, struct bpf_map *, map,
 
 	sk = skb_to_full_sk(skb);
 	if (!sk || !sk_fullsock(sk))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (unlikely(idx >= array->map.max_entries))
 		return -E2BIG;
 
@@ -5938,10 +5938,10 @@ BPF_CALL_5(bpf_tcp_check_syncookie, struct sock *, sk, void *, iph, u32, iph_len
 		return -EINVAL;
 
 	if (!th->ack || th->rst || th->syn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (tcp_synq_no_recent_overflow(sk))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	cookie = ntohl(th->ack_seq) - 1;
 
@@ -5969,7 +5969,7 @@ BPF_CALL_5(bpf_tcp_check_syncookie, struct sock *, sk, void *, iph, u32, iph_len
 	if (ret > 0)
 		return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 #else
 	return -ENOTSUPP;
 #endif
@@ -6001,7 +6001,7 @@ BPF_CALL_5(bpf_tcp_gen_syncookie, struct sock *, sk, void *, iph, u32, iph_len,
 		return -EINVAL;
 
 	if (!sock_net(sk)->ipv4.sysctl_tcp_syncookies)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!th->syn || th->ack || th->fin || th->rst)
 		return -EINVAL;
@@ -6036,7 +6036,7 @@ BPF_CALL_5(bpf_tcp_gen_syncookie, struct sock *, sk, void *, iph, u32, iph_len,
 		return -EPROTONOSUPPORT;
 	}
 	if (mss == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return cookie | ((u64)mss << 32);
 #else
@@ -6068,7 +6068,7 @@ BPF_CALL_3(bpf_sk_assign, struct sk_buff *, skb, struct sock *, sk, u64, flags)
 		return -ESOCKTNOSUPPORT;
 	if (sk_is_refcounted(sk) &&
 	    unlikely(!refcount_inc_not_zero(&sk->sk_refcnt)))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	skb_orphan(skb);
 	skb->sk = sk;
@@ -8981,7 +8981,7 @@ BPF_CALL_4(sk_select_reuseport, struct sk_reuseport_kern *, reuse_kern,
 
 	selected_sk = map->ops->map_lookup_elem(map, key);
 	if (!selected_sk)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	reuse = rcu_dereference(selected_sk->sk_reuseport_cb);
 	if (!reuse) {
diff --git a/net/core/flow_offload.c b/net/core/flow_offload.c
index 2076219b8..de56fd172 100644
--- a/net/core/flow_offload.c
+++ b/net/core/flow_offload.c
@@ -307,7 +307,7 @@ int flow_block_cb_setup_simple(struct flow_block_offload *f,
 	case FLOW_BLOCK_UNBIND:
 		block_cb = flow_block_cb_lookup(f->block, cb, cb_ident);
 		if (!block_cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		flow_block_cb_remove(block_cb, f);
 		list_del(&block_cb->driver_list);
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index ef6b5a8f6..66b216acb 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -779,7 +779,7 @@ int pneigh_delete(struct neigh_table *tbl, struct net *net, const void *pkey,
 		}
 	}
 	write_unlock_bh(&tbl->lock);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int pneigh_ifdown_and_unlock(struct neigh_table *tbl,
@@ -810,7 +810,7 @@ static int pneigh_ifdown_and_unlock(struct neigh_table *tbl,
 			dev_put(n->dev);
 		kfree(n);
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void neigh_parms_destroy(struct neigh_parms *parms);
@@ -2211,7 +2211,7 @@ static int neightbl_set(struct sk_buff *skb, struct nlmsghdr *nlh,
 	}
 
 	if (!found)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * We acquire tbl->lock to be nice to the periodic timers and
@@ -2900,7 +2900,7 @@ static int neigh_get(struct sk_buff *in_skb, struct nlmsghdr *nlh,
 		pn = pneigh_lookup(tbl, net, dst, dev, 0);
 		if (!pn) {
 			NL_SET_ERR_MSG(extack, "Proxy neighbour entry not found");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		return pneigh_get_reply(net, pn, NETLINK_CB(in_skb).portid,
 					nlh->nlmsg_seq, tbl);
@@ -2914,7 +2914,7 @@ static int neigh_get(struct sk_buff *in_skb, struct nlmsghdr *nlh,
 	neigh = neigh_lookup(tbl, dst, dev);
 	if (!neigh) {
 		NL_SET_ERR_MSG(extack, "Neighbour entry not found");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = neigh_get_reply(net, neigh, NETLINK_CB(in_skb).portid,
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index 7bd6440c6..bedea76bd 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -1130,7 +1130,7 @@ static ssize_t traffic_class_show(struct netdev_queue *queue,
 	int tc;
 
 	if (!netif_is_multiqueue(dev))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	index = get_netdev_queue_index(queue);
 
@@ -1314,7 +1314,7 @@ static ssize_t xps_cpus_show(struct netdev_queue *queue,
 	unsigned long index;
 
 	if (!netif_is_multiqueue(dev))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	index = get_netdev_queue_index(queue);
 
@@ -1370,7 +1370,7 @@ static ssize_t xps_cpus_store(struct netdev_queue *queue,
 	int err;
 
 	if (!netif_is_multiqueue(dev))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 85a4b0101..9efec5e0a 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -296,7 +296,7 @@ int rtnl_unregister(int protocol, int msgtype)
 	tab = rtnl_dereference(rtnl_msg_handlers[protocol]);
 	if (!tab) {
 		rtnl_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	link = tab[msgindex];
diff --git a/net/core/sock.c b/net/core/sock.c
index 2e5b7870e..9aa8e84ad 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -3123,7 +3123,7 @@ int sock_gettstamp(struct socket *sock, void __user *userstamp,
 	sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 	ts = ktime_to_timespec64(sock_read_timestamp(sk));
 	if (ts.tv_sec == -1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (ts.tv_sec == 0) {
 		ktime_t kt = ktime_get_real();
 		sock_write_timestamp(sk, kt);
@@ -3566,7 +3566,7 @@ int sock_load_diag_module(int family, int protocol)
 {
 	if (!protocol) {
 		if (!sock_is_registered(family))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		return request_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK,
 				      NETLINK_SOCK_DIAG, family);
@@ -3576,7 +3576,7 @@ int sock_load_diag_module(int family, int protocol)
 	if (family == AF_INET &&
 	    protocol != IPPROTO_RAW &&
 	    !rcu_access_pointer(inet_protos[protocol]))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 #endif
 
 	return request_module("net-pf-%d-proto-%d-type-%d-%d", PF_NETLINK,
diff --git a/net/core/sock_map.c b/net/core/sock_map.c
index 0971f17e8..227ee6185 100644
--- a/net/core/sock_map.c
+++ b/net/core/sock_map.c
@@ -454,7 +454,7 @@ static int sock_map_get_next_key(struct bpf_map *map, void *key, void *next)
 	u32 *key_next = next;
 
 	if (i == stab->map.max_entries - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (i >= stab->map.max_entries)
 		*key_next = 0;
 	else
@@ -988,7 +988,7 @@ static int sock_hash_get_next_key(struct bpf_map *map, void *key,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct bpf_map *sock_hash_alloc(union bpf_attr *attr)
diff --git a/net/core/sock_reuseport.c b/net/core/sock_reuseport.c
index bbdd3c7b6..daf7a281c 100644
--- a/net/core/sock_reuseport.c
+++ b/net/core/sock_reuseport.c
@@ -353,7 +353,7 @@ int reuseport_detach_prog(struct sock *sk)
 	spin_unlock_bh(&reuseport_lock);
 
 	if (!old_prog)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	sk_reuseport_prog_free(old_prog);
 	return 0;
diff --git a/net/dccp/ipv4.c b/net/dccp/ipv4.c
index d19557c6d..1fe2a0d48 100644
--- a/net/dccp/ipv4.c
+++ b/net/dccp/ipv4.c
@@ -255,7 +255,7 @@ static int dccp_v4_err(struct sk_buff *skb, u32 info)
 				       inet_iif(skb), 0);
 	if (!sk) {
 		__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (sk->sk_state == DCCP_TIME_WAIT) {
diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c
index 650187d68..81cb2ae7c 100644
--- a/net/dccp/ipv6.c
+++ b/net/dccp/ipv6.c
@@ -92,7 +92,7 @@ static int dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	if (!sk) {
 		__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),
 				  ICMP6_MIB_INERRORS);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (sk->sk_state == DCCP_TIME_WAIT) {
diff --git a/net/dsa/slave.c b/net/dsa/slave.c
index 4c7f086a0..7caf08285 100644
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -1140,7 +1140,7 @@ static int dsa_slave_setup_tc_block(struct net_device *dev,
 	case FLOW_BLOCK_UNBIND:
 		block_cb = flow_block_cb_lookup(f->block, cb, dev);
 		if (!block_cb)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		flow_block_cb_remove(block_cb, f);
 		list_del(&block_cb->driver_list);
diff --git a/net/ethtool/bitset.c b/net/ethtool/bitset.c
index dae7402ea..fe1f664d5 100644
--- a/net/ethtool/bitset.c
+++ b/net/ethtool/bitset.c
@@ -364,7 +364,7 @@ static int ethnl_name_to_idx(ethnl_string_array_t names, unsigned int n_names,
 	unsigned int i;
 
 	if (!names)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < n_names; i++) {
 		/* names[i] may not be null terminated */
@@ -373,7 +373,7 @@ static int ethnl_name_to_idx(ethnl_string_array_t names, unsigned int n_names,
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int ethnl_parse_bit(unsigned int *index, bool *val, unsigned int nbits,
diff --git a/net/hsr/hsr_framereg.c b/net/hsr/hsr_framereg.c
index 530de24b1..e6c950ade 100644
--- a/net/hsr/hsr_framereg.c
+++ b/net/hsr/hsr_framereg.c
@@ -486,7 +486,7 @@ int hsr_get_node_data(struct hsr_priv *hsr,
 
 	node = find_node_by_addr_A(&hsr->node_db, addr);
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ether_addr_copy(addr_b, node->macaddress_B);
 
diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index a23094b05..ef1360367 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -241,7 +241,7 @@ static int cipso_v4_cache_check(const unsigned char *key,
 	u32 hash;
 
 	if (!cipso_v4_cache_enabled)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hash = cipso_v4_map_cache_hash(key, key_len);
 	bkt = hash & (CIPSO_V4_CACHE_BUCKETS - 1);
@@ -278,7 +278,7 @@ static int cipso_v4_cache_check(const unsigned char *key,
 	}
 	spin_unlock_bh(&cipso_v4_cache[bkt].lock);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index 41079490a..a68adc753 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -994,7 +994,7 @@ static int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)
 				return skb->len;
 
 			NL_SET_ERR_MSG(cb->extack, "ipv4: FIB table does not exist");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		rcu_read_lock();
diff --git a/net/ipv4/fou.c b/net/ipv4/fou.c
index abd083415..791093317 100644
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@ -1121,7 +1121,7 @@ static int gue_err_proto_handler(int proto, struct sk_buff *skb, u32 info)
 			return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int gue_err(struct sk_buff *skb, u32 info)
@@ -1163,7 +1163,7 @@ static int gue_err(struct sk_buff *skb, u32 info)
 	}
 
 	if (guehdr->control)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	optlen = guehdr->hlen << 2;
 
diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index 2bbaaf0c7..8393616fd 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -139,7 +139,7 @@ int __inet_inherit_port(const struct sock *sk, struct sock *child)
 	tb = inet_csk(sk)->icsk_bind_hash;
 	if (unlikely(!tb)) {
 		spin_unlock(&head->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (tb->port != port) {
 		l3mdev = inet_sk_bound_l3mdev(sk);
diff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c
index 4e31f23e4..a60038d46 100644
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@ -154,7 +154,7 @@ static int ipgre_err(struct sk_buff *skb, u32 info,
 			     iph->daddr, iph->saddr, tpi->key);
 
 	if (!t)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (type) {
 	default:
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index f5c7a5884..b6a43ed63 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -1168,7 +1168,7 @@ static int ipmr_mfc_delete(struct mr_table *mrt, struct mfcctl *mfc, int parent)
 				   mfc->mfcc_mcastgrp.s_addr, parent);
 	rcu_read_unlock();
 	if (!c)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	rhltable_remove(&mrt->mfc_hash, &c->_c.mnode, ipmr_rht_params);
 	list_del_rcu(&c->_c.list);
 	call_ipmr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, c, mrt->id);
@@ -1544,7 +1544,7 @@ int ip_mroute_getsockopt(struct sock *sk, int optname, char __user *optval, int
 
 	mrt = ipmr_get_table(net, raw_sk(sk)->ipmr_table ? : RT_TABLE_DEFAULT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (optname) {
 	case MRT_VERSION:
@@ -1586,7 +1586,7 @@ int ipmr_ioctl(struct sock *sk, int cmd, void __user *arg)
 
 	mrt = ipmr_get_table(net, raw_sk(sk)->ipmr_table ? : RT_TABLE_DEFAULT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (cmd) {
 	case SIOCGETVIFCNT:
@@ -1661,7 +1661,7 @@ int ipmr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)
 
 	mrt = ipmr_get_table(net, raw_sk(sk)->ipmr_table ? : RT_TABLE_DEFAULT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (cmd) {
 	case SIOCGETVIFCNT:
@@ -2232,7 +2232,7 @@ int ipmr_get_route(struct net *net, struct sk_buff *skb,
 
 	mrt = ipmr_get_table(net, RT_TABLE_DEFAULT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rcu_read_lock();
 	cache = ipmr_cache_find(mrt, saddr, daddr);
@@ -2581,7 +2581,7 @@ static int ipmr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb)
 				return skb->len;
 
 			NL_SET_ERR_MSG(cb->extack, "ipv4: MR table does not exist");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		err = mr_table_dump(mrt, skb, cb, _ipmr_fill_mroute,
 				    &mfc_unres_lock, &filter);
diff --git a/net/ipv4/ipmr_base.c b/net/ipv4/ipmr_base.c
index aa8738a91..979a96e00 100644
--- a/net/ipv4/ipmr_base.c
+++ b/net/ipv4/ipmr_base.c
@@ -217,7 +217,7 @@ int mr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,
 	/* If cache is unresolved, don't try to parse IIF and OIF */
 	if (c->mfc_parent >= MAXVIFS) {
 		rtm->rtm_flags |= RTNH_F_UNRESOLVED;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (VIF_EXISTS(mrt, c->mfc_parent) &&
diff --git a/net/ipv4/netfilter/ipt_CLUSTERIP.c b/net/ipv4/netfilter/ipt_CLUSTERIP.c
index f8755a4ae..132f734ba 100644
--- a/net/ipv4/netfilter/ipt_CLUSTERIP.c
+++ b/net/ipv4/netfilter/ipt_CLUSTERIP.c
@@ -797,7 +797,7 @@ static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
 		if (rc)
 			return rc;
 		if (clusterip_del_node(c, nodenum))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else
 		return -EIO;
 
diff --git a/net/ipv4/nexthop.c b/net/ipv4/nexthop.c
index cc8049b10..eeb312422 100644
--- a/net/ipv4/nexthop.c
+++ b/net/ipv4/nexthop.c
@@ -1681,7 +1681,7 @@ static int rtm_del_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 	nh = nexthop_find_by_id(net, id);
 	if (!nh)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	remove_nexthop(net, nh, &nlinfo);
 
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 04bfcbbfe..931ce3a09 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -478,7 +478,7 @@ int tcp_v4_err(struct sk_buff *skb, u32 info)
 				       inet_iif(skb), 0);
 	if (!sk) {
 		__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (sk->sk_state == TCP_TIME_WAIT) {
 		inet_twsk_put(inet_twsk(sk));
@@ -1169,7 +1169,7 @@ int tcp_md5_do_del(struct sock *sk, const union tcp_md5_addr *addr, int family,
 
 	key = tcp_md5_do_lookup_exact(sk, addr, family, prefixlen, l3index);
 	if (!key)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	hlist_del_rcu(&key->node);
 	atomic_sub(sizeof(*key), &sk->sk_omem_alloc);
 	kfree_rcu(key, rcu);
diff --git a/net/ipv4/tcp_ulp.c b/net/ipv4/tcp_ulp.c
index 7c27aa629..858937a87 100644
--- a/net/ipv4/tcp_ulp.c
+++ b/net/ipv4/tcp_ulp.c
@@ -155,7 +155,7 @@ int tcp_set_ulp(struct sock *sk, const char *name)
 
 	ulp_ops = __tcp_ulp_find_autoload(name);
 	if (!ulp_ops)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return __tcp_set_ulp(sk, ulp_ops);
 }
diff --git a/net/ipv4/tunnel4.c b/net/ipv4/tunnel4.c
index c4b2ccbeb..1e51028de 100644
--- a/net/ipv4/tunnel4.c
+++ b/net/ipv4/tunnel4.c
@@ -158,7 +158,7 @@ static int tunnel4_err(struct sk_buff *skb, u32 info)
 		if (!handler->err_handler(skb, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #if IS_ENABLED(CONFIG_IPV6)
@@ -170,7 +170,7 @@ static int tunnel64_err(struct sk_buff *skb, u32 info)
 		if (!handler->err_handler(skb, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
@@ -183,7 +183,7 @@ static int tunnelmpls4_err(struct sk_buff *skb, u32 info)
 		if (!handler->err_handler(skb, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 4077d589b..daa1b9c28 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -565,7 +565,7 @@ static int __udp4_lib_err_encap_no_sk(struct sk_buff *skb, u32 info)
 			return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Try to match ICMP errors to UDP tunnels by looking up a socket without
diff --git a/net/ipv4/udp_diag.c b/net/ipv4/udp_diag.c
index 1dbece344..ced08bcaa 100644
--- a/net/ipv4/udp_diag.c
+++ b/net/ipv4/udp_diag.c
@@ -210,11 +210,11 @@ static int __udp_diag_destroy(struct sk_buff *in_skb,
 	rcu_read_unlock();
 
 	if (!sk)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (sock_diag_check_cookie(sk, req->id.idiag_cookie)) {
 		sock_put(sk);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = sock_diag_destroy(sk, ECONNABORTED);
diff --git a/net/ipv4/xfrm4_protocol.c b/net/ipv4/xfrm4_protocol.c
index ea595c854..d36a147c6 100644
--- a/net/ipv4/xfrm4_protocol.c
+++ b/net/ipv4/xfrm4_protocol.c
@@ -118,7 +118,7 @@ static int xfrm4_esp_err(struct sk_buff *skb, u32 info)
 		if (!handler->err_handler(skb, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int xfrm4_ah_rcv(struct sk_buff *skb)
@@ -146,7 +146,7 @@ static int xfrm4_ah_err(struct sk_buff *skb, u32 info)
 		if (!handler->err_handler(skb, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int xfrm4_ipcomp_rcv(struct sk_buff *skb)
@@ -174,7 +174,7 @@ static int xfrm4_ipcomp_err(struct sk_buff *skb, u32 info)
 		if (!handler->err_handler(skb, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct net_protocol esp4_protocol = {
diff --git a/net/ipv4/xfrm4_tunnel.c b/net/ipv4/xfrm4_tunnel.c
index dc19aff7c..ebec656a2 100644
--- a/net/ipv4/xfrm4_tunnel.c
+++ b/net/ipv4/xfrm4_tunnel.c
@@ -58,7 +58,7 @@ static int xfrm_tunnel_rcv(struct sk_buff *skb)
 
 static int xfrm_tunnel_err(struct sk_buff *skb, u32 info)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct xfrm_tunnel xfrm_tunnel_handler __read_mostly = {
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 840bfdb3d..df94b9c71 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -4619,7 +4619,7 @@ static int modify_prefix_route(struct inet6_ifaddr *ifp,
 					ifp->prefix_len,
 					ifp->idev->dev, 0, RTF_DEFAULT, true);
 	if (!f6i)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	prio = ifp->rt_priority ? : IP6_RT_PRIO_ADDRCONF;
 	if (f6i->fib6_metric != prio) {
diff --git a/net/ipv6/anycast.c b/net/ipv6/anycast.c
index 893261230..2bf4e79d5 100644
--- a/net/ipv6/anycast.c
+++ b/net/ipv6/anycast.c
@@ -169,7 +169,7 @@ int ipv6_sock_ac_drop(struct sock *sk, int ifindex, const struct in6_addr *addr)
 		prev_pac = pac;
 	}
 	if (!pac)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (prev_pac)
 		prev_pac->acl_next = pac->acl_next;
 	else
@@ -350,7 +350,7 @@ int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr)
 	}
 	if (!aca) {
 		write_unlock_bh(&idev->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (--aca->aca_users > 0) {
 		write_unlock_bh(&idev->lock);
diff --git a/net/ipv6/calipso.c b/net/ipv6/calipso.c
index 8d3f66c31..25ce02c04 100644
--- a/net/ipv6/calipso.c
+++ b/net/ipv6/calipso.c
@@ -203,7 +203,7 @@ static int calipso_cache_check(const unsigned char *key,
 	u32 hash;
 
 	if (!calipso_cache_enabled)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hash = calipso_map_cache_hash(key, key_len);
 	bkt = hash & (CALIPSO_CACHE_BUCKETS - 1);
@@ -240,7 +240,7 @@ static int calipso_cache_check(const unsigned char *key,
 	}
 	spin_unlock_bh(&calipso_cache[bkt].lock);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/net/ipv6/exthdrs_core.c b/net/ipv6/exthdrs_core.c
index da46c4284..69be535d7 100644
--- a/net/ipv6/exthdrs_core.c
+++ b/net/ipv6/exthdrs_core.c
@@ -211,7 +211,7 @@ int ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
 		if ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) {
 			if (target < 0 || found)
 				break;
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);
@@ -255,7 +255,7 @@ int ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
 					return hp->nexthdr;
 				}
 				if (!found)
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 				if (fragoff)
 					*fragoff = _frag_off;
 				break;
diff --git a/net/ipv6/fou6.c b/net/ipv6/fou6.c
index 430518ae2..92c7fdffb 100644
--- a/net/ipv6/fou6.c
+++ b/net/ipv6/fou6.c
@@ -83,7 +83,7 @@ static int gue6_err_proto_handler(int proto, struct sk_buff *skb,
 			return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
@@ -126,7 +126,7 @@ static int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	}
 
 	if (guehdr->control)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	optlen = guehdr->hlen << 2;
 
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 49ee89bbc..a8710fead 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -668,7 +668,7 @@ static int inet6_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)
 				goto out;
 
 			NL_SET_ERR_MSG_MOD(cb->extack, "FIB table does not exist");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (!cb->args[0]) {
@@ -1257,7 +1257,7 @@ static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,
 			if (add)
 				goto add;
 			pr_warn("NLM_F_REPLACE set, but no existing node found!\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (!info->skip_notify_kernel && ins == &fn->leaf) {
@@ -2000,7 +2000,7 @@ int fib6_del(struct fib6_info *rt, struct nl_info *info)
 	struct fib6_info __rcu **rtp_next;
 
 	if (!fn || rt == net->ipv6.fib6_null_entry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	WARN_ON(!(fn->fn_flags & RTN_RTINFO));
 
@@ -2019,7 +2019,7 @@ int fib6_del(struct fib6_info *rt, struct nl_info *info)
 		}
 		rtp_next = &cur->fib6_next;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /*
diff --git a/net/ipv6/ip6_flowlabel.c b/net/ipv6/ip6_flowlabel.c
index ce4fbba4a..e1ad1aaa7 100644
--- a/net/ipv6/ip6_flowlabel.c
+++ b/net/ipv6/ip6_flowlabel.c
@@ -530,7 +530,7 @@ int ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,
 	}
 	rcu_read_unlock_bh();
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int ipv6_flowlabel_opt(struct sock *sk, char __user *optval, int optlen)
diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c
index 3a57fb9ce..241de32a5 100644
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -437,7 +437,7 @@ static int ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,
 				 tpi.key, tpi.proto);
 	if (!t)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (type) {
 	case ICMPV6_DEST_UNREACH:
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index 1f4d20e97..a8859a1d4 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -1219,7 +1219,7 @@ static int ip6mr_mfc_delete(struct mr_table *mrt, struct mf6cctl *mfc,
 				    &mfc->mf6cc_mcastgrp.sin6_addr, parent);
 	rcu_read_unlock();
 	if (!c)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	rhltable_remove(&mrt->mfc_hash, &c->_c.mnode, ip6mr_rht_params);
 	list_del_rcu(&c->_c.list);
 
@@ -1644,7 +1644,7 @@ int ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, uns
 
 	mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (optname != MRT6_INIT) {
 		if (sk != rcu_access_pointer(mrt->mroute_sk) &&
@@ -1815,7 +1815,7 @@ int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,
 
 	mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (optname) {
 	case MRT6_VERSION:
@@ -1862,7 +1862,7 @@ int ip6mr_ioctl(struct sock *sk, int cmd, void __user *arg)
 
 	mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (cmd) {
 	case SIOCGETMIFCNT_IN6:
@@ -1937,7 +1937,7 @@ int ip6mr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)
 
 	mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	switch (cmd) {
 	case SIOCGETMIFCNT_IN6:
@@ -2262,7 +2262,7 @@ int ip6mr_get_route(struct net *net, struct sk_buff *skb, struct rtmsg *rtm,
 
 	mrt = ip6mr_get_table(net, RT6_TABLE_DFLT);
 	if (!mrt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	read_lock(&mrt_lock);
 	cache = ip6mr_cache_find(mrt, &rt->rt6i_src.addr, &rt->rt6i_dst.addr);
@@ -2507,7 +2507,7 @@ static int ip6mr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb)
 				return skb->len;
 
 			NL_SET_ERR_MSG_MOD(cb->extack, "MR table does not exist");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		err = mr_table_dump(mrt, skb, cb, _ip6mr_fill_mroute,
 				    &mfc_unres_lock, &filter);
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index 8cd2782a3..444fa7e3c 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -964,7 +964,7 @@ int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr)
 	}
 	write_unlock_bh(&idev->lock);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr)
diff --git a/net/ipv6/proc.c b/net/ipv6/proc.c
index bbff3e02e..6f0d9a7a3 100644
--- a/net/ipv6/proc.c
+++ b/net/ipv6/proc.c
@@ -249,7 +249,7 @@ int snmp6_register_dev(struct inet6_dev *idev)
 
 	net = dev_net(idev->dev);
 	if (!net->mib.proc_net_devsnmp6)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	p = proc_create_single_data(idev->dev->name, 0444,
 			net->mib.proc_net_devsnmp6, snmp6_dev_seq_show, idev);
@@ -264,7 +264,7 @@ int snmp6_unregister_dev(struct inet6_dev *idev)
 {
 	struct net *net = dev_net(idev->dev);
 	if (!net->mib.proc_net_devsnmp6)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (!idev->stats.proc_dir_entry)
 		return -EINVAL;
 	proc_remove(idev->stats.proc_dir_entry);
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index f3279810d..eeeae7af2 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -1838,7 +1838,7 @@ static int fib6_nh_remove_exception(const struct fib6_nh *nh, int plen,
 	int err;
 
 	if (!rcu_access_pointer(nh->rt6i_exception_bucket))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock_bh(&rt6_exception_lock);
 	bucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);
diff --git a/net/ipv6/seg6_hmac.c b/net/ipv6/seg6_hmac.c
index 85dddfe3a..19dc15678 100644
--- a/net/ipv6/seg6_hmac.c
+++ b/net/ipv6/seg6_hmac.c
@@ -126,7 +126,7 @@ static int __do_hmac(struct seg6_hmac_info *hinfo, const char *text, u8 psize,
 
 	algo = __hmac_get_algo(hinfo->alg_id);
 	if (!algo)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tfm = *this_cpu_ptr(algo->tfms);
 
diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c
index 5e2c34c0a..26ddd0c1d 100644
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -1308,7 +1308,7 @@ ipip6_tunnel_change(struct net_device *dev, struct ip_tunnel_parm *p)
 	t = ipip6_tunnel_locate(t->net, p, 0);
 	if (dev == dev_to_sit_net(dev)->fb_tunnel_dev) {
 		if (!t)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else {
 		if (t) {
 			if (t->dev != dev)
@@ -1337,7 +1337,7 @@ ipip6_tunnel_del(struct net_device *dev, struct ip_tunnel_parm *p)
 	if (dev == dev_to_sit_net(dev)->fb_tunnel_dev) {
 		t = ipip6_tunnel_locate(t->net, p, 0);
 		if (!t)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (t == netdev_priv(dev_to_sit_net(dev)->fb_tunnel_dev))
 			return -EPERM;
 		dev = t->dev;
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index f67d45ff0..0653d9e4e 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -384,7 +384,7 @@ static int tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	if (!sk) {
 		__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),
 				  ICMP6_MIB_INERRORS);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (sk->sk_state == TCP_TIME_WAIT) {
diff --git a/net/ipv6/tunnel6.c b/net/ipv6/tunnel6.c
index 06c02ebe6..47d47528b 100644
--- a/net/ipv6/tunnel6.c
+++ b/net/ipv6/tunnel6.c
@@ -182,7 +182,7 @@ static int tunnel6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		if (!handler->err_handler(skb, opt, type, code, offset, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int tunnel46_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
@@ -194,7 +194,7 @@ static int tunnel46_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		if (!handler->err_handler(skb, opt, type, code, offset, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int tunnelmpls6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
@@ -206,7 +206,7 @@ static int tunnelmpls6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		if (!handler->err_handler(skb, opt, type, code, offset, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct inet6_protocol tunnel6_protocol = {
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index a8d74f440..17cf5a35c 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -428,7 +428,7 @@ static int __udp6_lib_err_encap_no_sk(struct sk_buff *skb,
 			return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Try to match ICMP errors to UDP tunnels by looking up a socket without
diff --git a/net/ipv6/xfrm6_protocol.c b/net/ipv6/xfrm6_protocol.c
index ea2f805d3..ccbf05c6f 100644
--- a/net/ipv6/xfrm6_protocol.c
+++ b/net/ipv6/xfrm6_protocol.c
@@ -132,7 +132,7 @@ static int xfrm6_esp_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		if (!handler->err_handler(skb, opt, type, code, offset, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int xfrm6_ah_rcv(struct sk_buff *skb)
@@ -161,7 +161,7 @@ static int xfrm6_ah_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		if (!handler->err_handler(skb, opt, type, code, offset, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int xfrm6_ipcomp_rcv(struct sk_buff *skb)
@@ -190,7 +190,7 @@ static int xfrm6_ipcomp_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		if (!handler->err_handler(skb, opt, type, code, offset, info))
 			return 0;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct inet6_protocol esp6_protocol = {
diff --git a/net/kcm/kcmsock.c b/net/kcm/kcmsock.c
index 56fac24a6..6bf6daa87 100644
--- a/net/kcm/kcmsock.c
+++ b/net/kcm/kcmsock.c
@@ -1478,7 +1478,7 @@ static int kcm_attach_ioctl(struct socket *sock, struct kcm_attach *info)
 
 	csock = sockfd_lookup(info->fd, &err);
 	if (!csock)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	prog = bpf_prog_get_type(info->bpf_fd, BPF_PROG_TYPE_SOCKET_FILTER);
 	if (IS_ERR(prog)) {
@@ -1607,7 +1607,7 @@ static int kcm_unattach_ioctl(struct socket *sock, struct kcm_unattach *info)
 
 	csock = sockfd_lookup(info->fd, &err);
 	if (!csock)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	csk = csock->sk;
 	if (!csk) {
diff --git a/net/key/af_key.c b/net/key/af_key.c
index b67ed3a84..dbff4c27a 100644
--- a/net/key/af_key.c
+++ b/net/key/af_key.c
@@ -1370,7 +1370,7 @@ static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_
 		x = xfrm_find_acq(net, &dummy_mark, mode, reqid, 0, proto, xdaddr, xsaddr, 1, family);
 
 	if (x == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	min_spi = 0x100;
 	max_spi = 0x0fffffff;
@@ -2405,7 +2405,7 @@ static int pfkey_spddelete(struct sock *sk, struct sk_buff *skb, const struct sa
 				   1, &err);
 	security_xfrm_policy_free(pol_ctx);
 	if (xp == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	xfrm_audit_policy_delete(xp, err ? 0 : 1, true);
 
@@ -2654,7 +2654,7 @@ static int pfkey_spdget(struct sock *sk, struct sk_buff *skb, const struct sadb_
 	xp = xfrm_policy_byid(net, DUMMY_MARK, 0, XFRM_POLICY_TYPE_MAIN,
 			      dir, pol->sadb_x_policy_id, delete, &err);
 	if (xp == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (delete) {
 		xfrm_audit_policy_delete(xp, err ? 0 : 1, true);
diff --git a/net/mac80211/agg-tx.c b/net/mac80211/agg-tx.c
index b37c8a983..59a962e31 100644
--- a/net/mac80211/agg-tx.c
+++ b/net/mac80211/agg-tx.c
@@ -336,7 +336,7 @@ int ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 	if (!tid_tx) {
 		spin_unlock_bh(&sta->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 9b360544a..c36c6d2c3 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1142,7 +1142,7 @@ static int ieee80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
 
 	old = sdata_dereference(sdata->u.ap.beacon, sdata);
 	if (!old)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = ieee80211_assign_beacon(sdata, params, NULL);
 	if (err < 0)
@@ -1164,7 +1164,7 @@ static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 
 	old_beacon = sdata_dereference(sdata->u.ap.beacon, sdata);
 	if (!old_beacon)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	old_probe_resp = sdata_dereference(sdata->u.ap.probe_resp, sdata);
 
 	/* abort any running channel switch */
@@ -1745,7 +1745,7 @@ static int ieee80211_add_mpath(struct wiphy *wiphy, struct net_device *dev,
 	sta = sta_info_get(sdata, next_hop);
 	if (!sta) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mpath = mesh_path_add(sdata, dst);
@@ -1786,13 +1786,13 @@ static int ieee80211_change_mpath(struct wiphy *wiphy, struct net_device *dev,
 	sta = sta_info_get(sdata, next_hop);
 	if (!sta) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mpath = mesh_path_lookup(sdata, dst);
 	if (!mpath) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mesh_path_fix_nexthop(mpath, sta);
@@ -1860,7 +1860,7 @@ static int ieee80211_get_mpath(struct wiphy *wiphy, struct net_device *dev,
 	mpath = mesh_path_lookup(sdata, dst);
 	if (!mpath) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	memcpy(dst, mpath->dst, ETH_ALEN);
 	mpath_set_pinfo(mpath, next_hop, pinfo);
@@ -1881,7 +1881,7 @@ static int ieee80211_dump_mpath(struct wiphy *wiphy, struct net_device *dev,
 	mpath = mesh_path_lookup_by_idx(sdata, idx);
 	if (!mpath) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	memcpy(dst, mpath->dst, ETH_ALEN);
 	mpath_set_pinfo(mpath, next_hop, pinfo);
@@ -1911,7 +1911,7 @@ static int ieee80211_get_mpp(struct wiphy *wiphy, struct net_device *dev,
 	mpath = mpp_path_lookup(sdata, dst);
 	if (!mpath) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	memcpy(dst, mpath->dst, ETH_ALEN);
 	mpp_set_pinfo(mpath, mpp, pinfo);
@@ -1932,7 +1932,7 @@ static int ieee80211_dump_mpp(struct wiphy *wiphy, struct net_device *dev,
 	mpath = mpp_path_lookup_by_idx(sdata, idx);
 	if (!mpath) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	memcpy(dst, mpath->dst, ETH_ALEN);
 	mpp_set_pinfo(mpath, mpp, pinfo);
@@ -2181,7 +2181,7 @@ static int ieee80211_change_bss(struct wiphy *wiphy,
 	u32 changed = 0;
 
 	if (!sdata_dereference(sdata->u.ap.beacon, sdata))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	sband = ieee80211_get_sband(sdata);
 	if (!sband)
@@ -3736,7 +3736,7 @@ static int ieee80211_del_tx_ts(struct wiphy *wiphy, struct net_device *dev,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void ieee80211_nan_func_terminated(struct ieee80211_vif *vif,
@@ -3949,7 +3949,7 @@ static int ieee80211_set_tid_config(struct wiphy *wiphy,
 	sta = sta_info_get_bss(sdata, tid_conf->peer);
 	if (!sta) {
 		mutex_unlock(&sdata->local->sta_mtx);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = drv_set_tid_config(sdata->local, sdata, &sta->sta, tid_conf);
@@ -3976,7 +3976,7 @@ static int ieee80211_reset_tid_config(struct wiphy *wiphy,
 	sta = sta_info_get_bss(sdata, peer);
 	if (!sta) {
 		mutex_unlock(&sdata->local->sta_mtx);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = drv_reset_tid_config(sdata->local, sdata, &sta->sta, tids);
diff --git a/net/mac80211/mesh_hwmp.c b/net/mac80211/mesh_hwmp.c
index 02cde0fd0..f40effd68 100644
--- a/net/mac80211/mesh_hwmp.c
+++ b/net/mac80211/mesh_hwmp.c
@@ -1169,7 +1169,7 @@ int mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,
 	if (skb_to_free)
 		mesh_path_discard_frame(sdata, skb_to_free);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
@@ -1192,7 +1192,7 @@ int mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,
 
 	mpath = mesh_path_lookup(sdata, target_addr);
 	if (!mpath || !(mpath->flags & MESH_PATH_ACTIVE))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (time_after(jiffies,
 		       mpath->exp_time -
@@ -1210,7 +1210,7 @@ int mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void mesh_path_timer(struct timer_list *t)
diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c
index db3b8bf75..2e77bcc63 100644
--- a/net/mac80211/offchannel.c
+++ b/net/mac80211/offchannel.c
@@ -711,7 +711,7 @@ static int ieee80211_cancel_roc(struct ieee80211_local *local,
 	int ret;
 
 	if (!cookie)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	flush_work(&local->hw_roc_start);
 
@@ -728,7 +728,7 @@ static int ieee80211_cancel_roc(struct ieee80211_local *local,
 
 	if (!found) {
 		mutex_unlock(&local->mtx);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!found->started) {
diff --git a/net/mac80211/rate.c b/net/mac80211/rate.c
index b051f125d..9cb437e16 100644
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@ -962,7 +962,7 @@ int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,
 	if (!ref) {
 		wiphy_warn(local->hw.wiphy,
 			   "Failed to select rate control algorithm\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	WARN_ON(local->rate_ctrl);
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index cd8487bc6..368750a32 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -987,7 +987,7 @@ static int __must_check __sta_info_destroy_part1(struct sta_info *sta)
 	might_sleep();
 
 	if (!sta)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	local = sta->local;
 	sdata = sta->sdata;
diff --git a/net/mac802154/llsec.c b/net/mac802154/llsec.c
index c079ee69d..7e20ae913 100644
--- a/net/mac802154/llsec.c
+++ b/net/mac802154/llsec.c
@@ -282,7 +282,7 @@ int mac802154_llsec_key_del(struct mac802154_llsec *sec,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static bool llsec_dev_use_shortaddr(__le16 short_addr)
@@ -391,7 +391,7 @@ int mac802154_llsec_dev_del(struct mac802154_llsec *sec, __le64 device_addr)
 
 	pos = llsec_dev_find_long(sec, device_addr);
 	if (!pos)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hash_del_rcu(&pos->bucket_s);
 	hash_del_rcu(&pos->bucket_hw);
@@ -428,7 +428,7 @@ int mac802154_llsec_devkey_add(struct mac802154_llsec *sec,
 	dev = llsec_dev_find_long(sec, dev_addr);
 
 	if (!dev)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (llsec_devkey_find(dev, &key->key_id))
 		return -EEXIST;
@@ -452,11 +452,11 @@ int mac802154_llsec_devkey_del(struct mac802154_llsec *sec,
 	dev = llsec_dev_find_long(sec, dev_addr);
 
 	if (!dev)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	devkey = llsec_devkey_find(dev, &key->key_id);
 	if (!devkey)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_del_rcu(&devkey->devkey.list);
 	kfree_rcu(devkey, rcu);
@@ -510,7 +510,7 @@ int mac802154_llsec_seclevel_del(struct mac802154_llsec *sec,
 
 	pos = llsec_find_seclevel(sec, sl);
 	if (!pos)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_del_rcu(&pos->level.list);
 	kfree_rcu(pos, rcu);
@@ -944,7 +944,7 @@ llsec_update_devkey_info(struct mac802154_llsec_device *dev,
 	if (dev->dev.key_mode == IEEE802154_LLSEC_DEVKEY_RESTRICT) {
 		devkey = llsec_devkey_find(dev, in_key);
 		if (!devkey)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (dev->dev.key_mode == IEEE802154_LLSEC_DEVKEY_RECORD) {
diff --git a/net/ncsi/ncsi-aen.c b/net/ncsi/ncsi-aen.c
index b635c194f..d78e6e00e 100644
--- a/net/ncsi/ncsi-aen.c
+++ b/net/ncsi/ncsi-aen.c
@@ -223,7 +223,7 @@ int ncsi_aen_handler(struct ncsi_dev_priv *ndp, struct sk_buff *skb)
 	if (!nah) {
 		netdev_warn(ndp->ndev.dev, "Invalid AEN (0x%x) received\n",
 			    h->type);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = ncsi_validate_aen_pkt(h, nah->payload);
diff --git a/net/ncsi/ncsi-cmd.c b/net/ncsi/ncsi-cmd.c
index ba9ae4821..db14211e7 100644
--- a/net/ncsi/ncsi-cmd.c
+++ b/net/ncsi/ncsi-cmd.c
@@ -336,7 +336,7 @@ int ncsi_xmit_cmd(struct ncsi_cmd_arg *nca)
 	if (!nch) {
 		netdev_err(nca->ndp->ndev.dev,
 			   "Cannot send packet with type 0x%02x\n", nca->type);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Get packet payload length and allocate the request
diff --git a/net/ncsi/ncsi-rsp.c b/net/ncsi/ncsi-rsp.c
index a94bb5979..eaa338a34 100644
--- a/net/ncsi/ncsi-rsp.c
+++ b/net/ncsi/ncsi-rsp.c
@@ -733,7 +733,7 @@ static int ncsi_rsp_handler_oem(struct ncsi_request *nr)
 	if (!nrh) {
 		netdev_err(nr->ndp->ndev.dev, "Received unrecognized OEM packet with MFR-ID (0x%x)\n",
 			   mfr_id);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Process the packet */
@@ -1145,7 +1145,7 @@ int ncsi_rcv_rsp(struct sk_buff *skb, struct net_device *dev,
 	if (!nrh) {
 		netdev_err(nd->dev, "Received unrecognized packet (0x%x)\n",
 			   hdr->type);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Associate with the request */
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index 56621d6bf..668546204 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -1307,7 +1307,7 @@ static int ip_set_flush(struct net *net, struct sock *ctnl, struct sk_buff *skb,
 	} else {
 		s = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));
 		if (!s)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		ip_set_flush_set(s);
 	}
@@ -1344,7 +1344,7 @@ static int ip_set_rename(struct net *net, struct sock *ctnl,
 
 	set = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));
 	if (!set)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	write_lock_bh(&ip_set_ref_lock);
 	if (set->ref != 0 || set->ref_netlink != 0) {
@@ -1394,7 +1394,7 @@ static int ip_set_swap(struct net *net, struct sock *ctnl, struct sk_buff *skb,
 	from = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),
 			       &from_id);
 	if (!from)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	to = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME2]),
 			     &to_id);
@@ -1811,7 +1811,7 @@ static int ip_set_ad(struct net *net, struct sock *ctnl,
 
 	set = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));
 	if (!set)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	use_lineno = !!attr[IPSET_ATTR_LINENO];
 	if (attr[IPSET_ATTR_DATA]) {
@@ -1876,7 +1876,7 @@ static int ip_set_utest(struct net *net, struct sock *ctnl, struct sk_buff *skb,
 
 	set = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));
 	if (!set)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (nla_parse_nested(tb, IPSET_ATTR_ADT_MAX, attr[IPSET_ATTR_DATA],
 			     set->type->adt_policy, NULL))
@@ -1911,7 +1911,7 @@ static int ip_set_header(struct net *net, struct sock *ctnl,
 
 	set = find_set(inst, nla_data(attr[IPSET_ATTR_SETNAME]));
 	if (!set)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!skb2)
@@ -2069,7 +2069,7 @@ static int ip_set_byname(struct net *net, struct sock *ctnl,
 
 	set = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]), &id);
 	if (id == IPSET_INVALID_ID)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!skb2)
@@ -2121,10 +2121,10 @@ static int ip_set_byindex(struct net *net, struct sock *ctnl,
 
 	id = ip_set_get_h16(attr[IPSET_ATTR_INDEX]);
 	if (id >= inst->ip_set_max)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	set = ip_set(inst, id);
 	if (set == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!skb2)
diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c
index 412656c34..f88f179d3 100644
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@ -1130,7 +1130,7 @@ ip_vs_edit_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)
 
 	if (dest == NULL) {
 		IP_VS_DBG(1, "%s(): dest doesn't exist\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	__ip_vs_update_dest(svc, dest, udest, 0);
@@ -1212,7 +1212,7 @@ ip_vs_del_dest(struct ip_vs_service *svc, struct ip_vs_dest_user_kern *udest)
 
 	if (dest == NULL) {
 		IP_VS_DBG(1, "%s(): destination not found!\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
@@ -1418,7 +1418,7 @@ ip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)
 		if (!sched) {
 			pr_info("Scheduler module ip_vs_%s not found\n",
 				u->sched_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	old_sched = sched;
diff --git a/net/netfilter/ipvs/ip_vs_ftp.c b/net/netfilter/ipvs/ip_vs_ftp.c
index cf925906f..1c104ec13 100644
--- a/net/netfilter/ipvs/ip_vs_ftp.c
+++ b/net/netfilter/ipvs/ip_vs_ftp.c
@@ -579,7 +579,7 @@ static int __net_init __ip_vs_ftp_init(struct net *net)
 	struct netns_ipvs *ipvs = net_ipvs(net);
 
 	if (!ipvs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	app = register_ip_vs_app(ipvs, &ip_vs_ftp);
 	if (IS_ERR(app))
diff --git a/net/netfilter/ipvs/ip_vs_lblc.c b/net/netfilter/ipvs/ip_vs_lblc.c
index 7ac7473e3..3474aa867 100644
--- a/net/netfilter/ipvs/ip_vs_lblc.c
+++ b/net/netfilter/ipvs/ip_vs_lblc.c
@@ -552,7 +552,7 @@ static int __net_init __ip_vs_lblc_init(struct net *net)
 	struct netns_ipvs *ipvs = net_ipvs(net);
 
 	if (!ipvs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!net_eq(net, &init_net)) {
 		ipvs->lblc_ctl_table = kmemdup(vs_vars_table,
diff --git a/net/netfilter/ipvs/ip_vs_lblcr.c b/net/netfilter/ipvs/ip_vs_lblcr.c
index 77c323c36..2ae408414 100644
--- a/net/netfilter/ipvs/ip_vs_lblcr.c
+++ b/net/netfilter/ipvs/ip_vs_lblcr.c
@@ -738,7 +738,7 @@ static int __net_init __ip_vs_lblcr_init(struct net *net)
 	struct netns_ipvs *ipvs = net_ipvs(net);
 
 	if (!ipvs)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!net_eq(net, &init_net)) {
 		ipvs->lblcr_ctl_table = kmemdup(vs_vars_table,
diff --git a/net/netfilter/ipvs/ip_vs_pe.c b/net/netfilter/ipvs/ip_vs_pe.c
index 166c669f0..8324db873 100644
--- a/net/netfilter/ipvs/ip_vs_pe.c
+++ b/net/netfilter/ipvs/ip_vs_pe.c
@@ -69,7 +69,7 @@ int register_ip_vs_pe(struct ip_vs_pe *pe)
 
 	/* increase the module use count */
 	if (!ip_vs_use_count_inc())
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&ip_vs_pe_mutex);
 	/* Make sure that the pe with this name doesn't exist
diff --git a/net/netfilter/ipvs/ip_vs_sched.c b/net/netfilter/ipvs/ip_vs_sched.c
index d4903723b..ed77238e5 100644
--- a/net/netfilter/ipvs/ip_vs_sched.c
+++ b/net/netfilter/ipvs/ip_vs_sched.c
@@ -180,7 +180,7 @@ int register_ip_vs_scheduler(struct ip_vs_scheduler *scheduler)
 
 	/* increase the module use count */
 	if (!ip_vs_use_count_inc())
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mutex_lock(&ip_vs_sched_mutex);
 
diff --git a/net/netfilter/nf_conntrack_helper.c b/net/netfilter/nf_conntrack_helper.c
index 118f41592..36c03b424 100644
--- a/net/netfilter/nf_conntrack_helper.c
+++ b/net/netfilter/nf_conntrack_helper.c
@@ -158,7 +158,7 @@ nf_nat_helper_try_module_get(const char *name, u16 l3num, u8 protonum)
 	h = __nf_conntrack_helper_find(name, l3num, protonum);
 	if (!h) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	nat = nf_conntrack_nat_helper_find(h->nat_mod_name);
@@ -171,7 +171,7 @@ nf_nat_helper_try_module_get(const char *name, u16 l3num, u8 protonum)
 		nat = nf_conntrack_nat_helper_find(mod_name);
 		if (!nat) {
 			rcu_read_unlock();
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index 832eabecf..4f6847f69 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -1573,7 +1573,7 @@ static int ctnetlink_del_conntrack(struct net *net, struct sock *ctnl,
 
 	h = nf_conntrack_find_get(net, &zone, &tuple);
 	if (!h)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ct = nf_ct_tuplehash_to_ctrack(h);
 
@@ -1587,7 +1587,7 @@ static int ctnetlink_del_conntrack(struct net *net, struct sock *ctnl,
 
 		if (id != (__force __be32)nf_ct_get_id(ct)) {
 			nf_ct_put(ct);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -1641,7 +1641,7 @@ static int ctnetlink_get_conntrack(struct net *net, struct sock *ctnl,
 
 	h = nf_conntrack_find_get(net, &zone, &tuple);
 	if (!h)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ct = nf_ct_tuplehash_to_ctrack(h);
 
@@ -3304,7 +3304,7 @@ static int ctnetlink_dump_exp_ct(struct net *net, struct sock *ctnl,
 
 	h = nf_conntrack_find_get(net, &zone, &tuple);
 	if (!h)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ct = nf_ct_tuplehash_to_ctrack(h);
 	/* No expectation linked to this connection tracking. */
@@ -3365,14 +3365,14 @@ static int ctnetlink_get_expect(struct net *net, struct sock *ctnl,
 
 	exp = nf_ct_expect_find_get(net, &zone, &tuple);
 	if (!exp)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (cda[CTA_EXPECT_ID]) {
 		__be32 id = nla_get_be32(cda[CTA_EXPECT_ID]);
 
 		if (id != nf_expect_get_id(exp)) {
 			nf_ct_expect_put(exp);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -3445,13 +3445,13 @@ static int ctnetlink_del_expect(struct net *net, struct sock *ctnl,
 		/* bump usage count to 2 */
 		exp = nf_ct_expect_find_get(net, &zone, &tuple);
 		if (!exp)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (cda[CTA_EXPECT_ID]) {
 			__be32 id = nla_get_be32(cda[CTA_EXPECT_ID]);
 			if (ntohl(id) != (u32)(unsigned long)exp) {
 				nf_ct_expect_put(exp);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		}
 
@@ -3627,7 +3627,7 @@ ctnetlink_create_expect(struct net *net,
 	/* Look for master conntrack of this expectation */
 	h = nf_conntrack_find_get(net, zone, &master_tuple);
 	if (!h)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ct = nf_ct_tuplehash_to_ctrack(h);
 
 	rcu_read_lock();
diff --git a/net/netfilter/nf_conntrack_proto.c b/net/netfilter/nf_conntrack_proto.c
index a0560d175..a090e5928 100644
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@ -289,7 +289,7 @@ getorigdst(struct sock *sk, int optval, void __user *user, int *len)
 	pr_debug("SO_ORIGINAL_DST: Can't find %pI4/%u-%pI4/%u.\n",
 		 &tuple.src.u3.ip, ntohs(tuple.src.u.tcp.port),
 		 &tuple.dst.u3.ip, ntohs(tuple.dst.u.tcp.port));
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct nf_sockopt_ops so_getorigdst = {
@@ -335,7 +335,7 @@ ipv6_getorigdst(struct sock *sk, int optval, void __user *user, int *len)
 		pr_debug("IP6T_SO_ORIGINAL_DST: Can't find %pI6c/%u-%pI6c/%u.\n",
 			 &tuple.src.u3.ip6, ntohs(tuple.src.u.tcp.port),
 			 &tuple.dst.u3.ip6, ntohs(tuple.dst.u.tcp.port));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ct = nf_ct_tuplehash_to_ctrack(h);
diff --git a/net/netfilter/nf_flow_table_offload.c b/net/netfilter/nf_flow_table_offload.c
index 5fff1e040..1e402beb6 100644
--- a/net/netfilter/nf_flow_table_offload.c
+++ b/net/netfilter/nf_flow_table_offload.c
@@ -184,7 +184,7 @@ static int flow_offload_eth_src(struct net *net,
 
 	dev = dev_get_by_index(net, tuple->iifidx);
 	if (!dev)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	mask = ~0xffff0000;
 	memcpy(&val16, dev->dev_addr, 2);
@@ -219,7 +219,7 @@ static int flow_offload_eth_dst(struct net *net,
 	dst_cache = flow->tuplehash[dir].tuple.dst_cache;
 	n = dst_neigh_lookup(dst_cache, daddr);
 	if (!n)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	read_lock_bh(&n->lock);
 	nud_state = n->nud_state;
@@ -228,7 +228,7 @@ static int flow_offload_eth_dst(struct net *net,
 
 	if (!(nud_state & NUD_VALID)) {
 		neigh_release(n);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mask = ~0xffffffff;
@@ -737,7 +737,7 @@ static int flow_offload_rule_add(struct flow_offload_work *offload,
 	ok_count += flow_offload_tuple_add(offload, flow_rule[1],
 					   FLOW_OFFLOAD_DIR_REPLY);
 	if (ok_count == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/net/netfilter/nf_log.c b/net/netfilter/nf_log.c
index 6cb9f9474..54663703c 100644
--- a/net/netfilter/nf_log.c
+++ b/net/netfilter/nf_log.c
@@ -133,7 +133,7 @@ int nf_log_bind_pf(struct net *net, u_int8_t pf,
 	mutex_lock(&nf_log_mutex);
 	if (__find_logger(pf, logger->name) == NULL) {
 		mutex_unlock(&nf_log_mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	rcu_assign_pointer(net->nf.nf_loggers[pf], logger);
 	mutex_unlock(&nf_log_mutex);
@@ -442,7 +442,7 @@ static int nf_log_proc_dostring(struct ctl_table *table, int write,
 		logger = __find_logger(tindex, buf);
 		if (logger == NULL) {
 			mutex_unlock(&nf_log_mutex);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		rcu_assign_pointer(net->nf.nf_loggers[tindex], logger);
 		mutex_unlock(&nf_log_mutex);
diff --git a/net/netfilter/nf_nat_sip.c b/net/netfilter/nf_nat_sip.c
index f0a735e86..b4f1b3511 100644
--- a/net/netfilter/nf_nat_sip.c
+++ b/net/netfilter/nf_nat_sip.c
@@ -485,7 +485,7 @@ static int mangle_sdp_packet(struct sk_buff *skb, unsigned int protoff,
 
 	if (ct_sip_get_sdp_header(ct, *dptr, sdpoff, *datalen, type, term,
 				  &matchoff, &matchlen) <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return mangle_packet(skb, protoff, dataoff, dptr, datalen,
 			     matchoff, matchlen, buffer, buflen) ? 0 : -EINVAL;
 }
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 88325b264..32842a404 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -327,7 +327,7 @@ nf_tables_delrule_deactivate(struct nft_ctx *ctx, struct nft_rule *rule)
 		ctx->chain->use--;
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct nft_trans *nft_trans_rule_add(struct nft_ctx *ctx, int msg_type,
@@ -1800,7 +1800,7 @@ static int nft_chain_parse_hook(struct net *net,
 		return -EOPNOTSUPP;
 
 	if (!try_module_get(type->owner))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hook->type = type;
 
@@ -4051,7 +4051,7 @@ static int nf_tables_newset(struct net *net, struct sock *nlsk,
 	}
 
 	if (!(nlh->nlmsg_flags & NLM_F_CREATE))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ops = nft_select_set_ops(&ctx, nla, &desc, policy);
 	if (IS_ERR(ops))
@@ -4512,7 +4512,7 @@ static int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)
 
 	if (!set_found) {
 		rcu_read_unlock();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	event  = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, NFT_MSG_NEWSETELEM);
diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c
index 3243a31f6..d091e876d 100644
--- a/net/netfilter/nfnetlink_queue.c
+++ b/net/netfilter/nfnetlink_queue.c
@@ -1087,7 +1087,7 @@ static int nfqnl_recv_verdict_batch(struct net *net, struct sock *ctnl,
 	spin_unlock_bh(&queue->lock);
 
 	if (list_empty(&batch_list))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	list_for_each_entry_safe(entry, tmp, &batch_list, list) {
 		if (nfqa[NFQA_MARK])
@@ -1187,7 +1187,7 @@ static int nfqnl_recv_verdict(struct net *net, struct sock *ctnl,
 
 	entry = find_dequeue_entry(queue, ntohl(vhdr->id));
 	if (entry == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* rcu lock already held from nfnl->call_rcu. */
 	nfnl_ct = rcu_dereference(nfnl_ct_hook);
diff --git a/net/netfilter/nft_ct.c b/net/netfilter/nft_ct.c
index 77258af1f..d68264971 100644
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@ -988,7 +988,7 @@ static int nft_ct_helper_obj_init(const struct nft_ctx *ctx,
 
 	priv->l4proto = nla_get_u8(tb[NFTA_CT_HELPER_L4PROTO]);
 	if (!priv->l4proto)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	nla_strlcpy(name, tb[NFTA_CT_HELPER_NAME], sizeof(name));
 
@@ -1027,7 +1027,7 @@ static int nft_ct_helper_obj_init(const struct nft_ctx *ctx,
 
 	/* && is intentional; only error if INET found neither ipv4 or ipv6 */
 	if (!help4 && !help6)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	priv->helper4 = help4;
 	priv->helper6 = help6;
diff --git a/net/netfilter/nft_exthdr.c b/net/netfilter/nft_exthdr.c
index 07782836f..c796175f5 100644
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@ -85,7 +85,7 @@ static int ipv4_find_option(struct net *net, struct sk_buff *skb,
 
 	optlen = iph->ihl * 4 - (int)sizeof(struct iphdr);
 	if (optlen <= 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	memset(opt, 0, sizeof(struct ip_options));
 	/* Copy the options since __ip_options_compile() modifies
diff --git a/net/netfilter/nft_flow_offload.c b/net/netfilter/nft_flow_offload.c
index 3b9b97aa4..1e18c0650 100644
--- a/net/netfilter/nft_flow_offload.c
+++ b/net/netfilter/nft_flow_offload.c
@@ -42,7 +42,7 @@ static int nft_flow_route(const struct nft_pktinfo *pkt,
 
 	nf_route(nft_net(pkt), &other_dst, &fl, false, nft_pf(pkt));
 	if (!other_dst)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	route->tuple[dir].dst		= this_dst;
 	route->tuple[!dir].dst		= other_dst;
diff --git a/net/netfilter/nft_meta.c b/net/netfilter/nft_meta.c
index 951b6e87e..133876ffe 100644
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@ -819,7 +819,7 @@ static int nft_secmark_compute_secid(struct nft_secmark *priv)
 		return err;
 
 	if (!tmp_secid)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = security_secmark_relabel_packet(tmp_secid);
 	if (err)
diff --git a/net/netfilter/nft_objref.c b/net/netfilter/nft_objref.c
index 5f9207a9f..4b24754d7 100644
--- a/net/netfilter/nft_objref.c
+++ b/net/netfilter/nft_objref.c
@@ -39,7 +39,7 @@ static int nft_objref_init(const struct nft_ctx *ctx,
 			     tb[NFTA_OBJREF_IMM_NAME], objtype,
 			     genmask);
 	if (IS_ERR(obj))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	nft_objref_priv(expr) = obj;
 	obj->use++;
diff --git a/net/netfilter/xt_CT.c b/net/netfilter/xt_CT.c
index d4deee391..e1e042244 100644
--- a/net/netfilter/xt_CT.c
+++ b/net/netfilter/xt_CT.c
@@ -80,14 +80,14 @@ xt_ct_set_helper(struct nf_conn *ct, const char *helper_name,
 	proto = xt_ct_find_proto(par);
 	if (!proto) {
 		pr_info_ratelimited("You must specify a L4 protocol and not use inversions on it\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	helper = nf_conntrack_helper_try_module_get(helper_name, par->family,
 						    proto);
 	if (helper == NULL) {
 		pr_info_ratelimited("No such helper \"%s\"\n", helper_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	help = nf_ct_helper_ext_add(ct, GFP_KERNEL);
diff --git a/net/netfilter/xt_SECMARK.c b/net/netfilter/xt_SECMARK.c
index 75625d13e..727f41938 100644
--- a/net/netfilter/xt_SECMARK.c
+++ b/net/netfilter/xt_SECMARK.c
@@ -60,7 +60,7 @@ static int checkentry_lsm(struct xt_secmark_target_info *info)
 	if (!info->secid) {
 		pr_info_ratelimited("unable to map security context \'%s\'\n",
 				    info->secctx);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = security_secmark_relabel_packet(info->secid);
diff --git a/net/netfilter/xt_nfacct.c b/net/netfilter/xt_nfacct.c
index 5aab6df74..914040d79 100644
--- a/net/netfilter/xt_nfacct.c
+++ b/net/netfilter/xt_nfacct.c
@@ -40,7 +40,7 @@ nfacct_mt_checkentry(const struct xt_mtchk_param *par)
 	if (nfacct == NULL) {
 		pr_info_ratelimited("accounting object `%s' does not exists\n",
 				    info->name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	info->nfacct = nfacct;
 	return 0;
diff --git a/net/netfilter/xt_set.c b/net/netfilter/xt_set.c
index 731bc2caf..f81beb91a 100644
--- a/net/netfilter/xt_set.c
+++ b/net/netfilter/xt_set.c
@@ -90,7 +90,7 @@ set_match_v0_checkentry(const struct xt_mtchk_param *par)
 	if (index == IPSET_INVALID_ID) {
 		pr_info_ratelimited("Cannot find set identified by id %u to match\n",
 				    info->match_set.index);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (info->match_set.u.flags[IPSET_DIM_MAX - 1] != 0) {
 		pr_info_ratelimited("set match dimension is over the limit!\n");
@@ -141,7 +141,7 @@ set_match_v1_checkentry(const struct xt_mtchk_param *par)
 	if (index == IPSET_INVALID_ID) {
 		pr_info_ratelimited("Cannot find set identified by id %u to match\n",
 				    info->match_set.index);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (info->match_set.dim > IPSET_DIM_MAX) {
 		pr_info_ratelimited("set match dimension is over the limit!\n");
@@ -239,7 +239,7 @@ set_target_v0_checkentry(const struct xt_tgchk_param *par)
 		if (index == IPSET_INVALID_ID) {
 			pr_info_ratelimited("Cannot find add_set index %u as target\n",
 					    info->add_set.index);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -250,7 +250,7 @@ set_target_v0_checkentry(const struct xt_tgchk_param *par)
 					    info->del_set.index);
 			if (info->add_set.index != IPSET_INVALID_ID)
 				ip_set_nfnl_put(par->net, info->add_set.index);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	if (info->add_set.u.flags[IPSET_DIM_MAX - 1] != 0 ||
@@ -314,7 +314,7 @@ set_target_v1_checkentry(const struct xt_tgchk_param *par)
 		if (index == IPSET_INVALID_ID) {
 			pr_info_ratelimited("Cannot find add_set index %u as target\n",
 					    info->add_set.index);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -325,7 +325,7 @@ set_target_v1_checkentry(const struct xt_tgchk_param *par)
 					    info->del_set.index);
 			if (info->add_set.index != IPSET_INVALID_ID)
 				ip_set_nfnl_put(par->net, info->add_set.index);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 	if (info->add_set.dim > IPSET_DIM_MAX ||
@@ -443,7 +443,7 @@ set_target_v3_checkentry(const struct xt_tgchk_param *par)
 		if (index == IPSET_INVALID_ID) {
 			pr_info_ratelimited("Cannot find add_set index %u as target\n",
 					    info->add_set.index);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/net/netlabel/netlabel_domainhash.c b/net/netlabel/netlabel_domainhash.c
index a1f2320ec..9018e4c50 100644
--- a/net/netlabel/netlabel_domainhash.c
+++ b/net/netlabel/netlabel_domainhash.c
@@ -582,7 +582,7 @@ int netlbl_domhsh_remove_entry(struct netlbl_dom_map *entry,
 	struct audit_buffer *audit_buf;
 
 	if (entry == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock(&netlbl_domhsh_lock);
 	if (entry->valid) {
@@ -709,7 +709,7 @@ int netlbl_domhsh_remove_af4(const char *domain,
 
 remove_af4_failure:
 	rcu_read_unlock();
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #if IS_ENABLED(CONFIG_IPV6)
@@ -774,7 +774,7 @@ int netlbl_domhsh_remove_af6(const char *domain,
 
 remove_af6_failure:
 	rcu_read_unlock();
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif /* IPv6 */
 
diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c
index 5e1239cef..73059fd9a 100644
--- a/net/netlabel/netlabel_kapi.c
+++ b/net/netlabel/netlabel_kapi.c
@@ -334,7 +334,7 @@ int netlbl_cfg_cipsov4_map_add(u32 doi,
 
 	doi_def = cipso_v4_doi_getdef(doi);
 	if (doi_def == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
 	if (entry == NULL)
@@ -460,7 +460,7 @@ int netlbl_cfg_calipso_map_add(u32 doi,
 
 	doi_def = calipso_doi_getdef(doi);
 	if (doi_def == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
 	if (entry == NULL)
@@ -614,7 +614,7 @@ int netlbl_catmap_walk(struct netlbl_lsm_catmap *catmap, u32 offset)
 
 	iter = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);
 	if (iter == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (offset > iter->startbit) {
 		offset -= iter->startbit;
 		idx = offset / NETLBL_CATMAP_MAPSIZE;
@@ -639,13 +639,13 @@ int netlbl_catmap_walk(struct netlbl_lsm_catmap *catmap, u32 offset)
 				iter = iter->next;
 				idx = 0;
 			} else
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 		}
 		bitmap = iter->bitmap[idx];
 		bit = 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(netlbl_catmap_walk);
 
@@ -671,7 +671,7 @@ int netlbl_catmap_walkrng(struct netlbl_lsm_catmap *catmap, u32 offset)
 
 	iter = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);
 	if (iter == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (offset > iter->startbit) {
 		offset -= iter->startbit;
 		idx = offset / NETLBL_CATMAP_MAPSIZE;
@@ -705,7 +705,7 @@ int netlbl_catmap_walkrng(struct netlbl_lsm_catmap *catmap, u32 offset)
 		bit = 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
diff --git a/net/netlabel/netlabel_unlabeled.c b/net/netlabel/netlabel_unlabeled.c
index 77bb1bb22..fdb258d20 100644
--- a/net/netlabel/netlabel_unlabeled.c
+++ b/net/netlabel/netlabel_unlabeled.c
@@ -505,7 +505,7 @@ static int netlbl_unlhsh_remove_addr4(struct net *net,
 	}
 
 	if (entry == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kfree_rcu(entry, rcu);
 	return 0;
@@ -566,7 +566,7 @@ static int netlbl_unlhsh_remove_addr6(struct net *net,
 	}
 
 	if (entry == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kfree_rcu(entry, rcu);
 	return 0;
diff --git a/net/netlink/diag.c b/net/netlink/diag.c
index c6255eac3..c7eee999c 100644
--- a/net/netlink/diag.c
+++ b/net/netlink/diag.c
@@ -201,7 +201,7 @@ static int netlink_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)
 		cb->args[1] = i;
 	} else {
 		if (req->sdiag_protocol >= MAX_LINKS)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		err = __netlink_diag_dump(skb, cb, req->sdiag_protocol, s_num);
 	}
diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c
index 9395ee8a8..a8b3f0d20 100644
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@ -394,7 +394,7 @@ int genl_unregister_family(const struct genl_family *family)
 
 	if (!genl_family_find_byid(family->id)) {
 		genl_unlock_all();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	genl_unregister_mc_groups(family);
@@ -689,7 +689,7 @@ static int genl_family_rcv_msg(const struct genl_family *family,
 
 	/* this family doesn't exist in this netns */
 	if (!family->netnsok && !net_eq(net, &init_net))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	hdrlen = GENL_HDRLEN + family->hdrsize;
 	if (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))
@@ -723,7 +723,7 @@ static int genl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 	family = genl_family_find_byid(nlh->nlmsg_type);
 	if (family == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!family->parallel_ops)
 		genl_lock();
@@ -987,7 +987,7 @@ static int ctrl_getfamily(struct sk_buff *skb, struct genl_info *info)
 
 	if (!res->netnsok && !net_eq(genl_info_net(info), &init_net)) {
 		/* family doesn't exist here */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	msg = ctrl_build_family_msg(res, info->snd_portid, info->snd_seq,
@@ -1063,14 +1063,14 @@ static int ctrl_dumppolicy(struct sk_buff *skb, struct netlink_callback *cb)
 			rt = genl_family_find_byname(
 				nla_data(tb[CTRL_ATTR_FAMILY_NAME]));
 			if (!rt)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			fam_id = rt->id;
 		}
 	}
 
 	rt = genl_family_find_byid(fam_id);
 	if (!rt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!rt->policy)
 		return -ENODATA;
diff --git a/net/nfc/nci/uart.c b/net/nfc/nci/uart.c
index 11b554ce0..a0baea414 100644
--- a/net/nfc/nci/uart.c
+++ b/net/nfc/nci/uart.c
@@ -123,7 +123,7 @@ static int nci_uart_set_driver(struct tty_struct *tty, unsigned int driver)
 		return -EINVAL;
 
 	if (!nci_uart_drivers[driver])
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	nu = kzalloc(sizeof(*nu), GFP_KERNEL);
 	if (!nu)
@@ -144,7 +144,7 @@ static int nci_uart_set_driver(struct tty_struct *tty, unsigned int driver)
 		nu->ops.close(nu);
 		tty->disc_data = NULL;
 		kfree(nu);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return ret;
 }
diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c
index 4340f25fe..a77ac5696 100644
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@ -968,7 +968,7 @@ static int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
 
 		err = nf_conntrack_in(skb, &state);
 		if (err != NF_ACCEPT)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		/* Clear CT state NAT flags to mark that we have not yet done
 		 * NAT after the nf_conntrack_in() call.  We can actually clear
diff --git a/net/phonet/pn_dev.c b/net/phonet/pn_dev.c
index ac0fae06c..f4688ae58 100644
--- a/net/phonet/pn_dev.c
+++ b/net/phonet/pn_dev.c
@@ -385,7 +385,7 @@ int phonet_route_del(struct net_device *dev, u8 daddr)
 	mutex_unlock(&routes->lock);
 
 	if (!dev)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	synchronize_rcu();
 	dev_put(dev);
 	return 0;
diff --git a/net/qrtr/ns.c b/net/qrtr/ns.c
index d8252fdab..1f8157c19 100644
--- a/net/qrtr/ns.c
+++ b/net/qrtr/ns.c
@@ -265,7 +265,7 @@ static int server_del(struct qrtr_node *node, unsigned int port)
 
 	srv = radix_tree_lookup(&node->servers, port);
 	if (!srv)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	radix_tree_delete(&node->servers, port);
 
@@ -521,7 +521,7 @@ static int ctrl_cmd_del_server(struct sockaddr_qrtr *from,
 
 	node = node_get(node_id);
 	if (!node)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return server_del(node, port);
 }
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 8ac7eb0a8..5b2fcf09b 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -377,7 +377,7 @@ static int tcf_idr_delete_index(struct tcf_idrinfo *idrinfo, u32 index)
 	p = idr_find(&idrinfo->action_idr, index);
 	if (!p) {
 		mutex_unlock(&idrinfo->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!atomic_read(&p->tcfa_bindcnt)) {
diff --git a/net/sched/act_ife.c b/net/sched/act_ife.c
index c1fcd8571..f5154c6c5 100644
--- a/net/sched/act_ife.c
+++ b/net/sched/act_ife.c
@@ -329,7 +329,7 @@ static int add_metainfo_and_get_ops(const struct tcf_meta_ops *ops,
 	int ret;
 
 	if (!try_module_get(ops->owner))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ret = __add_metainfo(ops, ife, metaid, NULL, 0, true, exists);
 	if (ret)
 		module_put(ops->owner);
@@ -343,7 +343,7 @@ static int add_metainfo(struct tcf_ife_info *ife, u32 metaid, void *metaval,
 	int ret;
 
 	if (!ops)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	ret = __add_metainfo(ops, ife, metaid, metaval, len, false, exists);
 	if (ret)
 		/*put back what find_ife_oplist took */
@@ -684,7 +684,7 @@ static int find_decode_metaid(struct sk_buff *skb, struct tcf_ife_info *ife,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int tcf_ife_decode(struct sk_buff *skb, const struct tc_action *a,
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index 4619cb3cb..8c3786636 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -1108,7 +1108,7 @@ static int __tcf_qdisc_cl_find(struct Qdisc *q, u32 parent, unsigned long *cl,
 		*cl = cops->find(q, parent);
 		if (*cl == 0) {
 			NL_SET_ERR_MSG(extack, "Specified class doesn't exist");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -1990,7 +1990,7 @@ static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,
 			prio_allocate = true;
 		} else {
 			NL_SET_ERR_MSG(extack, "Invalid filter command with priority of zero");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -2201,7 +2201,7 @@ static int tc_del_tfilter(struct sk_buff *skb, struct nlmsghdr *n,
 
 	if (prio == 0 && (protocol || t->tcm_handle || tca[TCA_KIND])) {
 		NL_SET_ERR_MSG(extack, "Cannot flush filters with protocol, handle or kind set");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Find head of filter chain. */
@@ -2358,7 +2358,7 @@ static int tc_get_tfilter(struct sk_buff *skb, struct nlmsghdr *n,
 
 	if (prio == 0) {
 		NL_SET_ERR_MSG(extack, "Invalid filter command with priority of zero");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Find head of filter chain. */
diff --git a/net/sched/cls_cgroup.c b/net/sched/cls_cgroup.c
index fb881144f..2bbff3bef 100644
--- a/net/sched/cls_cgroup.c
+++ b/net/sched/cls_cgroup.c
@@ -91,7 +91,7 @@ static int cls_cgroup_change(struct net *net, struct sk_buff *in_skb,
 		return -EINVAL;
 
 	if (head && handle != head->handle)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	new = kzalloc(sizeof(*head), GFP_KERNEL);
 	if (!new)
diff --git a/net/sched/cls_flower.c b/net/sched/cls_flower.c
index e30bd969f..63b2017cb 100644
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@ -531,7 +531,7 @@ static int __fl_delete(struct tcf_proto *tp, struct cls_fl_filter *f,
 	spin_lock(&tp->lock);
 	if (f->deleted) {
 		spin_unlock(&tp->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	f->deleted = true;
diff --git a/net/sched/cls_tcindex.c b/net/sched/cls_tcindex.c
index 61e95029c..770d22544 100644
--- a/net/sched/cls_tcindex.c
+++ b/net/sched/cls_tcindex.c
@@ -205,7 +205,7 @@ static int tcindex_delete(struct tcf_proto *tp, void *arg, bool *last,
 	pr_debug("tcindex_delete(tp %p,arg %p),p %p\n", tp, arg, p);
 	if (p->perfect) {
 		if (!r->res.class)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else {
 		int i;
 
@@ -217,7 +217,7 @@ static int tcindex_delete(struct tcf_proto *tp, void *arg, bool *last,
 					goto found;
 			}
 		}
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 found:
 		rcu_assign_pointer(*walk, rtnl_dereference(f->next));
diff --git a/net/sched/cls_u32.c b/net/sched/cls_u32.c
index e15ff3359..69eecd992 100644
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@ -613,7 +613,7 @@ static int u32_destroy_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static void u32_destroy(struct tcf_proto *tp, bool rtnl_held,
diff --git a/net/sched/em_ipset.c b/net/sched/em_ipset.c
index c95cf86fb..17a125d71 100644
--- a/net/sched/em_ipset.c
+++ b/net/sched/em_ipset.c
@@ -27,7 +27,7 @@ static int em_ipset_change(struct net *net, void *data, int data_len,
 
 	index = ip_set_nfnl_get_byindex(net, set->index);
 	if (index == IPSET_INVALID_ID)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	em->datalen = sizeof(*set);
 	em->data = (unsigned long)kmemdup(data, em->datalen, GFP_KERNEL);
diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c
index 9a3449b56..2aaec5c2c 100644
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@ -1045,7 +1045,7 @@ static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,
 			ingress = 1;
 			if (!dev_ingress_queue(dev)) {
 				NL_SET_ERR_MSG(extack, "Device does not have an ingress queue");
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		}
 
@@ -1103,7 +1103,7 @@ static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,
 		cl = cops->find(parent, classid);
 		if (!cl) {
 			NL_SET_ERR_MSG(extack, "Specified class not found");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		err = cops->graft(parent, cl, new, &old, extack);
@@ -1446,7 +1446,7 @@ static int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n,
 				p = qdisc_lookup(dev, TC_H_MAJ(clid));
 				if (!p) {
 					NL_SET_ERR_MSG(extack, "Failed to find qdisc with specified classid");
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 				}
 				q = qdisc_leaf(p, clid);
 			} else if (dev_ingress_queue(dev)) {
@@ -1457,7 +1457,7 @@ static int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n,
 		}
 		if (!q) {
 			NL_SET_ERR_MSG(extack, "Cannot find specified qdisc on specified device");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (tcm->tcm_handle && q->handle != tcm->tcm_handle) {
@@ -1468,7 +1468,7 @@ static int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n,
 		q = qdisc_lookup(dev, tcm->tcm_handle);
 		if (!q) {
 			NL_SET_ERR_MSG(extack, "Failed to find qdisc with specified handle");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
@@ -1484,7 +1484,7 @@ static int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n,
 		}
 		if (q->handle == 0) {
 			NL_SET_ERR_MSG(extack, "Cannot delete qdisc with handle of zero");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		err = qdisc_graft(dev, p, skb, n, clid, NULL, q, extack);
 		if (err != 0)
@@ -1535,7 +1535,7 @@ static int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n,
 				p = qdisc_lookup(dev, TC_H_MAJ(clid));
 				if (!p) {
 					NL_SET_ERR_MSG(extack, "Failed to find specified qdisc");
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 				}
 				q = qdisc_leaf(p, clid);
 			} else if (dev_ingress_queue_create(dev)) {
@@ -1620,7 +1620,7 @@ static int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n,
 	/* Change qdisc parameters */
 	if (!q) {
 		NL_SET_ERR_MSG(extack, "Specified qdisc not found");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (n->nlmsg_flags & NLM_F_EXCL) {
 		NL_SET_ERR_MSG(extack, "Exclusivity flag on, cannot modify");
@@ -1638,7 +1638,7 @@ static int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n,
 create_n_graft:
 	if (!(n->nlmsg_flags & NLM_F_CREATE)) {
 		NL_SET_ERR_MSG(extack, "Qdisc not found. To create specify NLM_F_CREATE flag");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (clid == TC_H_INGRESS) {
 		if (dev_ingress_queue(dev)) {
@@ -2057,7 +2057,7 @@ static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n,
 	/* OK. Locate qdisc */
 	q = qdisc_lookup(dev, qid);
 	if (!q)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* An check that it supports classes */
 	cops = q->ops->cl_ops;
diff --git a/net/sched/sch_atm.c b/net/sched/sch_atm.c
index 1c281cc81..b5370baed 100644
--- a/net/sched/sch_atm.c
+++ b/net/sched/sch_atm.c
@@ -246,7 +246,7 @@ static int atm_tc_change(struct Qdisc *sch, u32 classid, u32 parent,
 		excess = (struct atm_flow_data *)
 			atm_tc_find(sch, nla_get_u32(tb[TCA_ATM_EXCESS]));
 		if (!excess)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 	pr_debug("atm_tc_change: type %d, payload %d, hdr_len %d\n",
 		 opt->nla_type, nla_len(opt), hdr_len);
diff --git a/net/sched/sch_cbs.c b/net/sched/sch_cbs.c
index 2eaac2ff3..06ea57119 100644
--- a/net/sched/sch_cbs.c
+++ b/net/sched/sch_cbs.c
@@ -480,7 +480,7 @@ static int cbs_dump_class(struct Qdisc *sch, unsigned long cl,
 	struct cbs_sched_data *q = qdisc_priv(sch);
 
 	if (cl != 1 || !q->qdisc)	/* only one class */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tcm->tcm_handle |= TC_H_MIN(1);
 	tcm->tcm_info = q->qdisc->handle;
diff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c
index 433f21909..c0d0c65da 100644
--- a/net/sched/sch_hfsc.c
+++ b/net/sched/sch_hfsc.c
@@ -1010,7 +1010,7 @@ hfsc_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
 	if (parentid) {
 		parent = hfsc_find_class(parentid, sch);
 		if (parent == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (classid == 0 || TC_H_MAJ(classid ^ sch->handle) != 0)
diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c
index 84f82771c..128f00dc6 100644
--- a/net/sched/sch_netem.c
+++ b/net/sched/sch_netem.c
@@ -1216,7 +1216,7 @@ static int netem_dump_class(struct Qdisc *sch, unsigned long cl,
 	struct netem_sched_data *q = qdisc_priv(sch);
 
 	if (cl != 1 || !q->qdisc) 	/* only one class */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tcm->tcm_handle |= TC_H_MIN(1);
 	tcm->tcm_info = q->qdisc->handle;
diff --git a/net/sched/sch_teql.c b/net/sched/sch_teql.c
index 2f1f0a378..76549b6c8 100644
--- a/net/sched/sch_teql.c
+++ b/net/sched/sch_teql.c
@@ -222,7 +222,7 @@ __teql_resolve(struct sk_buff *skb, struct sk_buff *skb_res,
 
 	n = dst_neigh_lookup_skb(dst, skb);
 	if (!n)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (dst->dev != dev) {
 		struct neighbour *mn;
diff --git a/net/sctp/input.c b/net/sctp/input.c
index 55d4fc6f3..87d5ab343 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -594,7 +594,7 @@ int sctp_v4_err(struct sk_buff *skb, __u32 info)
 	skb->transport_header = savesctp;
 	if (!sk) {
 		__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	/* Warning:  The sock lock is held.  Remember to call
 	 * sctp_err_finish!
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index d57e1a002..395059323 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -3983,7 +3983,7 @@ static int sctp_setsockopt_paddr_thresholds(struct sock *sk,
 		trans = sctp_addr_id2transport(sk, &val.spt_address,
 					       val.spt_assoc_id);
 		if (!trans)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (val.spt_pathmaxrxt)
 			trans->pathmaxrxt = val.spt_pathmaxrxt;
@@ -5446,7 +5446,7 @@ int sctp_transport_lookup_process(int (*cb)(struct sctp_transport *, void *),
 	transport = sctp_addrs_lookup_transport(net, laddr, paddr);
 	rcu_read_unlock();
 	if (!transport)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = cb(transport, p);
 	sctp_transport_put(transport);
@@ -7273,7 +7273,7 @@ static int sctp_getsockopt_paddr_thresholds(struct sock *sk,
 		trans = sctp_addr_id2transport(sk, &val.spt_address,
 					       val.spt_assoc_id);
 		if (!trans)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		val.spt_pathmaxrxt = trans->pathmaxrxt;
 		val.spt_pathpfthld = trans->pf_retrans;
diff --git a/net/smc/smc_clc.c b/net/smc/smc_clc.c
index 779f4142a..505bfd05b 100644
--- a/net/smc/smc_clc.c
+++ b/net/smc/smc_clc.c
@@ -109,7 +109,7 @@ static int smc_clc_prfx_set4_rcu(struct dst_entry *dst, __be32 ipv4,
 		/* prop->ipv6_prefixes_cnt = 0; already done by memset before */
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* fill CLC proposal msg with ipv6 prefixes from device */
@@ -139,7 +139,7 @@ static int smc_clc_prfx_set6_rcu(struct dst_entry *dst,
 	if (cnt)
 		return 0;
 #endif
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* retrieve and set prefixes in CLC proposal msg */
@@ -201,7 +201,7 @@ static int smc_clc_prfx_match4_rcu(struct net_device *dev,
 			return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* match ipv6 addrs of dev against addrs in CLC proposal */
@@ -230,7 +230,7 @@ static int smc_clc_prfx_match6_rcu(struct net_device *dev,
 		}
 	}
 #endif
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* check if proposed prefixes match one of our device prefixes */
diff --git a/net/smc/smc_core.c b/net/smc/smc_core.c
index f82a2e599..b7f2619d8 100644
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@ -1802,7 +1802,7 @@ static int smc_rtoken_find_by_link(struct smc_link_group *lgr, int lnk_idx,
 		    lgr->rtokens[i][lnk_idx].rkey == rkey)
 			return i;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* set rtoken for a new link to an existing rmb */
@@ -1881,7 +1881,7 @@ int smc_rtoken_delete(struct smc_link *lnk, __be32 nw_rkey)
 			return 0;
 		}
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* save rkey and dma_addr received from peer during clc handshake */
diff --git a/net/smc/smc_pnet.h b/net/smc/smc_pnet.h
index 811a65986..6f75b57bd 100644
--- a/net/smc/smc_pnet.h
+++ b/net/smc/smc_pnet.h
@@ -37,7 +37,7 @@ static inline int smc_pnetid_by_dev_port(struct device *dev,
 #if IS_ENABLED(CONFIG_HAVE_PNETID)
 	return pnet_id_by_dev_port(dev, port, pnetid);
 #else
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 #endif
 }
 
diff --git a/net/sunrpc/auth.c b/net/sunrpc/auth.c
index a9f0d17fd..e393fe7d0 100644
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -210,7 +210,7 @@ rpcauth_get_gssinfo(rpc_authflavor_t pseudoflavor, struct rpcsec_gss_info *info)
 
 	ops = rpcauth_get_authops(flavor);
 	if (ops == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	result = -ENOENT;
 	if (ops->flavor2info != NULL)
diff --git a/net/sunrpc/auth_gss/gss_mech_switch.c b/net/sunrpc/auth_gss/gss_mech_switch.c
index fae632da1..0ae7acfc5 100644
--- a/net/sunrpc/auth_gss/gss_mech_switch.c
+++ b/net/sunrpc/auth_gss/gss_mech_switch.c
@@ -285,7 +285,7 @@ int gss_mech_flavor2info(rpc_authflavor_t pseudoflavor,
 
 	gm = gss_mech_get_by_pseudoflavor(pseudoflavor);
 	if (gm == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (i = 0; i < gm->gm_pf_num; i++) {
 		if (gm->gm_pfs[i].pseudoflavor == pseudoflavor) {
@@ -299,7 +299,7 @@ int gss_mech_flavor2info(rpc_authflavor_t pseudoflavor,
 	}
 
 	gss_mech_put(gm);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 u32
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index baef5ee43..7e3c4f6a3 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -248,7 +248,7 @@ static inline int cache_is_valid(struct cache_head *h)
 	else {
 		/* entry is valid */
 		if (test_bit(CACHE_NEGATIVE, &h->flags))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		else {
 			/*
 			 * In combination with write barrier in
diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index a91d1cdad..370a876c8 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -190,7 +190,7 @@ static int __rpc_clnt_handle_event(struct rpc_clnt *clnt, unsigned long event,
 	case RPC_PIPEFS_MOUNT:
 		dentry = rpc_setup_pipedir_sb(sb, clnt);
 		if (!dentry)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (IS_ERR(dentry))
 			return PTR_ERR(dentry);
 		break;
diff --git a/net/sunrpc/svcauth_unix.c b/net/sunrpc/svcauth_unix.c
index 97c0bddba..c33ed5e51 100644
--- a/net/sunrpc/svcauth_unix.c
+++ b/net/sunrpc/svcauth_unix.c
@@ -235,7 +235,7 @@ static int ip_map_parse(struct cache_detail *cd,
 	if (len) {
 		dom = unix_domain_find(buf);
 		if (dom == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else
 		dom = NULL;
 
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 3385a7a0b..1ffcab285 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -2591,11 +2591,11 @@ static int unix_open_file(struct sock *sk)
 		return -EPERM;
 
 	if (!smp_load_acquire(&unix_sk(sk)->addr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	path = unix_sk(sk)->path;
 	if (!path.dentry)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	path_get(&path);
 
diff --git a/net/wireless/ap.c b/net/wireless/ap.c
index 550ac9d82..9c0c3f5eb 100644
--- a/net/wireless/ap.c
+++ b/net/wireless/ap.c
@@ -23,7 +23,7 @@ int __cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		return -EOPNOTSUPP;
 
 	if (!wdev->beacon_interval)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = rdev_stop_ap(rdev, dev);
 	if (!err) {
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index a6c61a2e6..96ce8db0b 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -256,7 +256,7 @@ int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
 				   IEEE80211_BSS_TYPE_ESS,
 				   IEEE80211_PRIVACY_ANY);
 	if (!req.bss)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = rdev_auth(rdev, dev, &req);
 
@@ -324,7 +324,7 @@ int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 				    IEEE80211_BSS_TYPE_ESS,
 				    IEEE80211_PRIVACY_ANY);
 	if (!req->bss)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = rdev_assoc(rdev, dev, req);
 	if (!err)
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 0e07fb858..182a44f23 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -3949,7 +3949,7 @@ static int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)
 		return -EOPNOTSUPP;
 
 	if (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!msg)
@@ -8029,7 +8029,7 @@ static int nl80211_abort_scan(struct sk_buff *skb, struct genl_info *info)
 		return 0;
 
 	if (!rdev->scan_req)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	rdev_abort_scan(rdev, wdev);
 	return 0;
@@ -8583,7 +8583,7 @@ static int nl80211_stop_sched_scan(struct sk_buff *skb,
 	if (!req || req->reqid ||
 	    (req->owner_nlportid &&
 	     req->owner_nlportid != info->snd_portid))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return cfg80211_stop_sched_scan_req(rdev, req, false);
 }
@@ -16445,7 +16445,7 @@ static int __nl80211_rx_control_port(struct net_device *dev,
 	u32 nlportid = READ_ONCE(wdev->conn_owner_nlportid);
 
 	if (!nlportid)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	msg = nlmsg_new(100 + skb->len, gfp);
 	if (!msg)
diff --git a/net/wireless/radiotap.c b/net/wireless/radiotap.c
index d5e28239e..924ef12bb 100644
--- a/net/wireless/radiotap.c
+++ b/net/wireless/radiotap.c
@@ -220,7 +220,7 @@ int ieee80211_radiotap_iterator_next(
 		/* if no more EXT bits, that's it */
 		if ((iterator->_arg_index % 32) == IEEE80211_RADIOTAP_EXT &&
 		    !(iterator->_bitmap_shifter & 1))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (!(iterator->_bitmap_shifter & 1))
 			goto next_entry; /* arg not present */
@@ -240,7 +240,7 @@ int ieee80211_radiotap_iterator_next(
 			if (!iterator->current_namespace ||
 			    iterator->_arg_index >= iterator->current_namespace->n_bits) {
 				if (iterator->current_namespace == &radiotap_ns)
-					return -ENOENT;
+					ENOENT_DUMPER(stackdump_tuneable);
 				align = 0;
 			} else {
 				align = iterator->current_namespace->align_size[iterator->_arg_index].align;
diff --git a/net/wireless/scan.c b/net/wireless/scan.c
index 74ea4cfb3..c60abfcec 100644
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -689,7 +689,7 @@ int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 
 	sched_scan_req = cfg80211_find_sched_scan_req(rdev, reqid);
 	if (!sched_scan_req)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return cfg80211_stop_sched_scan_req(rdev, sched_scan_req,
 					    driver_initiated);
diff --git a/net/wireless/sme.c b/net/wireless/sme.c
index 15595cf40..958261e46 100644
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@ -161,7 +161,7 @@ static int cfg80211_conn_do_work(struct wireless_dev *wdev,
 	switch (wdev->conn->state) {
 	case CFG80211_CONN_SCANNING:
 		/* didn't find it during scan ... */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	case CFG80211_CONN_SCAN_AGAIN:
 		return cfg80211_conn_scan(wdev);
 	case CFG80211_CONN_AUTHENTICATE_NEXT:
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 4d3b76f94..e904c2bad 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -1426,7 +1426,7 @@ int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
 	if (attr_remaining && desired_attr)
 		return -EILSEQ;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(cfg80211_get_p2p_attr);
 
diff --git a/net/xdp/xskmap.c b/net/xdp/xskmap.c
index 1dc7208c7..351cc2fab 100644
--- a/net/xdp/xskmap.c
+++ b/net/xdp/xskmap.c
@@ -127,7 +127,7 @@ static int xsk_map_get_next_key(struct bpf_map *map, void *key, void *next_key)
 	}
 
 	if (index == m->map.max_entries - 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*next = index + 1;
 	return 0;
 }
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 564aa6492..bd444fc3a 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -2247,7 +2247,7 @@ int xfrm_policy_delete(struct xfrm_policy *pol, int dir)
 		xfrm_policy_kill(pol);
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 EXPORT_SYMBOL(xfrm_policy_delete);
 
@@ -4327,7 +4327,7 @@ static int xfrm_policy_migrate(struct xfrm_policy *pol,
 	if (unlikely(pol->walk.dead)) {
 		/* target policy has been deleted */
 		write_unlock_bh(&pol->lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	for (i = 0; i < pol->xfrm_nr; i++) {
diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index e6cfaa680..80936d076 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -1903,7 +1903,7 @@ static int xfrm_get_policy(struct sk_buff *skb, struct nlmsghdr *nlh,
 		security_xfrm_policy_free(ctx);
 	}
 	if (xp == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!delete) {
 		struct sk_buff *resp_skb;
@@ -2203,7 +2203,7 @@ static int xfrm_add_pol_expire(struct sk_buff *skb, struct nlmsghdr *nlh,
 		security_xfrm_policy_free(ctx);
 	}
 	if (xp == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (unlikely(xp->walk.dead))
 		goto out;
diff --git a/samples/bpf/xdp_redirect_cpu_user.c b/samples/bpf/xdp_redirect_cpu_user.c
index f4e755e0d..df7b731ac 100644
--- a/samples/bpf/xdp_redirect_cpu_user.c
+++ b/samples/bpf/xdp_redirect_cpu_user.c
@@ -656,7 +656,7 @@ static int init_map_fds(struct bpf_object *obj)
 	    cpumap_kthread_cnt_map_fd < 0 || cpus_available_map_fd < 0 ||
 	    cpus_count_map_fd < 0 || cpus_iterator_map_fd < 0 ||
 	    exception_cnt_map_fd < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/samples/vfio-mdev/mbochs.c b/samples/vfio-mdev/mbochs.c
index 3cc5e5921..f69167d7c 100644
--- a/samples/vfio-mdev/mbochs.c
+++ b/samples/vfio-mdev/mbochs.c
@@ -1150,7 +1150,7 @@ static int mbochs_get_gfx_dmabuf(struct mdev_device *mdev,
 	dmabuf = mbochs_dmabuf_find_by_id(mdev_state, id);
 	if (!dmabuf) {
 		mutex_unlock(&mdev_state->ops_lock);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (!dmabuf->buf)
diff --git a/security/apparmor/apparmorfs.c b/security/apparmor/apparmorfs.c
index 5fd4a64e4..78abe95cc 100644
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -1225,7 +1225,7 @@ static int seq_rawdata_open(struct inode *inode, struct file *file,
 
 	if (!data)
 		/* lost race this ent is being reaped */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	error = single_open(file, show, data);
 	if (error) {
@@ -1364,7 +1364,7 @@ static int rawdata_open(struct inode *inode, struct file *file)
 	loaddata = __aa_get_loaddata(inode->i_private);
 	if (!loaddata)
 		/* lost race: this entry is being reaped */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	private = rawdata_f_data_alloc(loaddata->size);
 	if (IS_ERR(private)) {
diff --git a/security/apparmor/audit.c b/security/apparmor/audit.c
index 597732503..382d3bd75 100644
--- a/security/apparmor/audit.c
+++ b/security/apparmor/audit.c
@@ -231,7 +231,7 @@ int aa_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule)
 	label = aa_secid_to_label(sid);
 
 	if (!label)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (aa_label_is_subset(label, rule->label))
 		found = 1;
diff --git a/security/apparmor/mount.c b/security/apparmor/mount.c
index e0828ee7a..d0819b3c9 100644
--- a/security/apparmor/mount.c
+++ b/security/apparmor/mount.c
@@ -541,7 +541,7 @@ int aa_new_mount(struct aa_label *label, const char *dev_name,
 
 		if (requires_dev) {
 			if (!dev_name || !*dev_name)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 
 			error = kern_path(dev_name, LOOKUP_FOLLOW, &tmp_path);
 			if (error)
diff --git a/security/integrity/evm/evm_crypto.c b/security/integrity/evm/evm_crypto.c
index 168c3b78a..a46f02810 100644
--- a/security/integrity/evm/evm_crypto.c
+++ b/security/integrity/evm/evm_crypto.c
@@ -356,7 +356,7 @@ int evm_init_key(void)
 
 	evm_key = request_key(&key_type_encrypted, EVMKEY, NULL);
 	if (IS_ERR(evm_key))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	down_read(&evm_key->sem);
 	ekp = evm_key->payload.data[0];
diff --git a/security/integrity/ima/ima_modsig.c b/security/integrity/ima/ima_modsig.c
index d106885cc..d9a5e4a28 100644
--- a/security/integrity/ima/ima_modsig.c
+++ b/security/integrity/ima/ima_modsig.c
@@ -68,11 +68,11 @@ int ima_read_modsig(enum ima_hooks func, const void *buf, loff_t buf_len,
 	int rc;
 
 	if (buf_len <= marker_len + sizeof(*sig))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	p = buf + buf_len - marker_len;
 	if (memcmp(p, MODULE_SIG_STRING, marker_len))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	buf_len -= marker_len;
 	sig = (const struct module_signature *)(p - sizeof(*sig));
diff --git a/security/integrity/ima/ima_template.c b/security/integrity/ima/ima_template.c
index 5a2def40a..51e9f1fbb 100644
--- a/security/integrity/ima/ima_template.c
+++ b/security/integrity/ima/ima_template.c
@@ -211,7 +211,7 @@ int template_desc_init_fields(const char *template_fmt,
 		found_fields[i] = lookup_template_field(tmp_field_id);
 		if (!found_fields[i]) {
 			pr_err("field '%s' not found\n", tmp_field_id);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 14abfe765..374676fd2 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -1494,7 +1494,7 @@ static int __key_unlink_begin(struct key *keyring, struct key *key,
 		return PTR_ERR(edit);
 
 	if (!edit)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	*_edit = edit;
 	return 0;
diff --git a/security/selinux/include/security.h b/security/selinux/include/security.h
index b0e02cfe3..c2dcee96c 100644
--- a/security/selinux/include/security.h
+++ b/security/selinux/include/security.h
@@ -400,7 +400,7 @@ static inline int security_netlbl_sid_to_secattr(struct selinux_state *state,
 					 u32 sid,
 					 struct netlbl_lsm_secattr *secattr)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif /* CONFIG_NETLABEL */
 
diff --git a/security/selinux/netif.c b/security/selinux/netif.c
index 15b8c1bcd..830dbd605 100644
--- a/security/selinux/netif.c
+++ b/security/selinux/netif.c
@@ -144,7 +144,7 @@ static int sel_netif_sid_slow(struct net *ns, int ifindex, u32 *sid)
 	if (unlikely(dev == NULL)) {
 		pr_warn("SELinux: failure in %s(), invalid network interface (%d)\n",
 			__func__, ifindex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	spin_lock_bh(&sel_netif_lock);
diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.c
index ef0afd878..294e179c0 100644
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@ -3449,7 +3449,7 @@ int selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule)
 
 	if (unlikely(!rule)) {
 		WARN_ONCE(1, "selinux_audit_rule_match: missing rule\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	read_lock(&state->ss->policy_rwlock);
diff --git a/security/selinux/ss/sidtab.c b/security/selinux/ss/sidtab.c
index eb6d27b5a..0254c2882 100644
--- a/security/selinux/ss/sidtab.c
+++ b/security/selinux/ss/sidtab.c
@@ -571,7 +571,7 @@ int sidtab_sid2str_get(struct sidtab *s, struct sidtab_entry *entry,
 	int rc = 0;
 
 	if (entry->context.len)
-		return -ENOENT; /* do not cache invalid contexts */
+		ENOENT_DUMPER(stackdump_tuneable); /* do not cache invalid contexts */
 
 	rcu_read_lock();
 
diff --git a/security/selinux/ss/sidtab.h b/security/selinux/ss/sidtab.h
index f2a84560b..ba4f71439 100644
--- a/security/selinux/ss/sidtab.h
+++ b/security/selinux/ss/sidtab.h
@@ -144,7 +144,7 @@ static inline int sidtab_sid2str_get(struct sidtab *s,
 				     struct sidtab_entry *entry,
 				     char **out, u32 *out_len)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif /* CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE > 0 */
 
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index 8ffbf951b..eadbe791a 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -4471,7 +4471,7 @@ static int smack_audit_rule_match(u32 secid, u32 field, u32 op, void *vrule)
 
 	if (unlikely(!rule)) {
 		WARN_ONCE(1, "Smack: missing rule\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	if (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)
diff --git a/security/smack/smackfs.c b/security/smack/smackfs.c
index c21b656b3..6dd44a329 100644
--- a/security/smack/smackfs.c
+++ b/security/smack/smackfs.c
@@ -334,7 +334,7 @@ static int smk_fill_rule(const char *subject, const char *object,
 		skp = smk_find_entry(cp);
 		kfree(cp);
 		if (skp == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		rule->smk_subject = skp;
 
 		cp = smk_parse_smack(object, len);
@@ -343,7 +343,7 @@ static int smk_fill_rule(const char *subject, const char *object,
 		skp = smk_find_entry(cp);
 		kfree(cp);
 		if (skp == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		rule->smk_object = skp;
 	}
 
diff --git a/security/tomoyo/common.c b/security/tomoyo/common.c
index c16b8c1b0..ee1de38bd 100644
--- a/security/tomoyo/common.c
+++ b/security/tomoyo/common.c
@@ -2637,7 +2637,7 @@ static int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)
 			head->w.ns = &tomoyo_kernel_namespace;
 		/* Don't allow updating if namespace is invalid. */
 		if (!head->w.ns)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 	/* Do the update. */
 	return head->write(head);
diff --git a/sound/core/control.c b/sound/core/control.c
index aa0c0cf18..3412db5c0 100644
--- a/sound/core/control.c
+++ b/sound/core/control.c
@@ -496,7 +496,7 @@ int snd_ctl_remove_id(struct snd_card *card, struct snd_ctl_elem_id *id)
 	kctl = snd_ctl_find_id(card, id);
 	if (kctl == NULL) {
 		up_write(&card->controls_rwsem);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	ret = snd_ctl_remove(card, kctl);
 	up_write(&card->controls_rwsem);
@@ -613,7 +613,7 @@ int snd_ctl_rename_id(struct snd_card *card, struct snd_ctl_elem_id *src_id,
 	kctl = snd_ctl_find_id(card, src_id);
 	if (kctl == NULL) {
 		up_write(&card->controls_rwsem);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	kctl->id = *dst_id;
 	kctl->id.numid = card->last_numid + 1;
@@ -1028,7 +1028,7 @@ static int snd_ctl_elem_read(struct snd_card *card,
 
 	kctl = snd_ctl_find_id(card, &control->id);
 	if (kctl == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	index_offset = snd_ctl_get_ioff(kctl, &control->id);
 	vd = &kctl->vd[index_offset];
@@ -1100,7 +1100,7 @@ static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,
 
 	kctl = snd_ctl_find_id(card, &control->id);
 	if (kctl == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	index_offset = snd_ctl_get_ioff(kctl, &control->id);
 	vd = &kctl->vd[index_offset];
@@ -1663,7 +1663,7 @@ static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,
 
 	kctl = snd_ctl_find_numid(file->card, header.numid);
 	if (kctl == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Calculate index of the element in this set. */
 	id = kctl->id;
diff --git a/sound/core/control_compat.c b/sound/core/control_compat.c
index d55be1db1..4c60ca207 100644
--- a/sound/core/control_compat.c
+++ b/sound/core/control_compat.c
@@ -181,7 +181,7 @@ static int get_ctl_type(struct snd_card *card, struct snd_ctl_elem_id *id,
 	kctl = snd_ctl_find_id(card, id);
 	if (! kctl) {
 		up_read(&card->controls_rwsem);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (info == NULL) {
diff --git a/sound/core/init.c b/sound/core/init.c
index b02a99766..812bfa322 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -975,7 +975,7 @@ int snd_card_file_remove(struct snd_card *card, struct file *file)
 	spin_unlock(&card->files_lock);
 	if (!found) {
 		dev_err(card->dev, "card file remove problem (%p)\n", file);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	kfree(found);
 	put_device(&card->card_dev);
diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
index 2a688b711..c5fabc727 100644
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -624,7 +624,7 @@ static int __snd_rawmidi_info_select(struct snd_card *card,
 	info->stream = array_index_nospec(info->stream, 2);
 	pstr = &rmidi->streams[info->stream];
 	if (pstr->substream_count == 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if (info->subdevice >= pstr->substream_count)
 		return -ENXIO;
 	list_for_each_entry(substream, &pstr->substreams, list) {
diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c
index cc93157fa..1054192ad 100644
--- a/sound/core/seq/seq_clientmgr.c
+++ b/sound/core/seq/seq_clientmgr.c
@@ -1194,7 +1194,7 @@ static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)
 	/* requested client number */
 	cptr = snd_seq_client_use_ptr(info->client);
 	if (cptr == NULL)
-		return -ENOENT;		/* don't change !!! */
+		ENOENT_DUMPER(stackdump_tuneable);		/* don't change !!! */
 
 #ifdef SNDRV_BIG_ENDIAN
 	if (!info->big_endian) {
@@ -1254,7 +1254,7 @@ static int snd_seq_ioctl_get_client_info(struct snd_seq_client *client,
 	/* requested client number */
 	cptr = snd_seq_client_use_ptr(client_info->client);
 	if (cptr == NULL)
-		return -ENOENT;		/* don't change !!! */
+		ENOENT_DUMPER(stackdump_tuneable);		/* don't change !!! */
 
 	get_client_info(cptr, client_info);
 	snd_seq_client_unlock(cptr);
@@ -1370,7 +1370,7 @@ static int snd_seq_ioctl_get_port_info(struct snd_seq_client *client, void *arg)
 	port = snd_seq_port_use_ptr(cptr, info->addr.port);
 	if (port == NULL) {
 		snd_seq_client_unlock(cptr);
-		return -ENOENT;			/* don't change */
+		ENOENT_DUMPER(stackdump_tuneable);			/* don't change */
 	}
 
 	/* get port info */
@@ -1825,7 +1825,7 @@ static int snd_seq_ioctl_get_client_pool(struct snd_seq_client *client,
 
 	cptr = snd_seq_client_use_ptr(info->client);
 	if (cptr == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	memset(info, 0, sizeof(*info));
 	info->client = cptr->number;
 	info->output_pool = cptr->pool->size;
@@ -2026,7 +2026,7 @@ static int snd_seq_ioctl_query_next_client(struct snd_seq_client *client,
 			break; /* found */
 	}
 	if (cptr == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	get_client_info(cptr, info);
 	snd_seq_client_unlock(cptr);
@@ -2053,7 +2053,7 @@ static int snd_seq_ioctl_query_next_port(struct snd_seq_client *client,
 	port = snd_seq_port_query_nearest(cptr, info);
 	if (port == NULL) {
 		snd_seq_client_unlock(cptr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* get port info */
diff --git a/sound/core/seq/seq_midi_event.c b/sound/core/seq/seq_midi_event.c
index 7511462fe..ce91d607f 100644
--- a/sound/core/seq/seq_midi_event.c
+++ b/sound/core/seq/seq_midi_event.c
@@ -293,7 +293,7 @@ long snd_midi_event_decode(struct snd_midi_event *dev, unsigned char *buf, long
 	unsigned int cmd, type;
 
 	if (ev->type == SNDRV_SEQ_EVENT_NONE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (type = 0; type < ARRAY_SIZE(status_event); type++) {
 		if (ev->type == status_event[type].event)
@@ -303,7 +303,7 @@ long snd_midi_event_decode(struct snd_midi_event *dev, unsigned char *buf, long
 		if (ev->type == extra_event[type].event)
 			return extra_event[type].decode(dev, buf, count, ev);
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 
       __found:
 	if (type >= ST_SPECIAL)
diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c
index 83be6b982..827b5df79 100644
--- a/sound/core/seq/seq_ports.c
+++ b/sound/core/seq/seq_ports.c
@@ -285,7 +285,7 @@ int snd_seq_delete_port(struct snd_seq_client *client, int port)
 	if (found)
 		return port_delete(client, found);
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* delete the all ports belonging to the given client */
diff --git a/sound/core/sound.c b/sound/core/sound.c
index b75f78f2c..836954b86 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -311,7 +311,7 @@ int snd_unregister_device(struct device *dev)
 	}
 	mutex_unlock(&sound_mutex);
 	if (minor >= ARRAY_SIZE(snd_minors))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return 0;
 }
 EXPORT_SYMBOL(snd_unregister_device);
diff --git a/sound/core/sound_oss.c b/sound/core/sound_oss.c
index 610f317be..37925e429 100644
--- a/sound/core/sound_oss.c
+++ b/sound/core/sound_oss.c
@@ -160,7 +160,7 @@ int snd_unregister_oss_device(int type, struct snd_card *card, int dev)
 	mptr = snd_oss_minors[minor];
 	if (mptr == NULL) {
 		mutex_unlock(&sound_oss_mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	unregister_sound_special(minor);
 	switch (SNDRV_MINOR_OSS_DEVICE(minor)) {
diff --git a/sound/core/vmaster.c b/sound/core/vmaster.c
index ab54d7965..aab150329 100644
--- a/sound/core/vmaster.c
+++ b/sound/core/vmaster.c
@@ -131,7 +131,7 @@ static int master_init(struct link_master *master)
 			master->hook(master->hook_private_data, master->val);
 		return 1;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int slave_get_val(struct link_slave *slave,
diff --git a/sound/drivers/mts64.c b/sound/drivers/mts64.c
index 9c708b693..02def3ae6 100644
--- a/sound/drivers/mts64.c
+++ b/sound/drivers/mts64.c
@@ -920,7 +920,7 @@ static int snd_mts64_probe(struct platform_device *pdev)
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
 	if (!enable[dev]) 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = snd_card_new(&pdev->dev, index[dev], id[dev], THIS_MODULE,
 			   0, &card);
diff --git a/sound/drivers/portman2x4.c b/sound/drivers/portman2x4.c
index 38603cb2b..b82699161 100644
--- a/sound/drivers/portman2x4.c
+++ b/sound/drivers/portman2x4.c
@@ -719,7 +719,7 @@ static int snd_portman_probe(struct platform_device *pdev)
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
 	if (!enable[dev]) 
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = snd_card_new(&pdev->dev, index[dev], id[dev], THIS_MODULE,
 			   0, &card);
diff --git a/sound/drivers/vx/vx_hwdep.c b/sound/drivers/vx/vx_hwdep.c
index 01baa6d87..77afd94a5 100644
--- a/sound/drivers/vx/vx_hwdep.c
+++ b/sound/drivers/vx/vx_hwdep.c
@@ -60,7 +60,7 @@ int snd_vx_setup_firmware(struct vx_core *chip)
 		sprintf(path, "vx/%s", fw_files[chip->type][i]);
 		if (request_firmware(&fw, path, chip->dev)) {
 			snd_printk(KERN_ERR "vx: can't load firmware %s\n", path);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		err = chip->ops->load_dsp(chip, i, fw);
 		if (err < 0) {
diff --git a/sound/isa/cs423x/cs4236.c b/sound/isa/cs423x/cs4236.c
index fa3c39cff..a84b5d6ce 100644
--- a/sound/isa/cs423x/cs4236.c
+++ b/sound/isa/cs423x/cs4236.c
@@ -548,7 +548,7 @@ static int snd_cs423x_pnpbios_detect(struct pnp_dev *pdev,
 	char cid[PNP_ID_LEN];
 
 	if (pnp_device_is_isapnp(pdev))
-		return -ENOENT;	/* we have another procedure - card */
+		ENOENT_DUMPER(stackdump_tuneable);	/* we have another procedure - card */
 	for (; dev < SNDRV_CARDS; dev++) {
 		if (enable[dev] && isapnp[dev])
 			break;
diff --git a/sound/isa/es18xx.c b/sound/isa/es18xx.c
index d1135f6ae..5cbad05c3 100644
--- a/sound/isa/es18xx.c
+++ b/sound/isa/es18xx.c
@@ -2255,7 +2255,7 @@ static int snd_audiodrive_pnp_detect(struct pnp_dev *pdev,
 	struct snd_card *card;
 
 	if (pnp_device_is_isapnp(pdev))
-		return -ENOENT;	/* we have another procedure - card */
+		ENOENT_DUMPER(stackdump_tuneable);	/* we have another procedure - card */
 	for (; dev < SNDRV_CARDS; dev++) {
 		if (enable[dev] && isapnp[dev])
 			break;
diff --git a/sound/isa/gus/interwave.c b/sound/isa/gus/interwave.c
index 3e9ad930d..4d4a3bf12 100644
--- a/sound/isa/gus/interwave.c
+++ b/sound/isa/gus/interwave.c
@@ -563,7 +563,7 @@ static int snd_interwave_pnp(int dev, struct snd_interwave *iwcard,
 	if (pnp_port_start(pdev, 0) + 0x100 != pnp_port_start(pdev, 1) ||
 	    pnp_port_start(pdev, 0) + 0x10c != pnp_port_start(pdev, 2)) {
 		snd_printk(KERN_ERR "PnP configure failure (wrong ports)\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	port[dev] = pnp_port_start(pdev, 0);
 	dma1[dev] = pnp_dma(pdev, 0);
diff --git a/sound/isa/opl3sa2.c b/sound/isa/opl3sa2.c
index 85a181acd..5b068ce1f 100644
--- a/sound/isa/opl3sa2.c
+++ b/sound/isa/opl3sa2.c
@@ -715,7 +715,7 @@ static int snd_opl3sa2_pnp_detect(struct pnp_dev *pdev,
 	struct snd_card *card;
 
 	if (pnp_device_is_isapnp(pdev))
-		return -ENOENT;	/* we have another procedure - card */
+		ENOENT_DUMPER(stackdump_tuneable);	/* we have another procedure - card */
 	for (; dev < SNDRV_CARDS; dev++) {
 		if (enable[dev] && isapnp[dev])
 			break;
diff --git a/sound/mips/sgio2audio.c b/sound/mips/sgio2audio.c
index 5bf1ea150..06a4ad6c5 100644
--- a/sound/mips/sgio2audio.c
+++ b/sound/mips/sgio2audio.c
@@ -796,7 +796,7 @@ static int snd_sgio2audio_create(struct snd_card *card,
 	/* check if a codec is attached to the interface */
 	/* (Audio or Audio/Video board present) */
 	if (!(readq(&mace->perif.audio.control) & AUDIO_CONTROL_CODEC_PRESENT))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL)
diff --git a/sound/pci/ac97/ac97_codec.c b/sound/pci/ac97/ac97_codec.c
index 6758c0720..578b91e79 100644
--- a/sound/pci/ac97/ac97_codec.c
+++ b/sound/pci/ac97/ac97_codec.c
@@ -2623,7 +2623,7 @@ static int snd_ac97_rename_ctl(struct snd_ac97 *ac97, const char *src,
 		set_ctl_name(kctl->id.name, dst, suffix);
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* rename both Volume and Switch controls - don't check the return value */
@@ -2646,7 +2646,7 @@ static int snd_ac97_swap_ctl(struct snd_ac97 *ac97, const char *s1,
 		set_ctl_name(kctl2->id.name, s1, suffix);
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #if 1
@@ -2669,7 +2669,7 @@ static int tune_hp_only(struct snd_ac97 *ac97)
 	struct snd_kcontrol *msw = ctl_find(ac97, "Master Playback Switch", NULL);
 	struct snd_kcontrol *mvol = ctl_find(ac97, "Master Playback Volume", NULL);
 	if (! msw || ! mvol)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	msw->put = bind_hp_volsw_put;
 	mvol->put = bind_hp_volsw_put;
 	snd_ac97_remove_ctl(ac97, "Headphone Playback", "Switch");
@@ -2682,7 +2682,7 @@ static int tune_hp_only(struct snd_ac97 *ac97)
 static int tune_hp_only(struct snd_ac97 *ac97)
 {
 	if (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	snd_ac97_remove_ctl(ac97, "Master Playback", "Switch");
 	snd_ac97_remove_ctl(ac97, "Master Playback", "Volume");
 	snd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Master Playback");
@@ -2694,7 +2694,7 @@ static int tune_hp_only(struct snd_ac97 *ac97)
 static int tune_swap_hp(struct snd_ac97 *ac97)
 {
 	if (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	snd_ac97_rename_vol_ctl(ac97, "Master Playback", "Line-Out Playback");
 	snd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Master Playback");
 	return 0;
@@ -2705,7 +2705,7 @@ static int tune_swap_surround(struct snd_ac97 *ac97)
 {
 	if (snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Switch") ||
 	    snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Volume"))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	return 0;
 }
 
@@ -2746,7 +2746,7 @@ static int tune_inv_eapd(struct snd_ac97 *ac97)
 {
 	struct snd_kcontrol *kctl = ctl_find(ac97, "External Amplifier", NULL);
 	if (! kctl)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	set_inv_eapd(ac97, kctl);
 	return 0;
 }
@@ -2775,7 +2775,7 @@ static int tune_mute_led(struct snd_ac97 *ac97)
 {
 	struct snd_kcontrol *msw = ctl_find(ac97, "Master Playback Switch", NULL);
 	if (! msw)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	msw->put = master_mute_sw_put;
 	snd_ac97_remove_ctl(ac97, "External Amplifier", NULL);
 	snd_ac97_update_bits(
@@ -2811,7 +2811,7 @@ static int tune_hp_mute_led(struct snd_ac97 *ac97)
 	struct snd_kcontrol *msw = ctl_find(ac97, "Master Playback Switch", NULL);
 	struct snd_kcontrol *mvol = ctl_find(ac97, "Master Playback Volume", NULL);
 	if (! msw || ! mvol)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	msw->put = hp_master_mute_sw_put;
 	mvol->put = bind_hp_volsw_put;
 	snd_ac97_remove_ctl(ac97, "External Amplifier", NULL);
diff --git a/sound/pci/ad1889.c b/sound/pci/ad1889.c
index 5d42c4249..cc71d2a25 100644
--- a/sound/pci/ad1889.c
+++ b/sound/pci/ad1889.c
@@ -937,7 +937,7 @@ snd_ad1889_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[devno]) {
 		devno++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* (2) */
diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 8d2471ea0..86c1ef489 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -732,7 +732,7 @@ static int snd_als300_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/als4000.c b/sound/pci/als4000.c
index ba6390e9a..468a0bf61 100644
--- a/sound/pci/als4000.c
+++ b/sound/pci/als4000.c
@@ -829,7 +829,7 @@ static int snd_card_als4000_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* enable PCI device */
diff --git a/sound/pci/asihpi/asihpi.c b/sound/pci/asihpi/asihpi.c
index a9540c2c4..f703b6f55 100644
--- a/sound/pci/asihpi/asihpi.c
+++ b/sound/pci/asihpi/asihpi.c
@@ -2822,7 +2822,7 @@ static int snd_asihpi_probe(struct pci_dev *pci_dev,
 	/* Should this be enable[hpi->index] ? */
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Initialise low-level HPI driver */
diff --git a/sound/pci/au88x0/au88x0.c b/sound/pci/au88x0/au88x0.c
index be276fb3f..3383776c8 100644
--- a/sound/pci/au88x0/au88x0.c
+++ b/sound/pci/au88x0/au88x0.c
@@ -246,7 +246,7 @@ snd_vortex_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	// (2)
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/aw2/aw2-alsa.c b/sound/pci/aw2/aw2-alsa.c
index f1865afed..60aef7663 100644
--- a/sound/pci/aw2/aw2-alsa.c
+++ b/sound/pci/aw2/aw2-alsa.c
@@ -320,7 +320,7 @@ static int snd_aw2_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* (2) Create card instance */
diff --git a/sound/pci/bt87x.c b/sound/pci/bt87x.c
index 656750466..add4a703c 100644
--- a/sound/pci/bt87x.c
+++ b/sound/pci/bt87x.c
@@ -865,7 +865,7 @@ static int snd_bt87x_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		++dev;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/ca0106/ca0106_main.c b/sound/pci/ca0106/ca0106_main.c
index 70d775ff9..24b94069a 100644
--- a/sound/pci/ca0106/ca0106_main.c
+++ b/sound/pci/ca0106/ca0106_main.c
@@ -1779,7 +1779,7 @@ static int snd_ca0106_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/ca0106/ca0106_mixer.c b/sound/pci/ca0106/ca0106_mixer.c
index 3b8ec673d..21bf471c0 100644
--- a/sound/pci/ca0106/ca0106_mixer.c
+++ b/sound/pci/ca0106/ca0106_mixer.c
@@ -723,7 +723,7 @@ static int rename_ctl(struct snd_card *card, const char *src, const char *dst)
 		strcpy(kctl->id.name, dst);
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 #define ADD_CTLS(emu, ctls)						\
diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 7363d61ea..782a6f1b5 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3238,7 +3238,7 @@ static int snd_cmipci_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (! enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 94d2a6a46..01d2ff64b 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1874,7 +1874,7 @@ static int snd_cs4281_probe(struct pci_dev *pci,
                 return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/cs46xx/cs46xx.c b/sound/pci/cs46xx/cs46xx.c
index a6e0a4439..88da8a5ad 100644
--- a/sound/pci/cs46xx/cs46xx.c
+++ b/sound/pci/cs46xx/cs46xx.c
@@ -70,7 +70,7 @@ static int snd_card_cs46xx_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/cs5530.c b/sound/pci/cs5530.c
index 20b4faea5..cb7b51e6e 100644
--- a/sound/pci/cs5530.c
+++ b/sound/pci/cs5530.c
@@ -250,7 +250,7 @@ static int snd_cs5530_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/cs5535audio/cs5535audio.c b/sound/pci/cs5535audio/cs5535audio.c
index 11ce3c458..b0eeeb681 100644
--- a/sound/pci/cs5535audio/cs5535audio.c
+++ b/sound/pci/cs5535audio/cs5535audio.c
@@ -333,7 +333,7 @@ static int snd_cs5535audio_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/ctxfi/ctatc.c b/sound/pci/ctxfi/ctatc.c
index e56a230f6..664f8b207 100644
--- a/sound/pci/ctxfi/ctatc.c
+++ b/sound/pci/ctxfi/ctatc.c
@@ -144,7 +144,7 @@ static int ct_map_audio_buffer(struct ct_atc *atc, struct ct_atc_pcm *apcm)
 	apcm->vm_block = vm->map(vm, apcm->substream, runtime->dma_bytes);
 
 	if (!apcm->vm_block)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -233,7 +233,7 @@ static int select_rom(unsigned int pitch)
 		/* 0 <= pitch <= 8 */
 		return 0;
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 }
 
@@ -872,7 +872,7 @@ spdif_passthru_playback_setup(struct ct_atc *atc, struct ct_atc_pcm *apcm)
 		iec958_con_fs = IEC958_AES3_CON_FS_32000;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	mutex_lock(&atc->atc_mutex);
@@ -1269,7 +1269,7 @@ static int atc_identify_card(struct ct_atc *atc, unsigned int ssid)
 		list = subsys_20k2_list;
 		break;
 	default:
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (ssid) {
 		vendor_id = ssid >> 16;
@@ -1284,7 +1284,7 @@ static int atc_identify_card(struct ct_atc *atc, unsigned int ssid)
 			dev_err(atc->card->dev,
 				"Device %04x:%04x is black-listed\n",
 				vendor_id, device_id);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		atc->model = p->value;
 	} else {
diff --git a/sound/pci/ctxfi/ctdaio.c b/sound/pci/ctxfi/ctdaio.c
index 4cb47b5a7..b1ae9711b 100644
--- a/sound/pci/ctxfi/ctdaio.c
+++ b/sound/pci/ctxfi/ctdaio.c
@@ -506,7 +506,7 @@ static int dai_rsc_uninit(struct dai *dai)
 static int daio_mgr_get_rsc(struct rsc_mgr *mgr, enum DAIOTYP type)
 {
 	if (((struct daio_usage *)mgr->rscs)->data & (0x1 << type))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	((struct daio_usage *)mgr->rscs)->data |= (0x1 << type);
 
diff --git a/sound/pci/ctxfi/cthw20k1.c b/sound/pci/ctxfi/cthw20k1.c
index 015c0d676..6081a3d03 100644
--- a/sound/pci/ctxfi/cthw20k1.c
+++ b/sound/pci/ctxfi/cthw20k1.c
@@ -1807,7 +1807,7 @@ static int uaa_to_xfi(struct pci_dev *pci)
 	io_base = pci_resource_start(pci, 0);
 	mem_base = ioremap(io_base, pci_resource_len(pci, 0));
 	if (!mem_base)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/* Read current mode from Mode Change Register */
 	for (i = 0; i < 4; i++)
diff --git a/sound/pci/ctxfi/ctresource.c b/sound/pci/ctxfi/ctresource.c
index 61e51e35b..34347d6d5 100644
--- a/sound/pci/ctxfi/ctresource.c
+++ b/sound/pci/ctxfi/ctresource.c
@@ -39,7 +39,7 @@ get_resource(u8 *rscs, unsigned int amount,
 
 	if (i >= amount) {
 		/* Can not find sufficient contiguous resources */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* Mark the contiguous bits in resource bit-map as used */
@@ -75,7 +75,7 @@ int mgr_get_resource(struct rsc_mgr *mgr, unsigned int n, unsigned int *ridx)
 	int err;
 
 	if (n > mgr->avail)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	err = get_resource(mgr->rscs, mgr->amount, n, ridx);
 	if (!err)
diff --git a/sound/pci/ctxfi/xfi.c b/sound/pci/ctxfi/xfi.c
index 8c07c6463..fd2ae259f 100644
--- a/sound/pci/ctxfi/xfi.c
+++ b/sound/pci/ctxfi/xfi.c
@@ -66,7 +66,7 @@ ct_card_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
 			   0, &card);
diff --git a/sound/pci/echoaudio/echoaudio.c b/sound/pci/echoaudio/echoaudio.c
index 0941a7a17..03fd6348a 100644
--- a/sound/pci/echoaudio/echoaudio.c
+++ b/sound/pci/echoaudio/echoaudio.c
@@ -1961,7 +1961,7 @@ static int snd_echo_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	i = 0;
diff --git a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c
index 29b7720d7..c0a7e6f7c 100644
--- a/sound/pci/emu10k1/emu10k1.c
+++ b/sound/pci/emu10k1/emu10k1.c
@@ -98,7 +98,7 @@ static int snd_card_emu10k1_probe(struct pci_dev *pci,
         	return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c
index 6ff581733..774da2c48 100644
--- a/sound/pci/emu10k1/emu10k1_main.c
+++ b/sound/pci/emu10k1/emu10k1_main.c
@@ -1852,7 +1852,7 @@ int snd_emu10k1_create(struct snd_card *card,
 		dev_err(card->dev, "emu10k1: Card not recognised\n");
 		kfree(emu);
 		pci_disable_device(pci);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	emu->card_capabilities = c;
 	if (c->subsystem && !subsystem)
diff --git a/sound/pci/emu10k1/emu10k1x.c b/sound/pci/emu10k1/emu10k1x.c
index def8161cd..9bf9f05fc 100644
--- a/sound/pci/emu10k1/emu10k1x.c
+++ b/sound/pci/emu10k1/emu10k1x.c
@@ -1536,7 +1536,7 @@ static int snd_emu10k1x_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/emu10k1/emufx.c b/sound/pci/emu10k1/emufx.c
index 4e76ed0e9..ea1763541 100644
--- a/sound/pci/emu10k1/emufx.c
+++ b/sound/pci/emu10k1/emufx.c
@@ -748,7 +748,7 @@ static int snd_emu10k1_verify_controls(struct snd_emu10k1 *emu,
 		if (err < 0)
 			return err;
 		if (snd_emu10k1_look_for_ctl(emu, &id) == NULL)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	}
 	gctl = kmalloc(sizeof(*gctl), GFP_KERNEL);
 	if (! gctl)
diff --git a/sound/pci/emu10k1/emumixer.c b/sound/pci/emu10k1/emumixer.c
index 8a6cbe67e..b379ba3a4 100644
--- a/sound/pci/emu10k1/emumixer.c
+++ b/sound/pci/emu10k1/emumixer.c
@@ -1769,7 +1769,7 @@ static int rename_ctl(struct snd_card *card, const char *src, const char *dst)
 		strcpy(kctl->id.name, dst);
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int snd_emu10k1_mixer(struct snd_emu10k1 *emu,
diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d9acef082..100ffd914 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2357,7 +2357,7 @@ static int snd_audiopci_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/es1938.c b/sound/pci/es1938.c
index b4a0adf74..cc0f5835a 100644
--- a/sound/pci/es1938.c
+++ b/sound/pci/es1938.c
@@ -1755,7 +1755,7 @@ static int snd_es1938_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index d26004b35..cacd940a2 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2797,7 +2797,7 @@ static int snd_es1968_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c
index 181ebafa5..933af5d15 100644
--- a/sound/pci/fm801.c
+++ b/sound/pci/fm801.c
@@ -1295,7 +1295,7 @@ static int snd_card_fm801_probe(struct pci_dev *pci,
                 return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index 3565e2ab0..e342ae9f7 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -2110,7 +2110,7 @@ static int azx_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/sound/pci/hda/hda_local.h b/sound/pci/hda/hda_local.h
index 3dca65d79..ad3df5ef3 100644
--- a/sound/pci/hda/hda_local.h
+++ b/sound/pci/hda/hda_local.h
@@ -574,13 +574,13 @@ const char *snd_hda_get_hint(struct hda_codec *codec, const char *key)
 static inline
 int snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static inline
 int snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)
 {
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 #endif
 
diff --git a/sound/pci/ice1712/delta.c b/sound/pci/ice1712/delta.c
index 81929063b..92ca3fc11 100644
--- a/sound/pci/ice1712/delta.c
+++ b/sound/pci/ice1712/delta.c
@@ -157,7 +157,7 @@ static int ap_cs8427_probeaddr(struct snd_i2c_bus *bus, unsigned short addr)
 {
 	if (addr == 0x10)
 		return 1;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const struct snd_i2c_ops ap_cs8427_i2c_ops = {
diff --git a/sound/pci/ice1712/ice1712.c b/sound/pci/ice1712/ice1712.c
index 73e1e5400..dfa8995a8 100644
--- a/sound/pci/ice1712/ice1712.c
+++ b/sound/pci/ice1712/ice1712.c
@@ -2594,7 +2594,7 @@ static int snd_ice1712_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/ice1712/ice1724.c b/sound/pci/ice1712/ice1724.c
index c0fca94c1..f8b34af5f 100644
--- a/sound/pci/ice1712/ice1724.c
+++ b/sound/pci/ice1712/ice1724.c
@@ -2599,7 +2599,7 @@ static int snd_vt1724_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index ffa9d8860..7807e0de4 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -681,7 +681,7 @@ static int se_init(struct snd_ice1712 *ice)
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int se_add_controls(struct snd_ice1712 *ice)
diff --git a/sound/pci/korg1212/korg1212.c b/sound/pci/korg1212/korg1212.c
index 65a887b21..948c66f1d 100644
--- a/sound/pci/korg1212/korg1212.c
+++ b/sound/pci/korg1212/korg1212.c
@@ -2428,7 +2428,7 @@ snd_korg1212_probe(struct pci_dev *pci,
 	}
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
 			   0, &card);
diff --git a/sound/pci/lola/lola.c b/sound/pci/lola/lola.c
index cdd8db79b..6c0b6185e 100644
--- a/sound/pci/lola/lola.c
+++ b/sound/pci/lola/lola.c
@@ -698,7 +698,7 @@ static int lola_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/lx6464es/lx6464es.c b/sound/pci/lx6464es/lx6464es.c
index b92ea074f..88e9ca32c 100644
--- a/sound/pci/lx6464es/lx6464es.c
+++ b/sound/pci/lx6464es/lx6464es.c
@@ -1062,7 +1062,7 @@ static int snd_lx6464es_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/maestro3.c b/sound/pci/maestro3.c
index 40232a278..cca9e965b 100644
--- a/sound/pci/maestro3.c
+++ b/sound/pci/maestro3.c
@@ -2700,7 +2700,7 @@ snd_m3_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/mixart/mixart.c b/sound/pci/mixart/mixart.c
index 7ba487443..2f232b400 100644
--- a/sound/pci/mixart/mixart.c
+++ b/sound/pci/mixart/mixart.c
@@ -1240,7 +1240,7 @@ static int snd_mixart_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (! enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* enable PCI device */
diff --git a/sound/pci/mixart/mixart_hwdep.c b/sound/pci/mixart/mixart_hwdep.c
index 13dcb2fd0..497224cb6 100644
--- a/sound/pci/mixart/mixart_hwdep.c
+++ b/sound/pci/mixart/mixart_hwdep.c
@@ -561,7 +561,7 @@ int snd_mixart_setup_firmware(struct mixart_mgr *mgr)
 		if (request_firmware(&fw_entry, path, &mgr->pci->dev)) {
 			dev_err(&mgr->pci->dev,
 				"miXart: can't load firmware %s\n", path);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		/* fake hwdep dsp record */
 		err = mixart_dsp_load(mgr, i, fw_entry);
diff --git a/sound/pci/oxygen/oxygen.c b/sound/pci/oxygen/oxygen.c
index a751fcce7..52656dd41 100644
--- a/sound/pci/oxygen/oxygen.c
+++ b/sound/pci/oxygen/oxygen.c
@@ -844,7 +844,7 @@ static int generic_oxygen_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		++dev;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	err = oxygen_pci_probe(pci, index[dev], id[dev], THIS_MODULE,
 			       oxygen_ids, get_oxygen_model);
diff --git a/sound/pci/oxygen/se6x.c b/sound/pci/oxygen/se6x.c
index 78c35a0a5..97f2eed6d 100644
--- a/sound/pci/oxygen/se6x.c
+++ b/sound/pci/oxygen/se6x.c
@@ -125,7 +125,7 @@ static int se6x_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENODEV;
 	if (!enable[dev]) {
 		++dev;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	err = oxygen_pci_probe(pci, index[dev], id[dev], THIS_MODULE,
 			       se6x_ids, se6x_get_model);
diff --git a/sound/pci/oxygen/virtuoso.c b/sound/pci/oxygen/virtuoso.c
index 98ab16329..de7cc17d6 100644
--- a/sound/pci/oxygen/virtuoso.c
+++ b/sound/pci/oxygen/virtuoso.c
@@ -70,7 +70,7 @@ static int xonar_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		++dev;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	err = oxygen_pci_probe(pci, index[dev], id[dev], THIS_MODULE,
 			       xonar_ids, get_xonar_model);
diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index c2e4831c3..329cba72a 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1489,7 +1489,7 @@ static int pcxhr_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (! enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* enable PCI device */
diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 2258bd698..45c990601 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -376,7 +376,7 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 			dev_err(&mgr->pci->dev,
 				"pcxhr: can't load firmware %s\n",
 				   path);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		/* fake hwdep dsp record */
 		err = pcxhr_dsp_load(mgr, i, fw_entry);
diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index b4f300281..4c0c77532 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2051,7 +2051,7 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/rme32.c b/sound/pci/rme32.c
index 869af8a32..9943c61b6 100644
--- a/sound/pci/rme32.c
+++ b/sound/pci/rme32.c
@@ -1888,7 +1888,7 @@ snd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 	}
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 84eef6a37..cdb98e578 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2449,7 +2449,7 @@ snd_rme96_probe(struct pci_dev *pci,
 	}
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
 			   sizeof(struct rme96), &card);
diff --git a/sound/pci/rme9652/hdsp.c b/sound/pci/rme9652/hdsp.c
index 227aece17..953f57dde 100644
--- a/sound/pci/rme9652/hdsp.c
+++ b/sound/pci/rme9652/hdsp.c
@@ -5115,7 +5115,7 @@ static int hdsp_request_fw_loader(struct hdsp *hdsp)
 	if (request_firmware(&fw, fwfile, &hdsp->pci->dev)) {
 		dev_err(hdsp->card->dev,
 			"cannot load firmware %s\n", fwfile);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	if (fw->size < HDSP_FIRMWARE_SIZE) {
 		dev_err(hdsp->card->dev,
@@ -5346,7 +5346,7 @@ static int snd_hdsp_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f7cda9062..fe7d112e2 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6919,7 +6919,7 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev],
diff --git a/sound/pci/rme9652/rme9652.c b/sound/pci/rme9652/rme9652.c
index 7ab10028d..6e3133fec 100644
--- a/sound/pci/rme9652/rme9652.c
+++ b/sound/pci/rme9652/rme9652.c
@@ -2586,7 +2586,7 @@ static int snd_rme9652_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index ecdd54d7a..f07f7a0a2 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1427,7 +1427,7 @@ static int snd_sonic_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
  
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/trident/trident.c b/sound/pci/trident/trident.c
index 5bc79da6e..41dee0591 100644
--- a/sound/pci/trident/trident.c
+++ b/sound/pci/trident/trident.c
@@ -71,7 +71,7 @@ static int snd_trident_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/vx222/vx222.c b/sound/pci/vx222/vx222.c
index f7800ed1b..e221f39ba 100644
--- a/sound/pci/vx222/vx222.c
+++ b/sound/pci/vx222/vx222.c
@@ -188,7 +188,7 @@ static int snd_vx222_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/pci/ymfpci/ymfpci.c b/sound/pci/ymfpci/ymfpci.c
index 9b0d18a7b..49adfc88b 100644
--- a/sound/pci/ymfpci/ymfpci.c
+++ b/sound/pci/ymfpci/ymfpci.c
@@ -173,7 +173,7 @@ static int snd_card_ymfpci_probe(struct pci_dev *pci,
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/sh/aica.c b/sound/sh/aica.c
index 8fa68432d..326232993 100644
--- a/sound/sh/aica.c
+++ b/sound/sh/aica.c
@@ -329,7 +329,7 @@ static int snd_aicapcm_pcm_open(struct snd_pcm_substream
 	struct aica_channel *channel;
 	struct snd_card_aica *dreamcastcard;
 	if (!enable)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	dreamcastcard = substream->pcm->private_data;
 	channel = kmalloc(sizeof(struct aica_channel), GFP_KERNEL);
 	if (!channel)
diff --git a/sound/soc/codecs/tas5086.c b/sound/soc/codecs/tas5086.c
index 0250b94c8..584630a12 100644
--- a/sound/soc/codecs/tas5086.c
+++ b/sound/soc/codecs/tas5086.c
@@ -345,7 +345,7 @@ static int index_in_array(const int *array, int len, int needle)
 		if (array[i] == needle)
 			return i;
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int tas5086_hw_params(struct snd_pcm_substream *substream,
diff --git a/sound/soc/intel/boards/ehl_rt5660.c b/sound/soc/intel/boards/ehl_rt5660.c
index 78160e3b1..ec1ea5eab 100644
--- a/sound/soc/intel/boards/ehl_rt5660.c
+++ b/sound/soc/intel/boards/ehl_rt5660.c
@@ -96,7 +96,7 @@ static int card_late_probe(struct snd_soc_card *card)
 	struct sof_hdmi_pcm *pcm;
 
 	if (list_empty(&ctx->hdmi_pcm_list))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!ctx->idisp_codec)
 		return 0;
diff --git a/sound/soc/samsung/s3c-i2s-v2.c b/sound/soc/samsung/s3c-i2s-v2.c
index 5e95c30fb..8bfc6bfc5 100644
--- a/sound/soc/samsung/s3c-i2s-v2.c
+++ b/sound/soc/samsung/s3c-i2s-v2.c
@@ -630,7 +630,7 @@ int s3c_i2sv2_probe(struct snd_soc_dai *dai,
 	i2s->iis_pclk = clk_get(dev, "iis");
 	if (IS_ERR(i2s->iis_pclk)) {
 		dev_err(dev, "failed to get iis_clock\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	clk_prepare_enable(i2s->iis_pclk);
diff --git a/sound/soc/samsung/smdk_spdif.c b/sound/soc/samsung/smdk_spdif.c
index 776a27026..ce5d67fcd 100644
--- a/sound/soc/samsung/smdk_spdif.c
+++ b/sound/soc/samsung/smdk_spdif.c
@@ -79,7 +79,7 @@ static int set_audio_clock_rate(unsigned long epll_rate,
 	fout_epll = clk_get(NULL, "fout_epll");
 	if (IS_ERR(fout_epll)) {
 		printk(KERN_ERR "%s: failed to get fout_epll\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	clk_set_rate(fout_epll, epll_rate);
@@ -88,7 +88,7 @@ static int set_audio_clock_rate(unsigned long epll_rate,
 	sclk_spdif = clk_get(NULL, "sclk_spdif");
 	if (IS_ERR(sclk_spdif)) {
 		printk(KERN_ERR "%s: failed to get sclk_spdif\n", __func__);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	clk_set_rate(sclk_spdif, audio_rate);
diff --git a/sound/soc/sof/debug.c b/sound/soc/sof/debug.c
index 8e15f105d..afb292c0f 100644
--- a/sound/soc/sof/debug.c
+++ b/sound/soc/sof/debug.c
@@ -106,7 +106,7 @@ static ssize_t probe_points_read(struct file *file,
 
 	if (sdev->extractor_stream_tag == SOF_PROBE_INVALID_NODE_ID) {
 		dev_warn(sdev->dev, "no extractor stream running\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
@@ -146,7 +146,7 @@ static ssize_t probe_points_write(struct file *file,
 
 	if (sdev->extractor_stream_tag == SOF_PROBE_INVALID_NODE_ID) {
 		dev_warn(sdev->dev, "no extractor stream running\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = tokenize_input(from, count, ppos, &tkns, &num_tkns);
@@ -186,7 +186,7 @@ static ssize_t probe_points_remove_write(struct file *file,
 
 	if (sdev->extractor_stream_tag == SOF_PROBE_INVALID_NODE_ID) {
 		dev_warn(sdev->dev, "no extractor stream running\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = tokenize_input(from, count, ppos, &tkns, &num_tkns);
diff --git a/sound/soc/sof/intel/hda-codec.c b/sound/soc/sof/intel/hda-codec.c
index 2c5c451fa..a21621550 100644
--- a/sound/soc/sof/intel/hda-codec.c
+++ b/sound/soc/sof/intel/hda-codec.c
@@ -151,7 +151,7 @@ static int hda_codec_probe(struct snd_sof_dev *sdev, int address,
 		if (!hdev->bus->audio_component) {
 			dev_dbg(sdev->dev,
 				"iDisp hw present but no driver\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		hda_priv->need_display_power = true;
 	}
diff --git a/sound/soc/ti/omap-mcbsp-st.c b/sound/soc/ti/omap-mcbsp-st.c
index 5a32b54bb..1440ea091 100644
--- a/sound/soc/ti/omap-mcbsp-st.c
+++ b/sound/soc/ti/omap-mcbsp-st.c
@@ -158,7 +158,7 @@ static int omap_mcbsp_st_set_chgain(struct omap_mcbsp *mcbsp, int channel,
 	int ret = 0;
 
 	if (!st_data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock_irq(&mcbsp->lock);
 	if (channel == 0)
@@ -182,7 +182,7 @@ static int omap_mcbsp_st_get_chgain(struct omap_mcbsp *mcbsp, int channel,
 	int ret = 0;
 
 	if (!st_data)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	spin_lock_irq(&mcbsp->lock);
 	if (channel == 0)
diff --git a/sound/sound_core.c b/sound/sound_core.c
index 90d118cd9..d4f1b25c3 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -178,7 +178,7 @@ static int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list,
 		}
 
 		if(n>=top)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 	} else {
 		n = low+(index*16);
 		while (*list) {
diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 9d0da5fa1..d148c5d75 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1000,7 +1000,7 @@ static int amd7930_sbus_probe(struct platform_device *op)
 		return -ENODEV;
 	if (!enable[dev_num]) {
 		dev_num++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&op->dev, index[dev_num], id[dev_num],
diff --git a/sound/sparc/cs4231.c b/sound/sparc/cs4231.c
index 0eed5f79a..324056a7e 100644
--- a/sound/sparc/cs4231.c
+++ b/sound/sparc/cs4231.c
@@ -1553,7 +1553,7 @@ static int cs4231_attach_begin(struct platform_device *op,
 
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&op->dev, index[dev], id[dev], THIS_MODULE,
diff --git a/sound/sparc/dbri.c b/sound/sparc/dbri.c
index cf7049999..f6f6ad9a9 100644
--- a/sound/sparc/dbri.c
+++ b/sound/sparc/dbri.c
@@ -2599,7 +2599,7 @@ static int dbri_probe(struct platform_device *op)
 		return -ENODEV;
 	if (!enable[dev]) {
 		dev++;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	irq = op->archdata.irqs[0];
diff --git a/sound/usb/bcd2000/bcd2000.c b/sound/usb/bcd2000/bcd2000.c
index 010976d9c..b6d6b2e9e 100644
--- a/sound/usb/bcd2000/bcd2000.c
+++ b/sound/usb/bcd2000/bcd2000.c
@@ -376,7 +376,7 @@ static int bcd2000_probe(struct usb_interface *interface,
 
 	if (card_index >= SNDRV_CARDS) {
 		mutex_unlock(&devices_mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = snd_card_new(&interface->dev, index[card_index], id[card_index],
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 354f57692..d3c22a0db 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2030,7 +2030,7 @@ static int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi,
 
 	intf = umidi->iface;
 	if (!intf || intf->num_altsetting < 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	hostif = intf->cur_altsetting;
 	intfd = get_iface_desc(hostif);
 
@@ -2088,11 +2088,11 @@ static int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi,
 
 	intf = umidi->iface;
 	if (!intf)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	hostif = intf->altsetting;
 	intfd = get_iface_desc(hostif);
 	if (intfd->bNumEndpoints < 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	/*
 	 * For each port there is one MIDI_IN/OUT_JACK descriptor, not
@@ -2111,7 +2111,7 @@ static int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi,
 		}
 	}
 	if (!endpoint->in_cables && !endpoint->out_cables)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return snd_usbmidi_detect_endpoints(umidi, endpoint, 1);
 }
@@ -2128,7 +2128,7 @@ static int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,
 
 	intf = umidi->iface;
 	if (!intf)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	hostif = intf->altsetting;
 	/*
 	 * Some devices have a descriptor <06 24 F1 02 <inputs> <outputs>>,
@@ -2169,7 +2169,7 @@ static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,
 
 	intf = umidi->iface;
 	if (!intf)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	hostif = intf->altsetting;
 	intfd = get_iface_desc(hostif);
 	/*
@@ -2184,7 +2184,7 @@ static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,
 	 */
 	if (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {
 		dev_dbg(&umidi->dev->dev, "not enough endpoints\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	epd = get_endpoint(hostif, 0);
diff --git a/sound/usb/misc/ua101.c b/sound/usb/misc/ua101.c
index 884e740a7..c68a4e72e 100644
--- a/sound/usb/misc/ua101.c
+++ b/sound/usb/misc/ua101.c
@@ -1200,7 +1200,7 @@ static int ua101_probe(struct usb_interface *interface,
 			break;
 	if (card_index >= SNDRV_CARDS) {
 		mutex_unlock(&devices_mutex);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	err = snd_card_new(&interface->dev,
 			   index[card_index], id[card_index], THIS_MODULE,
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index 40b7cd13f..d7bef19bf 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -298,7 +298,7 @@ static int search_roland_implicit_fb(struct usb_device *dev, int ifnum,
 
 	iface = usb_ifnum_to_if(dev, ifnum);
 	if (!iface || iface->num_altsetting < altsetting + 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*alts = &iface->altsetting[altsetting];
 	altsd = get_iface_desc(*alts);
 	if (altsd->bAlternateSetting != altsetting ||
@@ -306,12 +306,12 @@ static int search_roland_implicit_fb(struct usb_device *dev, int ifnum,
 	    (altsd->bInterfaceSubClass != 2 &&
 	     altsd->bInterfaceProtocol != 2   ) ||
 	    altsd->bNumEndpoints < 1)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	epd = get_endpoint(*alts, 0);
 	if (!usb_endpoint_is_isoc_in(epd) ||
 	    (epd->bmAttributes & USB_ENDPOINT_USAGE_MASK) !=
 					USB_ENDPOINT_USAGE_IMPLICIT_FB)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	*ep = epd->bEndpointAddress;
 	return 0;
 }
diff --git a/tools/bpf/bpftool/tracelog.c b/tools/bpf/bpftool/tracelog.c
index e80a5c79b..8c2e8fcdc 100644
--- a/tools/bpf/bpftool/tracelog.c
+++ b/tools/bpf/bpftool/tracelog.c
@@ -29,9 +29,9 @@ static int validate_tracefs_mnt(const char *mnt, unsigned long magic)
 	struct statfs st_fs;
 
 	if (statfs(mnt, &st_fs) < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	if ((unsigned long)st_fs.f_type != magic)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/tools/lib/api/fs/fs.c b/tools/lib/api/fs/fs.c
index 82f53d81a..adad9c078 100644
--- a/tools/lib/api/fs/fs.c
+++ b/tools/lib/api/fs/fs.c
@@ -174,9 +174,9 @@ static int fs__valid_mount(const char *fs, long magic)
 	struct statfs st_fs;
 
 	if (statfs(fs, &st_fs) < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	else if ((long)st_fs.f_type != magic)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
diff --git a/tools/lib/bpf/btf.c b/tools/lib/bpf/btf.c
index bfef3d606..8b3bef70c 100644
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@ -359,7 +359,7 @@ __s32 btf__find_by_name(const struct btf *btf, const char *type_name)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 __s32 btf__find_by_name_kind(const struct btf *btf, const char *type_name,
@@ -381,7 +381,7 @@ __s32 btf__find_by_name_kind(const struct btf *btf, const char *type_name,
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 void btf__free(struct btf *btf)
@@ -582,7 +582,7 @@ static int btf_fixup_datasec(struct bpf_object *obj, struct btf *btf,
 
 	if (!name) {
 		pr_debug("No name found in string section for DATASEC kind.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/* .extern datasec size and var offsets were set correctly during
@@ -594,7 +594,7 @@ static int btf_fixup_datasec(struct bpf_object *obj, struct btf *btf,
 	ret = bpf_object__section_size(obj, name, &size);
 	if (ret || !size || (t->size && t->size != size)) {
 		pr_debug("Invalid size for section %s: %u bytes\n", name, size);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	t->size = size;
@@ -614,14 +614,14 @@ static int btf_fixup_datasec(struct bpf_object *obj, struct btf *btf,
 		name = btf__name_by_offset(btf, t_var->name_off);
 		if (!name) {
 			pr_debug("No name found in string section for VAR kind\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		ret = bpf_object__variable_offset(obj, name, &off);
 		if (ret) {
 			pr_debug("No offset found in symbol table for VAR %s\n",
 				 name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		vsi->offset = off;
@@ -1125,7 +1125,7 @@ static int btf_ext_reloc_info(const struct btf *btf,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int btf_ext__reloc_func_info(const struct btf *btf,
diff --git a/tools/lib/bpf/hashmap.c b/tools/lib/bpf/hashmap.c
index a405dad06..54b6dd3db 100644
--- a/tools/lib/bpf/hashmap.c
+++ b/tools/lib/bpf/hashmap.c
@@ -179,7 +179,7 @@ int hashmap__insert(struct hashmap *map, const void *key, void *value,
 	}
 
 	if (strategy == HASHMAP_UPDATE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (hashmap_needs_to_grow(map)) {
 		err = hashmap_grow(map);
diff --git a/tools/lib/bpf/hashmap.h b/tools/lib/bpf/hashmap.h
index e0af36b0e..53096d70f 100644
--- a/tools/lib/bpf/hashmap.h
+++ b/tools/lib/bpf/hashmap.h
@@ -72,7 +72,7 @@ size_t hashmap__capacity(const struct hashmap *map);
  * - HASHMAP_SET - add key/value pair if key doesn't exist yet; otherwise,
  *   update value;
  * - HASHMAP_UPDATE - update value, if key already exists; otherwise, do
- *   nothing and return -ENOENT;
+ *   nothing and ENOENT_DUMPER(stackdump_tuneable);
  * - HASHMAP_APPEND - always add key/value pair, even if key already exists.
  *   This turns hashmap into a multimap by allowing multiple values to be
  *   associated with the same key. Most useful read API for such hashmap is
diff --git a/tools/lib/bpf/libbpf.c b/tools/lib/bpf/libbpf.c
index 11e4725b8..11dd83ba7 100644
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@ -1193,7 +1193,7 @@ static int bpf_object_search_section_size(const struct bpf_object *obj,
 		return 0;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 int bpf_object__section_size(const struct bpf_object *obj, const char *name,
@@ -1258,7 +1258,7 @@ int bpf_object__variable_offset(const struct bpf_object *obj, const char *name,
 		}
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct bpf_map *bpf_object__add_map(struct bpf_object *obj)
@@ -1639,7 +1639,7 @@ static int bpf_object__read_kconfig_file(struct bpf_object *obj, void *data)
 
 	if (!file) {
 		pr_warn("failed to open system Kconfig\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	while (gzgets(file, buf, sizeof(buf))) {
@@ -2256,7 +2256,7 @@ static int bpf_object__init_user_btf_maps(struct bpf_object *obj, bool strict,
 
 	if (!sec) {
 		pr_warn("DATASEC '%s' not found.\n", MAPS_ELF_SEC);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	vlen = btf_vlen(sec);
@@ -2457,7 +2457,7 @@ static int bpf_object__finalize_btf(struct bpf_object *obj)
 
 	if (libbpf_needs_btf(obj)) {
 		pr_warn("BTF is required, but is missing or corrupted.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	return 0;
 }
@@ -2706,7 +2706,7 @@ static int find_extern_btf_id(const struct btf *btf, const char *ext_name)
 		return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static enum extern_type find_extern_type(const struct btf *btf, int id,
@@ -6053,11 +6053,11 @@ int bpf_object__pin_maps(struct bpf_object *obj, const char *path)
 	int err;
 
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!obj->loaded) {
 		pr_warn("object not yet loaded; load it first\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bpf_object__for_each_map(map, obj) {
@@ -6105,7 +6105,7 @@ int bpf_object__unpin_maps(struct bpf_object *obj, const char *path)
 	int err;
 
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bpf_object__for_each_map(map, obj) {
 		char *pin_path = NULL;
@@ -6139,11 +6139,11 @@ int bpf_object__pin_programs(struct bpf_object *obj, const char *path)
 	int err;
 
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!obj->loaded) {
 		pr_warn("object not yet loaded; load it first\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	bpf_object__for_each_program(prog, obj) {
@@ -6191,7 +6191,7 @@ int bpf_object__unpin_programs(struct bpf_object *obj, const char *path)
 	int err;
 
 	if (!obj)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bpf_object__for_each_program(prog, obj) {
 		char buf[PATH_MAX];
@@ -6500,7 +6500,7 @@ int bpf_program__nth_fd(const struct bpf_program *prog, int n)
 	if (fd < 0) {
 		pr_warn("%dth instance of program '%s' is invalid\n",
 			n, prog->section_name);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return fd;
@@ -7271,7 +7271,7 @@ int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,
 
 	obj = bpf_object__open_xattr(&open_attr);
 	if (IS_ERR_OR_NULL(obj))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	bpf_object__for_each_program(prog, obj) {
 		enum bpf_attach_type attach_type = attr->expected_attach_type;
@@ -7309,7 +7309,7 @@ int bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,
 	if (!first_prog) {
 		pr_warn("object file doesn't contain bpf program\n");
 		bpf_object__close(obj);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	err = bpf_object__load(obj);
diff --git a/tools/lib/perf/mmap.c b/tools/lib/perf/mmap.c
index 79d5ed6c3..e391c5346 100644
--- a/tools/lib/perf/mmap.c
+++ b/tools/lib/perf/mmap.c
@@ -175,7 +175,7 @@ int perf_mmap__read_init(struct perf_mmap *map)
 	 * Check if event was unmapped due to a POLLHUP/POLLERR.
 	 */
 	if (!refcount_read(&map->refcnt))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return __perf_mmap__read_init(map);
 }
diff --git a/tools/perf/builtin-kmem.c b/tools/perf/builtin-kmem.c
index 38a5ab683..1cc6be842 100644
--- a/tools/perf/builtin-kmem.c
+++ b/tools/perf/builtin-kmem.c
@@ -350,7 +350,7 @@ static int build_alloc_func_list(void)
 	kernel_map = machine__kernel_map(machine);
 	if (map__load(kernel_map) < 0) {
 		pr_err("cannot load kernel map\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	map__for_each_symbol(kernel_map, sym, node) {
@@ -903,7 +903,7 @@ static int evsel__process_page_free_event(struct evsel *evsel, struct perf_sampl
 
 	pstat = page_stat__find_caller(&this);
 	if (pstat == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pstat->nr_free++;
 	pstat->free_bytes += bytes;
diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c
index 9be020e00..518698d80 100644
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@ -325,7 +325,7 @@ static int read_counter_cpu(struct evsel *counter, struct timespec *rs, int cpu)
 	int thread;
 
 	if (!counter->supported)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (counter->core.system_wide)
 		nthreads = 1;
diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c
index 4cbb64edc..0222b8495 100644
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@ -407,7 +407,7 @@ static int evsel__init_syscall_tp(struct evsel *evsel)
 	if (sc != NULL) {
 		if (evsel__init_tp_uint_field(evsel, &sc->id, "__syscall_nr") &&
 		    evsel__init_tp_uint_field(evsel, &sc->id, "nr"))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		return 0;
 	}
 
@@ -450,7 +450,7 @@ static int evsel__init_raw_syscall_tp(struct evsel *evsel, void *handler)
 {
 	if (evsel__syscall_tp(evsel) != NULL) {
 		if (perf_evsel__init_sc_tp_uint_field(evsel, id))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		evsel->handler = handler;
 		return 0;
diff --git a/tools/perf/pmu-events/jevents.c b/tools/perf/pmu-events/jevents.c
index fa86c5f99..55141433f 100644
--- a/tools/perf/pmu-events/jevents.c
+++ b/tools/perf/pmu-events/jevents.c
@@ -529,7 +529,7 @@ int json_events(const char *fn,
 	char buf[128];
 
 	if (!fn)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tokens = parse_json(fn, &map, &size, &len);
 	if (!tokens)
diff --git a/tools/perf/util/auxtrace.c b/tools/perf/util/auxtrace.c
index 25c639ac4..c9fd19d6f 100644
--- a/tools/perf/util/auxtrace.c
+++ b/tools/perf/util/auxtrace.c
@@ -1049,7 +1049,7 @@ int auxtrace_queues__add_sample(struct auxtrace_queues *queues,
 
 	sid = perf_evlist__id2sid(session->evlist, id);
 	if (!sid)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	idx = sid->idx;
 	buffer.tid = sid->tid;
diff --git a/tools/perf/util/dwarf-aux.c b/tools/perf/util/dwarf-aux.c
index aa898014a..31cb29b20 100644
--- a/tools/perf/util/dwarf-aux.c
+++ b/tools/perf/util/dwarf-aux.c
@@ -240,7 +240,7 @@ int die_get_call_lineno(Dwarf_Die *in_die)
 	Dwarf_Word ret;
 
 	if (!dwarf_attr(in_die, DW_AT_call_line, &attr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dwarf_formudata(&attr, &ret);
 	return (int)ret;
@@ -310,7 +310,7 @@ static int die_get_attr_udata(Dwarf_Die *tp_die, unsigned int attr_name,
 
 	if (dwarf_attr(tp_die, attr_name, &attr) == NULL ||
 	    dwarf_formudata(&attr, result) != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -323,7 +323,7 @@ static int die_get_attr_sdata(Dwarf_Die *tp_die, unsigned int attr_name,
 
 	if (dwarf_attr(tp_die, attr_name, &attr) == NULL ||
 	    dwarf_formsdata(&attr, result) != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	return 0;
 }
@@ -422,13 +422,13 @@ int die_get_data_member_location(Dwarf_Die *mb_die, Dwarf_Word *offs)
 	int ret;
 
 	if (dwarf_attr(mb_die, DW_AT_data_member_location, &attr) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (dwarf_formudata(&attr, offs) != 0) {
 		/* DW_AT_data_member_location should be DW_OP_plus_uconst */
 		ret = dwarf_getlocation(&attr, &expr, &nexpr);
 		if (ret < 0 || nexpr == 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (expr[0].atom != DW_OP_plus_uconst || nexpr != 1) {
 			pr_debug("Unable to get offset:Unexpected OP %x (%zd)\n",
@@ -448,7 +448,7 @@ static int die_get_call_fileno(Dwarf_Die *in_die)
 	if (die_get_attr_sdata(in_die, DW_AT_call_file, &idx) == 0)
 		return (int)idx;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* Get the declared file index number in CU DIE */
@@ -459,7 +459,7 @@ static int die_get_decl_fileno(Dwarf_Die *pdie)
 	if (die_get_attr_sdata(pdie, DW_AT_decl_file, &idx) == 0)
 		return (int)idx;
 	else
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /**
@@ -731,7 +731,7 @@ int die_walk_instances(Dwarf_Die *or_die, int (*callback)(Dwarf_Die *, void *),
 	};
 
 	if (dwarf_diecu(or_die, &cu_die, NULL, NULL) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	die_find_child(&cu_die, __die_walk_instances_cb, &iwp, &die_mem);
 
@@ -860,7 +860,7 @@ int die_walk_lines(Dwarf_Die *rt_die, line_walk_callback_t callback, void *data)
 	/* Get lines list in the CU */
 	if (dwarf_getsrclines(cu_die, &lines, &nlines) != 0) {
 		pr_debug2("Failed to get source lines on this CU.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	pr_debug2("Get %zd lines from this CU\n", nlines);
 
@@ -1028,7 +1028,7 @@ int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf)
 	const char *tmp = "";
 
 	if (__die_get_real_type(vr_die, &type) == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	tag = dwarf_tag(&type);
 	if (tag == DW_TAG_array_type || tag == DW_TAG_pointer_type)
@@ -1038,7 +1038,7 @@ int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf)
 		return strbuf_add(buf, "(function_type)", 15);
 	} else {
 		if (!dwarf_diename(&type))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (tag == DW_TAG_union_type)
 			tmp = "union ";
 		else if (tag == DW_TAG_structure_type)
@@ -1101,7 +1101,7 @@ static int die_get_var_innermost_scope(Dwarf_Die *sp_die, Dwarf_Die *vr_die,
 
 	name = dwarf_diename(sp_die);
 	if (!name)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	count = dwarf_getscopes_die(vr_die, &scopes);
 
@@ -1164,7 +1164,7 @@ int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die, struct strbuf *buf)
 
 	name = dwarf_diename(sp_die);
 	if (!name)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (dwarf_attr(vr_die, DW_AT_location, &attr) == NULL)
 		return -EINVAL;
diff --git a/tools/perf/util/evswitch.c b/tools/perf/util/evswitch.c
index 3ba72f743..adbcb4e9e 100644
--- a/tools/perf/util/evswitch.c
+++ b/tools/perf/util/evswitch.c
@@ -44,7 +44,7 @@ int evswitch__init(struct evswitch *evswitch, struct evlist *evlist, FILE *fp)
 		evswitch->on = perf_evlist__find_evsel_by_str(evlist, evswitch->on_name);
 		if (evswitch->on == NULL) {
 			evswitch__fprintf_enoent(fp, "on", evswitch->on_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		evswitch->discarding = true;
 	}
@@ -53,7 +53,7 @@ int evswitch__init(struct evswitch *evswitch, struct evlist *evlist, FILE *fp)
 		evswitch->off = perf_evlist__find_evsel_by_str(evlist, evswitch->off_name);
 		if (evswitch->off == NULL) {
 			evswitch__fprintf_enoent(fp, "off", evswitch->off_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 	}
 
diff --git a/tools/perf/util/hashmap.c b/tools/perf/util/hashmap.c
index a405dad06..54b6dd3db 100644
--- a/tools/perf/util/hashmap.c
+++ b/tools/perf/util/hashmap.c
@@ -179,7 +179,7 @@ int hashmap__insert(struct hashmap *map, const void *key, void *value,
 	}
 
 	if (strategy == HASHMAP_UPDATE)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (hashmap_needs_to_grow(map)) {
 		err = hashmap_grow(map);
diff --git a/tools/perf/util/hashmap.h b/tools/perf/util/hashmap.h
index e0af36b0e..53096d70f 100644
--- a/tools/perf/util/hashmap.h
+++ b/tools/perf/util/hashmap.h
@@ -72,7 +72,7 @@ size_t hashmap__capacity(const struct hashmap *map);
  * - HASHMAP_SET - add key/value pair if key doesn't exist yet; otherwise,
  *   update value;
  * - HASHMAP_UPDATE - update value, if key already exists; otherwise, do
- *   nothing and return -ENOENT;
+ *   nothing and ENOENT_DUMPER(stackdump_tuneable);
  * - HASHMAP_APPEND - always add key/value pair, even if key already exists.
  *   This turns hashmap into a multimap by allowing multiple values to be
  *   associated with the same key. Most useful read API for such hashmap is
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index 7a67d017d..ebd161a1c 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -1403,7 +1403,7 @@ static int write_cpu_pmu_caps(struct feat_fd *ff,
 	int ret;
 
 	if (!cpu_pmu)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	nr_caps = perf_pmu__caps_parse(cpu_pmu);
 	if (nr_caps < 0)
diff --git a/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c b/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c
index f8ccfd6be..464e945a5 100644
--- a/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c
+++ b/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c
@@ -1176,14 +1176,14 @@ static int intel_pt_walk_fup(struct intel_pt_decoder *decoder)
 			intel_pt_log_at("ERROR: Unexpected indirect branch",
 					decoder->ip);
 			decoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		if (intel_pt_insn.branch == INTEL_PT_BR_CONDITIONAL) {
 			intel_pt_log_at("ERROR: Unexpected conditional branch",
 					decoder->ip);
 			decoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		intel_pt_bug(decoder);
@@ -1260,7 +1260,7 @@ static int intel_pt_walk_tip(struct intel_pt_decoder *decoder)
 		intel_pt_log_at("ERROR: Conditional branch when expecting indirect branch",
 				decoder->ip);
 		decoder->pkt_state = INTEL_PT_STATE_ERR_RESYNC;
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return intel_pt_bug(decoder);
@@ -1283,19 +1283,19 @@ static int intel_pt_walk_tnt(struct intel_pt_decoder *decoder)
 				intel_pt_log_at("ERROR: RET when expecting conditional branch",
 						decoder->ip);
 				decoder->pkt_state = INTEL_PT_STATE_ERR3;
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			if (!decoder->ret_addr) {
 				intel_pt_log_at("ERROR: Bad RET compression (stack empty)",
 						decoder->ip);
 				decoder->pkt_state = INTEL_PT_STATE_ERR3;
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			if (!(decoder->tnt.payload & BIT63)) {
 				intel_pt_log_at("ERROR: Bad RET compression (TNT=N)",
 						decoder->ip);
 				decoder->pkt_state = INTEL_PT_STATE_ERR3;
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			decoder->tnt.count -= 1;
 			if (decoder->tnt.count)
@@ -1320,7 +1320,7 @@ static int intel_pt_walk_tnt(struct intel_pt_decoder *decoder)
 						decoder->ip);
 				decoder->pkt_state = INTEL_PT_STATE_ERR3;
 				decoder->pkt_step = 0;
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			intel_pt_set_last_ip(decoder);
 			decoder->state.from_ip = decoder->ip;
@@ -1798,7 +1798,7 @@ static int intel_pt_walk_fup_tip(struct intel_pt_decoder *decoder)
 			intel_pt_log("ERROR: Missing TIP after FUP\n");
 			decoder->pkt_state = INTEL_PT_STATE_ERR3;
 			decoder->pkt_step = 0;
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		case INTEL_PT_CBR:
 			intel_pt_calc_cbr(decoder);
diff --git a/tools/perf/util/intel-pt.c b/tools/perf/util/intel-pt.c
index cb3c1e569..6a7b666d4 100644
--- a/tools/perf/util/intel-pt.c
+++ b/tools/perf/util/intel-pt.c
@@ -565,7 +565,7 @@ static int intel_pt_walk_next_insn(struct intel_pt_insn *intel_pt_insn,
 		if (al.map->dso->data.status == DSO_DATA_STATUS_ERROR &&
 		    dso__data_status_seen(al.map->dso,
 					  DSO_DATA_STATUS_SEEN_ITRACE))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		offset = al.map->map_ip(al.map, *ip);
 
diff --git a/tools/perf/util/llvm-utils.c b/tools/perf/util/llvm-utils.c
index dbdffb667..499e8f0e2 100644
--- a/tools/perf/util/llvm-utils.c
+++ b/tools/perf/util/llvm-utils.c
@@ -268,7 +268,7 @@ static int detect_kbuild_dir(char **kbuild_dir)
 	pr_debug("%s: Couldn't find \"%s\", missing kernel-devel package?.\n",
 		 __func__, autoconf_path);
 	free(autoconf_path);
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static const char *kinc_fetch_script =
@@ -466,7 +466,7 @@ int llvm__compile_bpf(const char *path, void **p_obj_buf,
 "Hint:\tTry to install latest clang/llvm to support BPF. Check your $PATH\n"
 "     \tand 'clang-path' option in [llvm] section of ~/.perfconfig.\n");
 		version_notice();
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	/*
diff --git a/tools/perf/util/machine.c b/tools/perf/util/machine.c
index d53848073..e713b986f 100644
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@ -1167,7 +1167,7 @@ int machines__create_guest_kernel_maps(struct machines *machines)
 	if (symbol_conf.guestmount) {
 		items = scandir(symbol_conf.guestmount, &namelist, NULL, NULL);
 		if (items <= 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		for (i = 0; i < items; i++) {
 			if (!isdigit(namelist[i]->d_name[0])) {
 				/* Filter out . and .. */
diff --git a/tools/perf/util/mem-events.c b/tools/perf/util/mem-events.c
index ea0af0bc4..6df24d15c 100644
--- a/tools/perf/util/mem-events.c
+++ b/tools/perf/util/mem-events.c
@@ -86,7 +86,7 @@ int perf_mem_events__init(void)
 	int j;
 
 	if (!mnt)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	for (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {
 		char path[PATH_MAX];
diff --git a/tools/perf/util/perf-hooks.c b/tools/perf/util/perf-hooks.c
index 7a0ab3507..4baafceea 100644
--- a/tools/perf/util/perf-hooks.c
+++ b/tools/perf/util/perf-hooks.c
@@ -73,7 +73,7 @@ int perf_hooks__set_hook(const char *hook_name,
 		perf_hooks[i]->hook_ctx = hook_ctx;
 		return 0;
 	}
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 perf_hook_func_t perf_hooks__get_hook(const char *hook_name)
diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c
index df713a5d1..1027142d1 100644
--- a/tools/perf/util/probe-event.c
+++ b/tools/perf/util/probe-event.c
@@ -135,7 +135,7 @@ static int kernel_get_symbol_address_by_name(const char *name, u64 *addr,
 	else {
 		sym = machine__find_kernel_symbol_by_name(host_machine, name, &map);
 		if (!sym)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		*addr = map->unmap_ip(map, sym->start) -
 			((reloc) ? 0 : map->reloc) -
 			((reladdr) ? map->start : 0);
@@ -332,7 +332,7 @@ static int kernel_get_module_dso(const char *module, struct dso **pdso)
 			goto found;
 		}
 		pr_debug("Failed to find module %s.\n", module);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	map = machine__kernel_map(host_machine);
@@ -626,7 +626,7 @@ static int post_process_probe_trace_point(struct probe_trace_point *tp,
 
 	sym = map__find_symbol(map, addr);
 	if (!sym)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (strcmp(sym->name, tp->symbol)) {
 		/* If we have no realname, use symbol for it */
@@ -838,7 +838,7 @@ static int try_to_find_probe_trace_events(struct perf_probe_event *pev,
 	dinfo = open_debuginfo(pev->target, pev->nsi, !need_dwarf);
 	if (!dinfo) {
 		if (need_dwarf)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		pr_debug("Could not open debuginfo. Try to use symbols.\n");
 		return 0;
 	}
@@ -877,7 +877,7 @@ static int try_to_find_probe_trace_events(struct perf_probe_event *pev,
 	if (ntevs == 0)	{	/* No error but failed to find probe point. */
 		pr_warning("Probe point '%s' not found.\n",
 			   synthesize_perf_probe_point(&pev->point));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (ntevs < 0) {
 		/* Error path : ntevs < 0 */
 		pr_debug("An error occurred in debuginfo analysis (%d).\n", ntevs);
@@ -957,7 +957,7 @@ static int __show_line_range(struct line_range *lr, const char *module,
 	/* Search a line range */
 	dinfo = open_debuginfo(module, NULL, false);
 	if (!dinfo)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	ret = debuginfo__find_line_range(dinfo, lr);
 	if (!ret) {	/* Not found, retry with an alternative */
@@ -968,7 +968,7 @@ static int __show_line_range(struct line_range *lr, const char *module,
 	debuginfo__delete(dinfo);
 	if (ret == 0 || ret == -ENOENT) {
 		pr_warning("Specified source line is not found.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	} else if (ret < 0) {
 		pr_warning("Debuginfo analysis failed.\n");
 		return ret;
diff --git a/tools/perf/util/probe-file.c b/tools/perf/util/probe-file.c
index 064b63a6a..a640e06ba 100644
--- a/tools/perf/util/probe-file.c
+++ b/tools/perf/util/probe-file.c
@@ -298,7 +298,7 @@ int probe_file__get_events(int fd, struct strfilter *filter,
 
 	namelist = __probe_file__get_namelist(fd, true);
 	if (!namelist)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	strlist__for_each_entry(ent, namelist) {
 		p = strchr(ent->s, ':');
diff --git a/tools/perf/util/probe-finder.c b/tools/perf/util/probe-finder.c
index 55924255c..cd965528f 100644
--- a/tools/perf/util/probe-finder.c
+++ b/tools/perf/util/probe-finder.c
@@ -80,7 +80,7 @@ static int debuginfo__init_offline_dwarf(struct debuginfo *dbg,
 		close(fd);
 	memset(dbg, 0, sizeof(*dbg));
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static struct debuginfo *__debuginfo__new(const char *path)
@@ -195,19 +195,19 @@ static int convert_variable_location(Dwarf_Die *vr_die, Dwarf_Addr addr,
 	if (dwarf_getlocation_addr(&attr, addr, &op, &nops, 1) <= 0) {
 		ret = dwarf_entrypc(sp_die, &tmp);
 		if (ret)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 
 		if (probe_conf.show_location_range &&
 			(dwarf_tag(vr_die) == DW_TAG_variable)) {
 			ret2 = -ERANGE;
 		} else if (addr != tmp ||
 			dwarf_tag(vr_die) != DW_TAG_formal_parameter) {
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		ret = dwarf_highpc(sp_die, &tmp);
 		if (ret)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		/*
 		 * This is fuzzed by fentry mcount. We try to find the
 		 * parameter location at the earliest address.
@@ -217,12 +217,12 @@ static int convert_variable_location(Dwarf_Die *vr_die, Dwarf_Addr addr,
 						   &nops, 1) > 0)
 				goto found;
 		}
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 found:
 	if (nops == 0)
 		/* TODO: Support const_value */
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (op->atom == DW_OP_addr) {
 static_var:
@@ -319,7 +319,7 @@ static int convert_variable_type(Dwarf_Die *vr_die,
 		boffs = dwarf_bitoffset(vr_die);
 		total = dwarf_bytesize(vr_die);
 		if (boffs < 0 || total < 0)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		ret = snprintf(buf, 16, "b%d@%d/%zd", bsize, boffs,
 				BYTES_TO_BITS(total));
 		goto formatted;
@@ -328,7 +328,7 @@ static int convert_variable_type(Dwarf_Die *vr_die,
 	if (die_get_real_type(vr_die, &type) == NULL) {
 		pr_warning("Failed to get a type information of %s.\n",
 			   dwarf_diename(vr_die));
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	pr_debug("%s type is %s.\n",
@@ -347,7 +347,7 @@ static int convert_variable_type(Dwarf_Die *vr_die,
 		if (die_get_real_type(&type, &type) == NULL) {
 			pr_warning("Failed to get a type"
 				   " information.\n");
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (ret == DW_TAG_pointer_type) {
 			while (*ref_ptr)
@@ -423,7 +423,7 @@ static int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,
 	pr_debug("converting %s in %s\n", field->name, varname);
 	if (die_get_real_type(vr_die, &type) == NULL) {
 		pr_warning("Failed to get the type of %s.\n", varname);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	pr_debug2("Var real type: %s (%x)\n", dwarf_diename(&type),
 		  (unsigned)dwarf_dieoffset(&type));
@@ -436,7 +436,7 @@ static int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,
 		/* Get the type of this array */
 		if (die_get_real_type(&type, &type) == NULL) {
 			pr_warning("Failed to get the type of %s.\n", varname);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		pr_debug2("Array real type: %s (%x)\n", dwarf_diename(&type),
 			 (unsigned)dwarf_dieoffset(&type));
@@ -462,7 +462,7 @@ static int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,
 		/* Get the type pointed by this pointer */
 		if (die_get_real_type(&type, &type) == NULL) {
 			pr_warning("Failed to get the type of %s.\n", varname);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		/* Verify it is a data structure  */
 		tag = dwarf_tag(&type);
@@ -649,7 +649,7 @@ static int convert_to_trace_point(Dwarf_Die *sp_die, Dwfl_Module *mod,
 	if (!symbol) {
 		pr_warning("Failed to find symbol at 0x%lx\n",
 			   (unsigned long)paddr);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	tp->offset = (unsigned long)(paddr - eaddr);
@@ -696,7 +696,7 @@ static int call_probe_finder(Dwarf_Die *sc_die, struct probe_finder *pf)
 			} else {
 				pr_warning("Failed to find probe point in any "
 					   "functions.\n");
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 		}
 	} else
@@ -716,7 +716,7 @@ static int call_probe_finder(Dwarf_Die *sc_die, struct probe_finder *pf)
 			pr_warning("Failed to get call frame on 0x%jx\n",
 				   (uintmax_t)pf->addr);
 			free(frame);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 #endif
 	}
@@ -834,7 +834,7 @@ static int verify_representive_line(struct probe_finder *pf, const char *fname,
 	pr_warning("Please try to probe at %s:%d instead.\n",
 		   __func ? : __fname, __lineno);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 static int probe_point_line_walker(const char *fname, int lineno,
@@ -848,13 +848,13 @@ static int probe_point_line_walker(const char *fname, int lineno,
 		return 0;
 
 	if (verify_representive_line(pf, fname, lineno, addr))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	pf->addr = addr;
 	sc_die = find_best_scope(pf, &die_mem);
 	if (!sc_die) {
 		pr_warning("Failed to find scope of probe point.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = call_probe_finder(sc_die, pf);
@@ -927,7 +927,7 @@ static int probe_point_lazy_walker(const char *fname, int lineno,
 	sc_die = find_best_scope(pf, &die_mem);
 	if (!sc_die) {
 		pr_warning("Failed to find scope of probe point.\n");
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	ret = call_probe_finder(sc_die, pf);
@@ -1012,12 +1012,12 @@ static int probe_point_inline_cb(Dwarf_Die *in_die, void *data)
 		if (die_entrypc(in_die, &addr) != 0) {
 			pr_warning("Failed to get entry address of %s.\n",
 				   dwarf_diename(in_die));
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		if (addr == 0) {
 			pr_debug("%s has no valid entry address. skipped.\n",
 				 dwarf_diename(in_die));
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		pf->addr = addr;
 		pf->addr += pp->offset;
@@ -1418,7 +1418,7 @@ static int fill_empty_trace_arg(struct perf_probe_event *pev,
 		}
 		if (j == ntevs) {
 			print_var_not_found(pev->args[i].var);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 		for (j = 0; j < ntevs; j++) {
 			valp = &tevs[j].args[i].value;
@@ -1660,7 +1660,7 @@ int debuginfo__get_text_offset(struct debuginfo *dbg, Dwarf_Addr *offs,
 	/* Get the number of relocations */
 	n = dwfl_module_relocations(dbg->mod);
 	if (n < 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	/* Search the relocation related .text section */
 	for (i = 0; i < n; i++) {
 		p = dwfl_module_relocation_info(dbg->mod, i, &shndx);
@@ -1668,10 +1668,10 @@ int debuginfo__get_text_offset(struct debuginfo *dbg, Dwarf_Addr *offs,
 			/* OK, get the section header */
 			scn = elf_getscn(elf, shndx);
 			if (!scn)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			shdr = gelf_getshdr(scn, &mem);
 			if (!shdr)
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			*offs = shdr->sh_addr;
 			if (adjust_offset)
 				*offs -= shdr->sh_offset;
@@ -2018,7 +2018,7 @@ int get_real_path(const char *raw_path, const char *comp_dir,
 			raw_path = strchr(++raw_path, '/');
 			if (!raw_path) {
 				zfree(new_path);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 			continue;
 
diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c
index 1a157e84a..e4de73401 100644
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@ -2441,7 +2441,7 @@ int perf_event__process_id_index(struct perf_session *session,
 
 		sid = perf_evlist__id2sid(evlist, e->id);
 		if (!sid)
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		sid->idx = e->idx;
 		sid->cpu = e->cpu;
 		sid->tid = e->tid;
diff --git a/tools/perf/util/sort.c b/tools/perf/util/sort.c
index d42339df2..9928f541e 100644
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@ -2465,7 +2465,7 @@ static int add_dynamic_entry(struct evlist *evlist, const char *tok,
 	int ret = 0;
 
 	if (evlist == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	str = strdup(tok);
 	if (str == NULL)
@@ -2515,7 +2515,7 @@ static int add_dynamic_entry(struct evlist *evlist, const char *tok,
 		if (field == NULL) {
 			pr_debug("Cannot find event field for %s.%s\n",
 				 event_name, field_name);
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		}
 
 		ret = __dynamic_dimension__add(evsel, field, raw_trace, level);
diff --git a/tools/perf/util/symbol.c b/tools/perf/util/symbol.c
index 5ddf84dcb..d07807319 100644
--- a/tools/perf/util/symbol.c
+++ b/tools/perf/util/symbol.c
@@ -1156,7 +1156,7 @@ static int validate_kcore_addresses(const char *kallsyms_filename,
 
 		if (kallsyms__get_function_start(kallsyms_filename,
 						 kmap->ref_reloc_sym->name, &start))
-			return -ENOENT;
+			ENOENT_DUMPER(stackdump_tuneable);
 		if (start != kmap->ref_reloc_sym->addr)
 			return -EINVAL;
 	}
diff --git a/tools/perf/util/synthetic-events.c b/tools/perf/util/synthetic-events.c
index 89b390623..cc2a37ef4 100644
--- a/tools/perf/util/synthetic-events.c
+++ b/tools/perf/util/synthetic-events.c
@@ -1643,7 +1643,7 @@ int perf_event__synthesize_id_index(struct perf_tool *tool, perf_event__handler_
 			sid = perf_evlist__id2sid(evlist, e->id);
 			if (!sid) {
 				free(ev);
-				return -ENOENT;
+				ENOENT_DUMPER(stackdump_tuneable);
 			}
 
 			e->idx = sid->idx;
diff --git a/tools/testing/selftests/bpf/trace_helpers.c b/tools/testing/selftests/bpf/trace_helpers.c
index 4d0e913bb..407e799ba 100644
--- a/tools/testing/selftests/bpf/trace_helpers.c
+++ b/tools/testing/selftests/bpf/trace_helpers.c
@@ -31,7 +31,7 @@ int load_kallsyms(void)
 	int i = 0;
 
 	if (!f)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	while (fgets(buf, sizeof(buf), f)) {
 		if (sscanf(buf, "%p %c %s", &addr, &symbol, func) != 3)
diff --git a/tools/testing/selftests/memfd/fuse_mnt.c b/tools/testing/selftests/memfd/fuse_mnt.c
index 6936f2a00..8e68b3898 100644
--- a/tools/testing/selftests/memfd/fuse_mnt.c
+++ b/tools/testing/selftests/memfd/fuse_mnt.c
@@ -36,7 +36,7 @@ static int memfd_getattr(const char *path, struct stat *st)
 		st->st_nlink = 1;
 		st->st_size = strlen(memfd_content);
 	} else {
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 
 	return 0;
@@ -49,7 +49,7 @@ static int memfd_readdir(const char *path,
 			 struct fuse_file_info *fi)
 {
 	if (strcmp(path, "/"))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	filler(buf, ".", NULL, 0);
 	filler(buf, "..", NULL, 0);
@@ -61,7 +61,7 @@ static int memfd_readdir(const char *path,
 static int memfd_open(const char *path, struct fuse_file_info *fi)
 {
 	if (strcmp(path, memfd_path))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if ((fi->flags & 3) != O_RDONLY)
 		return -EACCES;
@@ -81,7 +81,7 @@ static int memfd_read(const char *path,
 	size_t len;
 
 	if (strcmp(path, memfd_path) != 0)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	sleep(1);
 
diff --git a/tools/testing/selftests/resctrl/resctrlfs.c b/tools/testing/selftests/resctrl/resctrlfs.c
index 19c0ec404..6ceaa7b09 100644
--- a/tools/testing/selftests/resctrl/resctrlfs.c
+++ b/tools/testing/selftests/resctrl/resctrlfs.c
@@ -46,7 +46,7 @@ static int find_resctrl_mount(char *buffer)
 
 	fclose(mounts);
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 char cbm_mask[256];
@@ -508,7 +508,7 @@ int write_schemata(char *ctrlgrp, char *schemata, int cpu_no, char *resctrl_val)
 	if ((strcmp(resctrl_val, "mba") != 0) &&
 	    (strcmp(resctrl_val, "cat") != 0) &&
 	    (strcmp(resctrl_val, "cqm") != 0))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (!schemata) {
 		printf("# Skipping empty schemata update\n");
diff --git a/tools/thermal/tmon/sysfs.c b/tools/thermal/tmon/sysfs.c
index b00b1bfd9..fed0ebe14 100644
--- a/tools/thermal/tmon/sysfs.c
+++ b/tools/thermal/tmon/sysfs.c
@@ -114,7 +114,7 @@ static int str_to_trip_type(char *name)
 			return i;
 	}
 
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* scan and fill in trip point info for a thermal zone and trip point id */
@@ -132,7 +132,7 @@ static int get_trip_point_data(char *tz_path, int tzid, int tpid)
 	trip_type = str_to_trip_type(temp_str);
 	if (trip_type < 0) {
 		syslog(LOG_ERR, "%s:%s no matching type\n", __func__, temp_str);
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 	}
 	ptdata.tzi[tzid].tp[tpid].type = trip_type;
 	syslog(LOG_INFO, "%s:tz:%d tp:%d:type:%s type id %d\n", __func__, tzid,
@@ -470,7 +470,7 @@ int zone_instance_to_index(int zone_inst)
 	for (i = 0; i < ptdata.nr_tz_sensor; i++)
 		if (ptdata.tzi[i].instance == zone_inst)
 			return i;
-	return -ENOENT;
+	ENOENT_DUMPER(stackdump_tuneable);
 }
 
 /* read temperature of all thermal zones */
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 0a68c9d3d..aa6f3c2b5 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -1374,7 +1374,7 @@ int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log,
 	slots = __kvm_memslots(kvm, as_id);
 	*memslot = id_to_memslot(slots, id);
 	if (!(*memslot) || !(*memslot)->dirty_bitmap)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	kvm_arch_sync_dirty_log(kvm, *memslot);
 
@@ -1432,7 +1432,7 @@ static int kvm_get_dirty_log_protect(struct kvm *kvm, struct kvm_dirty_log *log)
 	slots = __kvm_memslots(kvm, as_id);
 	memslot = id_to_memslot(slots, id);
 	if (!memslot || !memslot->dirty_bitmap)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dirty_bitmap = memslot->dirty_bitmap;
 
@@ -1543,7 +1543,7 @@ static int kvm_clear_dirty_log_protect(struct kvm *kvm,
 	slots = __kvm_memslots(kvm, as_id);
 	memslot = id_to_memslot(slots, id);
 	if (!memslot || !memslot->dirty_bitmap)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	dirty_bitmap = memslot->dirty_bitmap;
 
@@ -4100,7 +4100,7 @@ static int kvm_io_bus_get_first_dev(struct kvm_io_bus *bus,
 	range = bsearch(&key, bus->range, bus->dev_count,
 			sizeof(struct kvm_io_range), kvm_io_bus_sort_cmp);
 	if (range == NULL)
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	off = range - bus->range;
 
@@ -4341,7 +4341,7 @@ static int kvm_debugfs_open(struct inode *inode, struct file *file,
 	 * directory we test against the users count.
 	 */
 	if (!refcount_inc_not_zero(&stat_data->kvm->users_count))
-		return -ENOENT;
+		ENOENT_DUMPER(stackdump_tuneable);
 
 	if (simple_attr_open(inode, file, get,
 		    KVM_DBGFS_GET_MODE(stat_data->dbgfs_item) & 0222
-- 
2.25.4

